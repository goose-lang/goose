(* autogenerated from github.com/tchajed/goose/internal/examples/unittest *)
From Perennial.new_goose_lang Require Import prelude.
From Goose Require github_com.tchajed.goose.internal.examples.unittest.generic.
From Goose Require github_com.tchajed.goose.machine.
From Goose Require github_com.tchajed.goose.machine.disk.
From Goose Require github_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.disk_prelude.

(* comments.go *)

(* unittest is a package full of many independent and small translation examples *)

Definition importantStruct := struct.decl [
].

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing) *)
Definition doSubtleThings: val :=
  rec: "doSubtleThings" <> :=
    exception_do do:  #().

(* This comment starts a Coq comment ( * *)
Definition hasStartComment: val :=
  rec: "hasStartComment" <> :=
    exception_do do:  #().

(* This comment * ) ends a Coq comment *)
Definition hasEndComment: val :=
  rec: "hasEndComment" <> :=
    exception_do do:  #().

(* condvar.go *)

Definition condvarWrapping: val :=
  rec: "condvarWrapping" <> :=
    exception_do (let: "mu" := ref (zero_val ptrT) in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "mu" <-[ptrT] "$a0";;;
    let: "cond1" := ref_zero ptrT #() in
    let: "$a0" := sync.NewCond (![ptrT] "mu") in
    do:  "cond1" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "mu" <-[ptrT] "$a0";;;
    do:  sync.Cond__Wait (![ptrT] "cond1");;;
    do:  #()).

(* const.go *)

Definition GlobalConstant : expr := #(str "foo").

(* an untyped string *)
Definition UntypedStringConstant : expr := #(str "bar").

Definition TypedInt : expr := #32.

Definition ConstWithArith : expr := #4 + (#3 * TypedInt).

Definition TypedInt32 : expr := #(U32 3).

Definition DivisionInConst : expr := (#4096 - #8) `quot` #8.

(* 517 *)
Definition ModInConst : expr := #513 + (#12 `rem` #8).

(* 5 *)
Definition ModInConstParens : expr := (#513 + #12) `rem` #8.

(* control_flow.go *)

Definition conditionalReturn: val :=
  rec: "conditionalReturn" "x" :=
    exception_do (let: "x" := ref_to boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#0);;;
      do:  #()
    else do:  #());;;
    return: (#1);;;
    do:  #()).

Definition alwaysReturn: val :=
  rec: "alwaysReturn" "x" :=
    exception_do (let: "x" := ref_to boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#0);;;
      do:  #()
    else
      return: (#1);;;
      do:  #());;;
    do:  #()).

Definition alwaysReturnInNestedBranches: val :=
  rec: "alwaysReturnInNestedBranches" "x" :=
    exception_do (let: "x" := ref_to boolT "x" in
    (if: (~ (![boolT] "x"))
    then
      (if: ![boolT] "x"
      then
        return: (#0);;;
        do:  #()
      else
        return: (#1);;;
        do:  #());;;
      do:  #()
    else do:  #());;;
    let: "y" := ref_zero uint64T #() in
    let: "$a0" := #14 in
    do:  "y" <-[uint64T] "$a0";;;
    return: (![uint64T] "y");;;
    do:  #()).

Definition earlyReturn: val :=
  rec: "earlyReturn" "x" :=
    exception_do (let: "x" := ref_to boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#());;;
      do:  #()
    else do:  #());;;
    do:  #()).

Definition conditionalAssign: val :=
  rec: "conditionalAssign" "x" :=
    exception_do (let: "x" := ref_to boolT "x" in
    let: "y" := ref (zero_val uint64T) in
    (if: ![boolT] "x"
    then
      let: "$a0" := #1 in
      do:  "y" <-[uint64T] "$a0";;;
      do:  #()
    else
      let: "$a0" := #2 in
      do:  "y" <-[uint64T] "$a0";;;
      do:  #());;;
    do:  "y" <-[uint64T] ((![uint64T] "y") + #1);;;
    return: (![uint64T] "y");;;
    do:  #()).

Definition elseIf: val :=
  rec: "elseIf" "x" "y" :=
    exception_do (let: "y" := ref_to boolT "y" in
    let: "x" := ref_to boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#0);;;
      do:  #()
    else
      (if: ![boolT] "y"
      then
        return: (#1);;;
        do:  #()
      else
        return: (#2);;;
        do:  #());;;
      #());;;
    do:  #()).

(* conversions.go *)

Definition stringWrapper: ty := stringT.

Definition typedLiteral: val :=
  rec: "typedLiteral" <> :=
    exception_do (return: (#3);;;
    do:  #()).

Definition literalCast: val :=
  rec: "literalCast" <> :=
    exception_do (let: "x" := ref_zero uint64T #() in
    let: "$a0" := #2 in
    do:  "x" <-[uint64T] "$a0";;;
    return: ((![uint64T] "x") + #2);;;
    do:  #()).

Definition castInt: val :=
  rec: "castInt" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    return: (slice.len (![sliceT byteT] "p"));;;
    do:  #()).

Definition stringToByteSlice: val :=
  rec: "stringToByteSlice" "s" :=
    exception_do (let: "s" := ref_to stringT "s" in
    let: "p" := ref_zero (sliceT byteT) #() in
    let: "$a0" := StringToBytes (![stringT] "s") in
    do:  "p" <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "p");;;
    do:  #()).

Definition byteSliceToString: val :=
  rec: "byteSliceToString" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    let: "s" := ref_zero stringT #() in
    let: "$a0" := StringFromBytes (![sliceT byteT] "p") in
    do:  "s" <-[stringT] "$a0";;;
    return: (![stringT] "s");;;
    do:  #()).

Definition stringToStringWrapper: val :=
  rec: "stringToStringWrapper" "s" :=
    exception_do (let: "s" := ref_to stringT "s" in
    return: (![stringT] "s");;;
    do:  #()).

Definition stringWrapperToString: val :=
  rec: "stringWrapperToString" "s" :=
    exception_do (let: "s" := ref_to stringWrapper "s" in
    return: (![stringWrapper] "s");;;
    do:  #()).

(* copy.go *)

Definition testCopySimple: val :=
  rec: "testCopySimple" <> :=
    exception_do (let: "x" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #10 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 1) in
    do:  SliceSet byteT (![sliceT byteT] "x") #3 "$a0";;;
    let: "y" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #10 in
    do:  "y" <-[sliceT byteT] "$a0";;;
    do:  SliceCopy byteT (![sliceT byteT] "y") (![sliceT byteT] "x");;;
    return: ((SliceGet byteT (![sliceT byteT] "y") #3) = #(U8 1));;;
    do:  #()).

Definition testCopyDifferentLengths: val :=
  rec: "testCopyDifferentLengths" <> :=
    exception_do (let: "x" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #15 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 1) in
    do:  SliceSet byteT (![sliceT byteT] "x") #3 "$a0";;;
    let: "$a0" := #(U8 2) in
    do:  SliceSet byteT (![sliceT byteT] "x") #12 "$a0";;;
    let: "y" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #10 in
    do:  "y" <-[sliceT byteT] "$a0";;;
    let: "n" := ref_zero uint64T #() in
    let: "$a0" := SliceCopy byteT (![sliceT byteT] "y") (![sliceT byteT] "x") in
    do:  "n" <-[uint64T] "$a0";;;
    return: (((![uint64T] "n") = #10) && ((SliceGet byteT (![sliceT byteT] "y") #3) = #(U8 1)));;;
    do:  #()).

(* data_structures.go *)

Definition atomicCreateStub: val :=
  rec: "atomicCreateStub" "dir" "fname" "data" :=
    exception_do (let: "data" := ref_to (sliceT byteT) "data" in
    let: "fname" := ref_to stringT "fname" in
    let: "dir" := ref_to stringT "dir" in
    do:  #()).

Definition useSlice: val :=
  rec: "useSlice" <> :=
    exception_do (let: "s" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #1 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    let: "s1" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceAppendSlice byteT (![sliceT byteT] "s") (![sliceT byteT] "s") in
    do:  "s1" <-[sliceT byteT] "$a0";;;
    do:  atomicCreateStub #(str "dir") #(str "file") (![sliceT byteT] "s1");;;
    do:  #()).

Definition useSliceIndexing: val :=
  rec: "useSliceIndexing" <> :=
    exception_do (let: "s" := ref_zero (sliceT uint64T) #() in
    let: "$a0" := NewSlice uint64T #2 in
    do:  "s" <-[sliceT uint64T] "$a0";;;
    let: "$a0" := #2 in
    do:  SliceSet uint64T (![sliceT uint64T] "s") #1 "$a0";;;
    let: "x" := ref_zero uint64T #() in
    let: "$a0" := SliceGet uint64T (![sliceT uint64T] "s") #0 in
    do:  "x" <-[uint64T] "$a0";;;
    return: (![uint64T] "x");;;
    do:  #()).

Definition useMap: val :=
  rec: "useMap" <> :=
    exception_do (let: "m" := ref_zero (mapT (sliceT byteT)) #() in
    let: "$a0" := NewMap uint64T (sliceT byteT) #() in
    do:  "m" <-[mapT (sliceT byteT)] "$a0";;;
    let: "$a0" := slice.nil in
    do:  MapInsert (![mapT (sliceT byteT)] "m") #1 "$a0";;;
    let: "ok" := ref_zero boolT #() in
    let: "x" := ref_zero (sliceT byteT) #() in
    let: ("$a0", "$a1") := Fst (MapGet (![mapT (sliceT byteT)] "m") #2) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "x" <-[sliceT byteT] "$a0";;;
    (if: ![boolT] "ok"
    then
      return: (#());;;
      do:  #()
    else do:  #());;;
    let: "$a0" := ![sliceT byteT] "x" in
    do:  MapInsert (![mapT (sliceT byteT)] "m") #3 "$a0";;;
    do:  #()).

Definition usePtr: val :=
  rec: "usePtr" <> :=
    exception_do (let: "p" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val uint64T) in
    do:  "p" <-[ptrT] "$a0";;;
    let: "$a0" := #1 in
    do:  (![ptrT] "p") <-[uint64T] "$a0";;;
    let: "x" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![ptrT] "p") in
    do:  "x" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "x" in
    do:  (![ptrT] "p") <-[uint64T] "$a0";;;
    do:  #()).

Definition iterMapKeysAndValues: val :=
  rec: "iterMapKeysAndValues" "m" :=
    exception_do (let: "m" := ref_to (mapT uint64T) "m" in
    let: "sumPtr" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val uint64T) in
    do:  "sumPtr" <-[ptrT] "$a0";;;
    do:  MapIter (![mapT uint64T] "m") (λ: "k" "v",
      let: "sum" := ref_zero uint64T #() in
      let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
      do:  "sum" <-[uint64T] "$a0";;;
      let: "$a0" := ((![uint64T] "sum") + (![uint64T] "k")) + (![uint64T] "v") in
      do:  (![ptrT] "sumPtr") <-[uint64T] "$a0";;;
      do:  #());;;
    let: "sum" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
    do:  "sum" <-[uint64T] "$a0";;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition iterMapKeys: val :=
  rec: "iterMapKeys" "m" :=
    exception_do (let: "m" := ref_to (mapT uint64T) "m" in
    let: "keysSlice" := ref_zero (sliceT uint64T) #() in
    let: "$a0" := NewSlice uint64T #0 in
    do:  "keysSlice" <-[sliceT uint64T] "$a0";;;
    let: "keysRef" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val (sliceT uint64T)) in
    do:  "keysRef" <-[ptrT] "$a0";;;
    let: "$a0" := ![sliceT uint64T] "keysSlice" in
    do:  (![ptrT] "keysRef") <-[sliceT uint64T] "$a0";;;
    do:  MapIter (![mapT uint64T] "m") (λ: "k" <>,
      let: "keys" := ref_zero (sliceT uint64T) #() in
      let: "$a0" := ![sliceT uint64T] (![ptrT] "keysRef") in
      do:  "keys" <-[sliceT uint64T] "$a0";;;
      let: "newKeys" := ref_zero (sliceT uint64T) #() in
      let: "$a0" := SliceAppend uint64T (![sliceT uint64T] "keys") (![uint64T] "k") in
      do:  "newKeys" <-[sliceT uint64T] "$a0";;;
      let: "$a0" := ![sliceT uint64T] "newKeys" in
      do:  (![ptrT] "keysRef") <-[sliceT uint64T] "$a0";;;
      do:  #());;;
    let: "keys" := ref_zero (sliceT uint64T) #() in
    let: "$a0" := ![sliceT uint64T] (![ptrT] "keysRef") in
    do:  "keys" <-[sliceT uint64T] "$a0";;;
    return: (![sliceT uint64T] "keys");;;
    do:  #()).

Definition getRandom: val :=
  rec: "getRandom" <> :=
    exception_do (let: "r" := ref_zero uint64T #() in
    let: "$a0" := machine.RandomUint64 #() in
    do:  "r" <-[uint64T] "$a0";;;
    return: (![uint64T] "r");;;
    do:  #()).

(* disk.go *)

Definition diskWrapper := struct.decl [
  "d" :: disk.Disk
].

Definition diskArgument: val :=
  rec: "diskArgument" "d" :=
    exception_do (let: "d" := ref_to disk.Disk "d" in
    let: "b" := ref_zero (sliceT byteT) #() in
    let: "$a0" := (struct.get disk.Disk "Read") (![disk.Disk] "d") #0 in
    do:  "b" <-[sliceT byteT] "$a0";;;
    do:  (struct.get disk.Disk "Write") (![disk.Disk] "d") #1 (![sliceT byteT] "b");;;
    do:  #()).

(* empty_functions.go *)

Definition empty: val :=
  rec: "empty" <> :=
    exception_do do:  #().

Definition emptyReturn: val :=
  rec: "emptyReturn" <> :=
    exception_do (return: (#());;;
    do:  #()).

(* encoding.go *)

Definition Enc := struct.decl [
  "p" :: sliceT byteT
].

Definition Enc__consume: val :=
  rec: "Enc__consume" "e" "n" :=
    exception_do (let: "n" := ref_to uint64T "n" in
    let: "e" := ref_to ptrT "e" in
    let: "b" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceTake (![struct.fieldTy Enc "p"] (struct.fieldRef Enc "p" (![ptrT] "e"))) (![uint64T] "n") in
    do:  "b" <-[sliceT byteT] "$a0";;;
    let: "$a0" := SliceSkip byteT (![struct.fieldTy Enc "p"] (struct.fieldRef Enc "p" (![ptrT] "e"))) (![uint64T] "n") in
    do:  (struct.fieldRef Enc "p" (![ptrT] "e") "$a0") <-[struct.fieldTy Enc "p"] "$a0";;;
    return: (![sliceT byteT] "b");;;
    do:  #()).

Definition Enc__UInt64: val :=
  rec: "Enc__UInt64" "e" "x" :=
    exception_do (let: "x" := ref_to uint64T "x" in
    let: "e" := ref_to ptrT "e" in
    do:  machine.UInt64Put (Enc__consume (![ptrT] "e") #8) (![uint64T] "x");;;
    do:  #()).

Definition Enc__UInt32: val :=
  rec: "Enc__UInt32" "e" "x" :=
    exception_do (let: "x" := ref_to uint32T "x" in
    let: "e" := ref_to ptrT "e" in
    do:  machine.UInt32Put (Enc__consume (![ptrT] "e") #4) (![uint32T] "x");;;
    do:  #()).

Definition Dec := struct.decl [
  "p" :: sliceT byteT
].

Definition Dec__consume: val :=
  rec: "Dec__consume" "d" "n" :=
    exception_do (let: "n" := ref_to uint64T "n" in
    let: "d" := ref_to ptrT "d" in
    let: "b" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceTake (![struct.fieldTy Dec "p"] (struct.fieldRef Dec "p" (![ptrT] "d"))) (![uint64T] "n") in
    do:  "b" <-[sliceT byteT] "$a0";;;
    let: "$a0" := SliceSkip byteT (![struct.fieldTy Dec "p"] (struct.fieldRef Dec "p" (![ptrT] "d"))) (![uint64T] "n") in
    do:  (struct.fieldRef Dec "p" (![ptrT] "d") "$a0") <-[struct.fieldTy Dec "p"] "$a0";;;
    return: (![sliceT byteT] "b");;;
    do:  #()).

Definition Dec__UInt64: val :=
  rec: "Dec__UInt64" "d" :=
    exception_do (let: "d" := ref_to ptrT "d" in
    return: (machine.UInt64Get (Dec__consume (![ptrT] "d") #8));;;
    do:  #()).

Definition Dec__UInt32: val :=
  rec: "Dec__UInt32" "d" :=
    exception_do (let: "d" := ref_to ptrT "d" in
    return: (machine.UInt32Get (Dec__consume (![ptrT] "d") #4));;;
    do:  #()).

(* generics.go *)

Definition genericId (T:ty): val :=
  rec: "genericId" "x" :=
    exception_do (let: "x" := ref_to T "x" in
    return: (![T] "x");;;
    do:  #()).

Definition useGenericImplicitly: val :=
  rec: "useGenericImplicitly" "x" :=
    exception_do (let: "x" := ref_to uint64T "x" in
    return: (genericId uint64T (![uint64T] "x"));;;
    do:  #()).

Definition useGenericAtTypeParam (T:ty): val :=
  rec: "useGenericAtTypeParam" "x" :=
    exception_do (let: "x" := ref_to T "x" in
    return: (genericId T (![T] "x"));;;
    do:  #()).

Definition useGenericExplicitly (T:ty): val :=
  rec: "useGenericExplicitly" "x" :=
    exception_do (let: "x" := ref_to T "x" in
    return: (genericId T (![T] "x"));;;
    do:  #()).

Definition loadGeneric (T:ty): val :=
  rec: "loadGeneric" "x" :=
    exception_do (let: "x" := ref_to ptrT "x" in
    return: (![T] (![ptrT] "x"));;;
    do:  #()).

Definition allocateGeneric (T:ty): val :=
  rec: "allocateGeneric" <> :=
    exception_do (return: (ref (zero_val T));;;
    do:  #()).

Definition multipleTypes (T:ty) (V:ty): val :=
  rec: "multipleTypes" "x" "v" :=
    exception_do (let: "v" := ref_to V "v" in
    let: "x" := ref_to T "x" in
    return: (![V] "v");;;
    do:  #()).

Definition callWithMultipleTypes: val :=
  rec: "callWithMultipleTypes" <> :=
    exception_do (do:  multipleTypes uint64T boolT #3 #true;;;
    do:  #()).

Definition callWithMultipleTypesImplicit: val :=
  rec: "callWithMultipleTypesImplicit" <> :=
    exception_do (do:  multipleTypes boolT uint64T #false #2;;;
    do:  #()).

Definition callWithPartialInstantiation: val :=
  rec: "callWithPartialInstantiation" <> :=
    exception_do (do:  multipleTypes boolT uint64T #false #2;;;
    do:  #()).

Definition useGenericImported: val :=
  rec: "useGenericImported" <> :=
    exception_do (return: (generic.Id boolT #true);;;
    do:  #()).

Definition void := struct.decl [
].

Definition useMapClear: val :=
  rec: "useMapClear" <> :=
    exception_do (let: "m" := ref_zero (mapT (structT void)) #() in
    let: "$a0" := NewMap uint64T (structT void) #() in
    do:  "m" <-[mapT (structT void)] "$a0";;;
    let: "$a0" := struct.mk void [
    ] in
    do:  MapInsert (![mapT (structT void)] "m") #1 "$a0";;;
    return: (generic.MapLen (structT void) (![mapT (structT void)] "m"));;;
    do:  #()).

(* higher_order.go *)

Definition TakesFunctionType: val :=
  rec: "TakesFunctionType" "f" :=
    exception_do (let: "f" := ref_to (unitT -> unitT)%ht "f" in
    do:  (![(arrowT unitT unitT)] "f") #();;;
    do:  #()).

(* ints.go *)

Definition useInts: val :=
  rec: "useInts" "x" "y" :=
    exception_do (let: "y" := ref_to uint32T "y" in
    let: "x" := ref_to uint64T "x" in
    let: "z" := ref (zero_val uint64T) in
    let: "$a0" := to_u64 (![uint32T] "y") in
    do:  "z" <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] "z") + #1 in
    do:  "z" <-[uint64T] "$a0";;;
    let: "y2" := ref (zero_val uint32T) in
    let: "$a0" := (![uint32T] "y") + #(U32 3) in
    do:  "y2" <-[uint32T] "$a0";;;
    return: (![uint64T] "z", ![uint32T] "y2");;;
    do:  #()).

Definition my_u32: ty := uint32T.

Definition also_u32: ty := my_u32.

Definition ConstWithAbbrevType : expr := #(U32 3).

(* literals.go *)

Definition allTheLiterals := struct.decl [
  "int" :: uint64T;
  "s" :: stringT;
  "b" :: boolT
].

Definition normalLiterals: val :=
  rec: "normalLiterals" <> :=
    exception_do (return: (struct.mk allTheLiterals [
       "int" ::= #0;
       "s" ::= #(str "foo");
       "b" ::= #true
     ]);;;
    do:  #()).

Definition specialLiterals: val :=
  rec: "specialLiterals" <> :=
    exception_do (return: (struct.mk allTheLiterals [
       "int" ::= #4096;
       "s" ::= #(str "");
       "b" ::= #false
     ]);;;
    do:  #()).

Definition oddLiterals: val :=
  rec: "oddLiterals" <> :=
    exception_do (return: (struct.mk allTheLiterals [
       "int" ::= #5;
       "s" ::= #(str "backquote string");
       "b" ::= #false
     ]);;;
    do:  #()).

(* locks.go *)

Definition useLocks: val :=
  rec: "useLocks" <> :=
    exception_do (let: "m" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "m" <-[ptrT] "$a0";;;
    do:  sync.Mutex__Lock (![ptrT] "m");;;
    do:  sync.Mutex__Unlock (![ptrT] "m");;;
    do:  #()).

Definition useCondVar: val :=
  rec: "useCondVar" <> :=
    exception_do (let: "m" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "m" <-[ptrT] "$a0";;;
    let: "c" := ref_zero ptrT #() in
    let: "$a0" := sync.NewCond (![ptrT] "m") in
    do:  "c" <-[ptrT] "$a0";;;
    do:  sync.Mutex__Lock (![ptrT] "m");;;
    do:  sync.Cond__Signal (![ptrT] "c");;;
    do:  sync.Cond__Wait (![ptrT] "c");;;
    do:  sync.Mutex__Unlock (![ptrT] "m");;;
    do:  #()).

Definition hasCondVar := struct.decl [
  "cond" :: ptrT
].

(* log_debugging.go *)

Definition ToBeDebugged: val :=
  rec: "ToBeDebugged" "x" :=
    exception_do (let: "x" := ref_to uint64T "x" in
    do:  log.Println #(str "starting function");;;
    do:  log.Printf #(str "called with %!!(MISSING)d(MISSING)") (![uint64T] "x");;;
    do:  log.Println #(str "ending function");;;
    return: (![uint64T] "x");;;
    do:  #()).

Definition DoNothing: val :=
  rec: "DoNothing" <> :=
    exception_do (do:  log.Println #(str "doing nothing");;;
    do:  #()).

(* loops.go *)

(* DoSomething is an impure function *)
Definition DoSomething: val :=
  rec: "DoSomething" "s" :=
    exception_do (let: "s" := ref_to stringT "s" in
    do:  #()).

Definition standardForLoop: val :=
  rec: "standardForLoop" "s" :=
    exception_do (let: "s" := ref_to (sliceT uint64T) "s" in
    let: "sumPtr" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val uint64T) in
    do:  "sumPtr" <-[ptrT] "$a0";;;
    (let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (slice.len (![sliceT uint64T] "s"))
      then
        let: "sum" := ref_zero uint64T #() in
        let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
        do:  "sum" <-[uint64T] "$a0";;;
        let: "x" := ref_zero uint64T #() in
        let: "$a0" := SliceGet uint64T (![sliceT uint64T] "s") (![uint64T] "i") in
        do:  "x" <-[uint64T] "$a0";;;
        let: "$a0" := (![uint64T] "sum") + (![uint64T] "x") in
        do:  (![ptrT] "sumPtr") <-[uint64T] "$a0";;;
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()
      else do:  #());;;
      break: #();;;
      do:  #()));;;
    let: "sum" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
    do:  "sum" <-[uint64T] "$a0";;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition conditionalInLoop: val :=
  rec: "conditionalInLoop" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #3
      then
        do:  DoSomething #(str "i is small");;;
        do:  #()
      else do:  #());;;
      (if: (![uint64T] "i") > #5
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] "i") + #1 in
      do:  "i" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

Definition conditionalInLoopElse: val :=
  rec: "conditionalInLoopElse" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #5
      then
        break: #();;;
        do:  #()
      else
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #());;;
      do:  #()));;;
    do:  #()).

Definition nestedConditionalInLoopImplicitContinue: val :=
  rec: "nestedConditionalInLoopImplicitContinue" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #5
      then
        (if: (![uint64T] "i") > #10
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        do:  #()
      else
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #());;;
      do:  #()));;;
    do:  #()).

Definition ImplicitLoopContinue: val :=
  rec: "ImplicitLoopContinue" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #4
      then
        let: "$a0" := #0 in
        do:  "i" <-[uint64T] "$a0";;;
        do:  #()
      else do:  #());;;
      do:  #()));;;
    do:  #()).

Definition ImplicitLoopContinue2: val :=
  rec: "ImplicitLoopContinue2" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #4
      then
        let: "$a0" := #0 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()
      else do:  #());;;
      do:  #()));;;
    do:  #()).

Definition ImplicitLoopContinueAfterIfBreak: val :=
  rec: "ImplicitLoopContinueAfterIfBreak" "i" :=
    exception_do (let: "i" := ref_to uint64T "i" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #0
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      do:  #());;;
    do:  #()).

Definition nestedLoops: val :=
  rec: "nestedLoops" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (let: "j" := ref_zero uint64T #() in
      let: "$a0" := #0 in
      do:  "j" <-[uint64T] "$a0";;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: #true
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        let: "$a0" := (![uint64T] "j") + #1 in
        do:  "j" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()));;;
      let: "$a0" := (![uint64T] "i") + #1 in
      do:  "i" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

Definition nestedGoStyleLoops: val :=
  rec: "nestedGoStyleLoops" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      (let: "j" := ref_zero uint64T #() in
      let: "$a0" := #0 in
      do:  "j" <-[uint64T] "$a0";;;
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, do:  "j" <-[uint64T] ((![uint64T] "j") + #1);;;
      #()) := λ: <>,
        (if: #true
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        continue: #();;;
        do:  #()));;;
      do:  #()));;;
    do:  #()).

Definition sumSlice: val :=
  rec: "sumSlice" "xs" :=
    exception_do (let: "xs" := ref_to (sliceT uint64T) "xs" in
    let: "sum" := ref (zero_val uint64T) in
    do:  ForSlice uint64T <> "x" (![sliceT uint64T] "xs")
      (do:  "sum" <-[uint64T] ((![uint64T] "sum") + (![uint64T] "x"));;;
      do:  #());;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition breakFromLoop: val :=
  rec: "breakFromLoop" <> :=
    exception_do ((for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      continue: #();;;
      do:  #());;;
    do:  #()).

(* maps.go *)

Definition clearMap: val :=
  rec: "clearMap" "m" :=
    exception_do (let: "m" := ref_to (mapT uint64T) "m" in
    do:  machine.MapClear (mapT uint64T) uint64T uint64T (![mapT uint64T] "m");;;
    do:  #()).

Definition IterateMapKeys: val :=
  rec: "IterateMapKeys" "m" "sum" :=
    exception_do (let: "sum" := ref_to ptrT "sum" in
    let: "m" := ref_to (mapT uint64T) "m" in
    do:  MapIter (![mapT uint64T] "m") (λ: "k" <>,
      let: "oldSum" := ref_zero uint64T #() in
      let: "$a0" := ![uint64T] (![ptrT] "sum") in
      do:  "oldSum" <-[uint64T] "$a0";;;
      let: "$a0" := (![uint64T] "oldSum") + (![uint64T] "k") in
      do:  (![ptrT] "sum") <-[uint64T] "$a0";;;
      do:  #());;;
    do:  #()).

Definition MapSize: val :=
  rec: "MapSize" "m" :=
    exception_do (let: "m" := ref_to (mapT boolT) "m" in
    return: (MapLen (![mapT boolT] "m"));;;
    do:  #()).

Definition IntWrapper: ty := uint64T.

Definition MapWrapper: ty := mapT boolT.

Definition MapTypeAliases: val :=
  rec: "MapTypeAliases" "m1" "m2" :=
    exception_do (let: "m2" := ref_to MapWrapper "m2" in
    let: "m1" := ref_to (mapT boolT) "m1" in
    let: "$a0" := Fst (MapGet (![MapWrapper] "m2") #0) in
    do:  MapInsert (![mapT boolT] "m1") #4 "$a0";;;
    do:  #()).

Definition StringMap: val :=
  rec: "StringMap" "m" :=
    exception_do (let: "m" := ref_to (mapT uint64T) "m" in
    return: (Fst (MapGet (![mapT uint64T] "m") #(str "foo")));;;
    do:  #()).

(* multiple.go *)

Definition returnTwo: val :=
  rec: "returnTwo" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    return: (#0, #0);;;
    do:  #()).

Definition returnTwoWrapper: val :=
  rec: "returnTwoWrapper" "data" :=
    exception_do (let: "data" := ref_to (sliceT byteT) "data" in
    let: "b" := ref_zero uint64T #() in
    let: "a" := ref_zero uint64T #() in
    let: ("$a0", "$a1") := returnTwo (![sliceT byteT] "data") in
    do:  "b" <-[uint64T] "$a1";;;
    do:  "a" <-[uint64T] "$a0";;;
    return: (![uint64T] "a", ![uint64T] "b");;;
    do:  #()).

Definition multipleVar: val :=
  rec: "multipleVar" "x" "y" :=
    exception_do (let: "y" := ref_to uint64T "y" in
    let: "x" := ref_to uint64T "x" in
    do:  #()).

(* nil.go *)

Definition AssignNilSlice: val :=
  rec: "AssignNilSlice" <> :=
    exception_do (let: "s" := ref_zero (sliceT (sliceT byteT)) #() in
    let: "$a0" := NewSlice (sliceT byteT) #4 in
    do:  "s" <-[sliceT (sliceT byteT)] "$a0";;;
    let: "$a0" := slice.nil in
    do:  SliceSet (sliceT byteT) (![sliceT (sliceT byteT)] "s") #2 "$a0";;;
    do:  #()).

Definition AssignNilPointer: val :=
  rec: "AssignNilPointer" <> :=
    exception_do (let: "s" := ref_zero (sliceT ptrT) #() in
    let: "$a0" := NewSlice ptrT #4 in
    do:  "s" <-[sliceT ptrT] "$a0";;;
    let: "$a0" := slice.nil in
    do:  SliceSet ptrT (![sliceT ptrT] "s") #2 "$a0";;;
    do:  #()).

Definition CompareSliceToNil: val :=
  rec: "CompareSliceToNil" <> :=
    exception_do (let: "s" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #0 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    return: ((![sliceT byteT] "s") ≠ slice.nil);;;
    do:  #()).

Definition ComparePointerToNil: val :=
  rec: "ComparePointerToNil" <> :=
    exception_do (let: "s" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val uint64T) in
    do:  "s" <-[ptrT] "$a0";;;
    return: ((![ptrT] "s") ≠ #null);;;
    do:  #()).

(* operators.go *)

Definition LogicalOperators: val :=
  rec: "LogicalOperators" "b1" "b2" :=
    exception_do (let: "b2" := ref_to boolT "b2" in
    let: "b1" := ref_to boolT "b1" in
    return: (((![boolT] "b1") && ((![boolT] "b2") || (![boolT] "b1"))) && (~ #false));;;
    do:  #()).

Definition LogicalAndEqualityOperators: val :=
  rec: "LogicalAndEqualityOperators" "b1" "x" :=
    exception_do (let: "x" := ref_to uint64T "x" in
    let: "b1" := ref_to boolT "b1" in
    return: (((![uint64T] "x") = #3) && ((![boolT] "b1") = #true));;;
    do:  #()).

Definition ArithmeticShifts: val :=
  rec: "ArithmeticShifts" "x" "y" :=
    exception_do (let: "y" := ref_to uint64T "y" in
    let: "x" := ref_to uint32T "x" in
    return: (((to_u64 ((![uint32T] "x") ≪ #3)) + ((![uint64T] "y") ≪ (to_u64 (![uint32T] "x")))) + ((![uint64T] "y") ≪ #1));;;
    do:  #()).

Definition BitwiseOps: val :=
  rec: "BitwiseOps" "x" "y" :=
    exception_do (let: "y" := ref_to uint64T "y" in
    let: "x" := ref_to uint32T "x" in
    return: ((to_u64 (![uint32T] "x")) `or` ((to_u64 (to_u32 (![uint64T] "y"))) `and` #43));;;
    do:  #()).

Definition Comparison: val :=
  rec: "Comparison" "x" "y" :=
    exception_do (let: "y" := ref_to uint64T "y" in
    let: "x" := ref_to uint64T "x" in
    (if: (![uint64T] "x") < (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] "x") = (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] "x") ≠ (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] "x") > (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: ((![uint64T] "x") + #1) > ((![uint64T] "y") - #2)
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    return: (#false);;;
    do:  #()).

Definition AssignOps: val :=
  rec: "AssignOps" <> :=
    exception_do (let: "x" := ref (zero_val uint64T) in
    do:  "x" <-[uint64T] ((![uint64T] "x") + #3);;;
    do:  "x" <-[uint64T] ((![uint64T] "x") - #3);;;
    do:  "x" <-[uint64T] ((![uint64T] "x") + #1);;;
    do:  "x" <-[uint64T] ((![uint64T] "x") - #1);;;
    do:  #()).

(* package.go *)

(* unittest has two package comments *)

Definition wrapExternalStruct := struct.decl [
  "e" :: structT marshal.Enc;
  "d" :: structT marshal.Dec
].

Definition wrapExternalStruct__moveUint64: val :=
  rec: "wrapExternalStruct__moveUint64" "w" :=
    exception_do (let: "w" := ref_to (structT wrapExternalStruct) "w" in
    do:  marshal.Enc__PutInt (![struct.fieldTy wrapExternalStruct "e"] (struct.get wrapExternalStruct "e" (![structT wrapExternalStruct] "w"))) (marshal.Dec__GetInt (![struct.fieldTy wrapExternalStruct "d"] (struct.get wrapExternalStruct "d" (![structT wrapExternalStruct] "w"))));;;
    do:  #()).

(* panic.go *)

Definition PanicAtTheDisco: val :=
  rec: "PanicAtTheDisco" <> :=
    exception_do (do:  Panic "disco";;;
    do:  #()).

(* proph.go *)

Definition Oracle: val :=
  rec: "Oracle" <> :=
    exception_do (let: "p" := ref_zero ProphIdT #() in
    let: "$a0" := machine.NewProph #() in
    do:  "p" <-[ProphIdT] "$a0";;;
    do:  machine.prophId__ResolveBool (![ProphIdT] "p") #false;;;
    do:  machine.prophId__ResolveU64 (![ProphIdT] "p") #0;;;
    do:  #()).

Definition typing := struct.decl [
  "proph" :: ProphIdT
].

(* reassign.go *)

Definition composite := struct.decl [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition ReassignVars: val :=
  rec: "ReassignVars" <> :=
    exception_do (let: "x" := ref (zero_val uint64T) in
    let: "y" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "y" <-[uint64T] "$a0";;;
    let: "$a0" := #3 in
    do:  "x" <-[uint64T] "$a0";;;
    let: "z" := ref_to (structT composite) (struct.mk composite [
      "a" ::= ![uint64T] "x";
      "b" ::= ![uint64T] "y"
    ]) in
    let: "$a0" := struct.mk composite [
      "a" ::= ![uint64T] "y";
      "b" ::= ![uint64T] "x"
    ] in
    do:  "z" <-[structT composite] "$a0";;;
    let: "$a0" := ![struct.fieldTy composite "a"] (struct.get composite "a" (![structT composite] "z")) in
    do:  "x" <-[uint64T] "$a0";;;
    do:  #()).

(* replicated_disk.go *)

Definition Block := struct.decl [
  "Value" :: uint64T
].

Definition Disk1 : expr := #0.

Definition Disk2 : expr := #0.

Definition DiskSize : expr := #1000.

(* TwoDiskWrite is a dummy function to represent the base layer's disk write *)
Definition TwoDiskWrite: val :=
  rec: "TwoDiskWrite" "diskId" "a" "v" :=
    exception_do (let: "v" := ref_to (structT Block) "v" in
    let: "a" := ref_to uint64T "a" in
    let: "diskId" := ref_to uint64T "diskId" in
    return: (#true);;;
    do:  #()).

(* TwoDiskRead is a dummy function to represent the base layer's disk read *)
Definition TwoDiskRead: val :=
  rec: "TwoDiskRead" "diskId" "a" :=
    exception_do (let: "a" := ref_to uint64T "a" in
    let: "diskId" := ref_to uint64T "diskId" in
    return: (struct.mk Block [
       "Value" ::= #0
     ], #true);;;
    do:  #()).

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer *)
Definition TwoDiskLock: val :=
  rec: "TwoDiskLock" "a" :=
    exception_do (let: "a" := ref_to uint64T "a" in
    do:  #()).

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer *)
Definition TwoDiskUnlock: val :=
  rec: "TwoDiskUnlock" "a" :=
    exception_do (let: "a" := ref_to uint64T "a" in
    do:  #()).

Definition ReplicatedDiskRead: val :=
  rec: "ReplicatedDiskRead" "a" :=
    exception_do (let: "a" := ref_to uint64T "a" in
    do:  TwoDiskLock (![uint64T] "a");;;
    let: "ok" := ref_zero boolT #() in
    let: "v" := ref_zero (structT Block) #() in
    let: ("$a0", "$a1") := TwoDiskRead Disk1 (![uint64T] "a") in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v" <-[structT Block] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  TwoDiskUnlock (![uint64T] "a");;;
      return: (![structT Block] "v");;;
      do:  #()
    else do:  #());;;
    let: <> := ref_zero boolT #() in
    let: "v2" := ref_zero (structT Block) #() in
    let: ("$a0", "$a1") := TwoDiskRead Disk2 (![uint64T] "a") in
    do:  "$a1";;;
    do:  "v2" <-[structT Block] "$a0";;;
    do:  TwoDiskUnlock (![uint64T] "a");;;
    return: (![structT Block] "v2");;;
    do:  #()).

Definition ReplicatedDiskWrite: val :=
  rec: "ReplicatedDiskWrite" "a" "v" :=
    exception_do (let: "v" := ref_to (structT Block) "v" in
    let: "a" := ref_to uint64T "a" in
    do:  TwoDiskLock (![uint64T] "a");;;
    do:  TwoDiskWrite Disk1 (![uint64T] "a") (![structT Block] "v");;;
    do:  TwoDiskWrite Disk2 (![uint64T] "a") (![structT Block] "v");;;
    do:  TwoDiskUnlock (![uint64T] "a");;;
    do:  #()).

Definition ReplicatedDiskRecover: val :=
  rec: "ReplicatedDiskRecover" <> :=
    exception_do ((let: "a" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "a" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "a") > DiskSize
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "ok" := ref_zero boolT #() in
      let: "v" := ref_zero (structT Block) #() in
      let: ("$a0", "$a1") := TwoDiskRead Disk1 (![uint64T] "a") in
      do:  "ok" <-[boolT] "$a1";;;
      do:  "v" <-[structT Block] "$a0";;;
      (if: ![boolT] "ok"
      then
        do:  TwoDiskWrite Disk2 (![uint64T] "a") (![structT Block] "v");;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] "a") + #1 in
      do:  "a" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

(* slices.go *)

Definition SliceAlias: ty := sliceT boolT.

Definition sliceOps: val :=
  rec: "sliceOps" <> :=
    exception_do (let: "x" := ref_zero (sliceT uint64T) #() in
    let: "$a0" := NewSlice uint64T #10 in
    do:  "x" <-[sliceT uint64T] "$a0";;;
    let: "v1" := ref_zero uint64T #() in
    let: "$a0" := SliceGet uint64T (![sliceT uint64T] "x") #2 in
    do:  "v1" <-[uint64T] "$a0";;;
    let: "v2" := ref_zero (sliceT uint64T) #() in
    let: "$a0" := SliceSubslice uint64T (![sliceT uint64T] "x") #2 #3 in
    do:  "v2" <-[sliceT uint64T] "$a0";;;
    let: "v3" := ref_zero (sliceT uint64T) #() in
    let: "$a0" := SliceTake (![sliceT uint64T] "x") #3 in
    do:  "v3" <-[sliceT uint64T] "$a0";;;
    let: "v4" := ref_zero ptrT #() in
    let: "$a0" := SliceRef uint64T (![sliceT uint64T] "x") #2 in
    do:  "v4" <-[ptrT] "$a0";;;
    return: ((((((![uint64T] "v1") + (SliceGet uint64T (![sliceT uint64T] "v2") #0)) + (SliceGet uint64T (![sliceT uint64T] "v3") #1)) + (![uint64T] (![ptrT] "v4"))) + (slice.len (![sliceT uint64T] "x"))) + (slice.cap (![sliceT uint64T] "x")));;;
    do:  #()).

Definition makeSingletonSlice: val :=
  rec: "makeSingletonSlice" "x" :=
    exception_do (let: "x" := ref_to uint64T "x" in
    return: (SliceSingleton (![uint64T] "x"));;;
    do:  #()).

Definition thing := struct.decl [
  "x" :: uint64T
].

Definition sliceOfThings := struct.decl [
  "things" :: sliceT (structT thing)
].

Definition sliceOfThings__getThingRef: val :=
  rec: "sliceOfThings__getThingRef" "ts" "i" :=
    exception_do (let: "i" := ref_to uint64T "i" in
    let: "ts" := ref_to (structT sliceOfThings) "ts" in
    return: (SliceRef (structT thing) (![struct.fieldTy sliceOfThings "things"] (struct.get sliceOfThings "things" (![structT sliceOfThings] "ts"))) (![uint64T] "i"));;;
    do:  #()).

Definition makeAlias: val :=
  rec: "makeAlias" <> :=
    exception_do (return: (NewSlice boolT #10);;;
    do:  #()).

(* spawn.go *)

(* Skip is a placeholder for some impure code *)
Definition Skip: val :=
  rec: "Skip" <> :=
    exception_do do:  #().

Definition simpleSpawn: val :=
  rec: "simpleSpawn" <> :=
    exception_do (let: "l" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "l" <-[ptrT] "$a0";;;
    let: "v" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val uint64T) in
    do:  "v" <-[ptrT] "$a0";;;
    do:  Fork (do:  sync.Mutex__Lock (![ptrT] "l");;;
          let: "x" := ref_zero uint64T #() in
          let: "$a0" := ![uint64T] (![ptrT] "v") in
          do:  "x" <-[uint64T] "$a0";;;
          (if: (![uint64T] "x") > #0
          then
            do:  Skip #();;;
            do:  #()
          else do:  #());;;
          do:  sync.Mutex__Unlock (![ptrT] "l");;;
          do:  #());;;
    do:  sync.Mutex__Lock (![ptrT] "l");;;
    let: "$a0" := #1 in
    do:  (![ptrT] "v") <-[uint64T] "$a0";;;
    do:  sync.Mutex__Unlock (![ptrT] "l");;;
    do:  #()).

Definition threadCode: val :=
  rec: "threadCode" "tid" :=
    exception_do (let: "tid" := ref_to uint64T "tid" in
    do:  #()).

Definition loopSpawn: val :=
  rec: "loopSpawn" <> :=
    exception_do ((let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "i" := ref_zero uint64T #() in
      let: "$a0" := ![uint64T] "i" in
      do:  "i" <-[uint64T] "$a0";;;
      do:  Fork (do:  threadCode (![uint64T] "i");;;
            do:  #());;;
      do:  #()));;;
    (let: "dummy" := ref_zero boolT #() in
    let: "$a0" := #true in
    do:  "dummy" <-[boolT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "$a0" := (~ (![boolT] "dummy")) in
      do:  "dummy" <-[boolT] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

(* strings.go *)

Definition stringAppend: val :=
  rec: "stringAppend" "s" "x" :=
    exception_do (let: "x" := ref_to uint64T "x" in
    let: "s" := ref_to stringT "s" in
    return: (((#(str "prefix ") + (![stringT] "s")) + #(str " ")) + (machine.UInt64ToString (![uint64T] "x")));;;
    do:  #()).

Definition stringLength: val :=
  rec: "stringLength" "s" :=
    exception_do (let: "s" := ref_to stringT "s" in
    return: (StringLength (![stringT] "s"));;;
    do:  #()).

(* struct_method.go *)

Definition Point := struct.decl [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition Point__Add: val :=
  rec: "Point__Add" "c" "z" :=
    exception_do (let: "z" := ref_to uint64T "z" in
    let: "c" := ref_to (structT Point) "c" in
    return: (((![struct.fieldTy Point "x"] (struct.get Point "x" (![structT Point] "c"))) + (![struct.fieldTy Point "y"] (struct.get Point "y" (![structT Point] "c")))) + (![uint64T] "z"));;;
    do:  #()).

Definition Point__GetField: val :=
  rec: "Point__GetField" "c" :=
    exception_do (let: "c" := ref_to (structT Point) "c" in
    let: "x" := ref_zero uint64T #() in
    let: "$a0" := ![struct.fieldTy Point "x"] (struct.get Point "x" (![structT Point] "c")) in
    do:  "x" <-[uint64T] "$a0";;;
    let: "y" := ref_zero uint64T #() in
    let: "$a0" := ![struct.fieldTy Point "y"] (struct.get Point "y" (![structT Point] "c")) in
    do:  "y" <-[uint64T] "$a0";;;
    return: ((![uint64T] "x") + (![uint64T] "y"));;;
    do:  #()).

Definition UseAdd: val :=
  rec: "UseAdd" <> :=
    exception_do (let: "c" := ref_zero (structT Point) #() in
    let: "$a0" := struct.mk Point [
      "x" ::= #2;
      "y" ::= #3
    ] in
    do:  "c" <-[structT Point] "$a0";;;
    let: "r" := ref_zero uint64T #() in
    let: "$a0" := Point__Add (![structT Point] "c") #4 in
    do:  "r" <-[uint64T] "$a0";;;
    return: (![uint64T] "r");;;
    do:  #()).

Definition UseAddWithLiteral: val :=
  rec: "UseAddWithLiteral" <> :=
    exception_do (let: "r" := ref_zero uint64T #() in
    let: "$a0" := Point__Add (struct.mk Point [
      "x" ::= #2;
      "y" ::= #3
    ]) #4 in
    do:  "r" <-[uint64T] "$a0";;;
    return: (![uint64T] "r");;;
    do:  #()).

(* struct_pointers.go *)

Definition TwoInts := struct.decl [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition S := struct.decl [
  "a" :: uint64T;
  "b" :: structT TwoInts;
  "c" :: boolT
].

Definition NewS: val :=
  rec: "NewS" <> :=
    exception_do (return: (ref_to (structT S) (struct.mk S [
       "a" ::= #2;
       "b" ::= struct.mk TwoInts [
         "x" ::= #1;
         "y" ::= #2
       ];
       "c" ::= #true
     ]));;;
    do:  #()).

Definition S__readA: val :=
  rec: "S__readA" "s" :=
    exception_do (let: "s" := ref_to ptrT "s" in
    return: (![struct.fieldTy S "a"] (struct.fieldRef S "a" (![ptrT] "s")));;;
    do:  #()).

Definition S__readB: val :=
  rec: "S__readB" "s" :=
    exception_do (let: "s" := ref_to ptrT "s" in
    return: (![struct.fieldTy S "b"] (struct.fieldRef S "b" (![ptrT] "s")));;;
    do:  #()).

Definition S__readBVal: val :=
  rec: "S__readBVal" "s" :=
    exception_do (let: "s" := ref_to (structT S) "s" in
    return: (![struct.fieldTy S "b"] (struct.get S "b" (![structT S] "s")));;;
    do:  #()).

Definition S__writeB: val :=
  rec: "S__writeB" "s" "two" :=
    exception_do (let: "two" := ref_to (structT TwoInts) "two" in
    let: "s" := ref_to ptrT "s" in
    let: "$a0" := ![structT TwoInts] "two" in
    do:  (struct.fieldRef S "b" (![ptrT] "s") "$a0") <-[struct.fieldTy S "b"] "$a0";;;
    do:  #()).

Definition S__negateC: val :=
  rec: "S__negateC" "s" :=
    exception_do (let: "s" := ref_to ptrT "s" in
    let: "$a0" := (~ (![struct.fieldTy S "c"] (struct.fieldRef S "c" (![ptrT] "s")))) in
    do:  (struct.fieldRef S "c" (![ptrT] "s") "$a0") <-[struct.fieldTy S "c"] "$a0";;;
    do:  #()).

Definition S__refC: val :=
  rec: "S__refC" "s" :=
    exception_do (let: "s" := ref_to ptrT "s" in
    return: (struct.fieldRef S "c" (![ptrT] "s"));;;
    do:  #()).

Definition localSRef: val :=
  rec: "localSRef" <> :=
    exception_do (let: "s" := ref (zero_val (structT S)) in
    return: (struct.fieldRef S "b" "s");;;
    do:  #()).

Definition setField: val :=
  rec: "setField" <> :=
    exception_do (let: "s" := ref (zero_val (structT S)) in
    let: "$a0" := #0 in
    do:  (struct.fieldRef S "a" "s" "$a0") <-[struct.fieldTy S "a"] "$a0";;;
    let: "$a0" := #true in
    do:  (struct.fieldRef S "c" "s" "$a0") <-[struct.fieldTy S "c"] "$a0";;;
    return: (![structT S] "s");;;
    do:  #()).

(* synchronization.go *)

(* DoSomeLocking uses the entire lock API *)
Definition DoSomeLocking: val :=
  rec: "DoSomeLocking" "l" :=
    exception_do (let: "l" := ref_to ptrT "l" in
    do:  sync.Mutex__Lock (![ptrT] "l");;;
    do:  sync.Mutex__Unlock (![ptrT] "l");;;
    do:  #()).

Definition makeLock: val :=
  rec: "makeLock" <> :=
    exception_do (let: "l" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "l" <-[ptrT] "$a0";;;
    do:  DoSomeLocking (![ptrT] "l");;;
    do:  #()).

(* time.go *)

Definition sleep: val :=
  rec: "sleep" <> :=
    exception_do (do:  machine.Sleep #1000;;;
    do:  #()).

(* topsort.go *)

Definition B := struct.decl [
  "a" :: sliceT (structT A)
].

Definition A := struct.decl [
].

(* trailing_call.go *)

Definition mkInt: val :=
  rec: "mkInt" <> :=
    exception_do (return: (#42);;;
    do:  #()).

Definition mkNothing: val :=
  rec: "mkNothing" <> :=
    exception_do (do:  mkInt #();;;
    do:  #()).

(* type_alias.go *)

Definition my_u64: ty := uint64T.

Definition Timestamp: ty := uint64T.

Definition UseTypeAbbrev: ty := uint64T.

Definition UseNamedType: ty := Timestamp.

Definition convertToAlias: val :=
  rec: "convertToAlias" <> :=
    exception_do (let: "x" := ref_zero uint64T #() in
    let: "$a0" := #2 in
    do:  "x" <-[uint64T] "$a0";;;
    return: (![uint64T] "x");;;
    do:  #()).
