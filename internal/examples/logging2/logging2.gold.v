(* autogenerated from github.com/tchajed/goose/internal/examples/logging2 *)
From Perennial.new_goose_lang Require Import prelude.
From Goose Require github_com.tchajed.goose.machine.
From Goose Require github_com.tchajed.goose.machine.disk.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.disk_prelude.

(* logging2.go *)

Definition LOGCOMMIT : expr := #0.

Definition LOGSTART : expr := #1.

Definition LOGMAXBLK : expr := #510.

Definition LOGEND : expr := LOGMAXBLK + LOGSTART.

Definition Log := struct.decl [
  "logLock" :: ptrT;
  "memLock" :: ptrT;
  "logSz" :: uint64T;
  "memLog" :: ptrT;
  "memLen" :: ptrT;
  "memTxnNxt" :: ptrT;
  "logTxnNxt" :: ptrT
].

Definition Log__writeHdr: val :=
  rec: "Log__writeHdr" "log" "len" :=
    exception_do (let: "len" := ref_to uint64T "len" in
    let: "log" := ref_to (structT Log) "log" in
    let: "hdr" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #4096 in
    do:  "hdr" <-[sliceT byteT] "$a0";;;
    do:  machine.UInt64Put (![sliceT byteT] "hdr") (![uint64T] "len");;;
    do:  disk.Write LOGCOMMIT (![sliceT byteT] "hdr");;;
    do:  #()).

Definition Init: val :=
  rec: "Init" "logSz" :=
    exception_do (let: "logSz" := ref_to uint64T "logSz" in
    let: "log" := ref_zero (structT Log) #() in
    let: "$a0" := struct.mk Log [
      "logLock" ::= struct.alloc sync.Mutex (zero_val (structT sync.Mutex));
      "memLock" ::= struct.alloc sync.Mutex (zero_val (structT sync.Mutex));
      "logSz" ::= ![uint64T] "logSz";
      "memLog" ::= ref (zero_val (sliceT disk.blockT));
      "memLen" ::= ref (zero_val uint64T);
      "memTxnNxt" ::= ref (zero_val uint64T);
      "logTxnNxt" ::= ref (zero_val uint64T)
    ] in
    do:  "log" <-[structT Log] "$a0";;;
    do:  Log__writeHdr (![structT Log] "log") #0;;;
    return: (![structT Log] "log");;;
    do:  #()).

Definition Log__readHdr: val :=
  rec: "Log__readHdr" "log" :=
    exception_do (let: "log" := ref_to (structT Log) "log" in
    let: "hdr" := ref_zero (sliceT byteT) #() in
    let: "$a0" := disk.Read LOGCOMMIT in
    do:  "hdr" <-[sliceT byteT] "$a0";;;
    let: "disklen" := ref_zero uint64T #() in
    let: "$a0" := machine.UInt64Get (![sliceT byteT] "hdr") in
    do:  "disklen" <-[uint64T] "$a0";;;
    return: (![uint64T] "disklen");;;
    do:  #()).

Definition Log__readBlocks: val :=
  rec: "Log__readBlocks" "log" "len" :=
    exception_do (let: "len" := ref_to uint64T "len" in
    let: "log" := ref_to (structT Log) "log" in
    let: "blks" := ref_to (sliceT (sliceT byteT)) (NewSlice (sliceT byteT) #0) in
    (let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "len")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "blk" := ref_zero (sliceT byteT) #() in
      let: "$a0" := disk.Read (LOGSTART + (![uint64T] "i")) in
      do:  "blk" <-[sliceT byteT] "$a0";;;
      let: "$a0" := SliceAppend (sliceT byteT) (![sliceT (sliceT byteT)] "blks") (![sliceT byteT] "blk") in
      do:  "blks" <-[sliceT (sliceT byteT)] "$a0";;;
      do:  #()));;;
    return: (![sliceT (sliceT byteT)] "blks");;;
    do:  #()).

Definition Log__Read: val :=
  rec: "Log__Read" "log" :=
    exception_do (let: "log" := ref_to (structT Log) "log" in
    do:  sync.Mutex__Lock (![struct.fieldTy Log "logLock"] (struct.get Log "logLock" (![structT Log] "log")));;;
    let: "disklen" := ref_zero uint64T #() in
    let: "$a0" := Log__readHdr (![structT Log] "log") in
    do:  "disklen" <-[uint64T] "$a0";;;
    let: "blks" := ref_zero (sliceT (sliceT byteT)) #() in
    let: "$a0" := Log__readBlocks (![structT Log] "log") (![uint64T] "disklen") in
    do:  "blks" <-[sliceT (sliceT byteT)] "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Log "logLock"] (struct.get Log "logLock" (![structT Log] "log")));;;
    return: (![sliceT (sliceT byteT)] "blks");;;
    do:  #()).

Definition Log__memWrite: val :=
  rec: "Log__memWrite" "log" "l" :=
    exception_do (let: "l" := ref_to (sliceT disk.blockT) "l" in
    let: "log" := ref_to (structT Log) "log" in
    let: "n" := ref_zero uint64T #() in
    let: "$a0" := slice.len (![sliceT (sliceT byteT)] "l") in
    do:  "n" <-[uint64T] "$a0";;;
    (let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "n")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "$a0" := SliceAppend (sliceT byteT) (![sliceT (sliceT byteT)] (![struct.fieldTy Log "memLog"] (struct.get Log "memLog" (![structT Log] "log")))) (SliceGet (sliceT byteT) (![sliceT (sliceT byteT)] "l") (![uint64T] "i")) in
      do:  (![struct.fieldTy Log "memLog"] (struct.get Log "memLog" (![structT Log] "log"))) <-[sliceT (sliceT byteT)] "$a0";;;
      do:  #()));;;
    do:  #()).

Definition Log__memAppend: val :=
  rec: "Log__memAppend" "log" "l" :=
    exception_do (let: "l" := ref_to (sliceT disk.blockT) "l" in
    let: "log" := ref_to (structT Log) "log" in
    do:  sync.Mutex__Lock (![struct.fieldTy Log "memLock"] (struct.get Log "memLock" (![structT Log] "log")));;;
    (if: ((![uint64T] (![struct.fieldTy Log "memLen"] (struct.get Log "memLen" (![structT Log] "log")))) + (slice.len (![sliceT (sliceT byteT)] "l"))) ≥ (![struct.fieldTy Log "logSz"] (struct.get Log "logSz" (![structT Log] "log")))
    then
      do:  sync.Mutex__Unlock (![struct.fieldTy Log "memLock"] (struct.get Log "memLock" (![structT Log] "log")));;;
      return: (#false, #0);;;
      do:  #()
    else do:  #());;;
    let: "txn" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![struct.fieldTy Log "memTxnNxt"] (struct.get Log "memTxnNxt" (![structT Log] "log"))) in
    do:  "txn" <-[uint64T] "$a0";;;
    let: "n" := ref_zero uint64T #() in
    let: "$a0" := (![uint64T] (![struct.fieldTy Log "memLen"] (struct.get Log "memLen" (![structT Log] "log")))) + (slice.len (![sliceT (sliceT byteT)] "l")) in
    do:  "n" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "n" in
    do:  (![struct.fieldTy Log "memLen"] (struct.get Log "memLen" (![structT Log] "log"))) <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] (![struct.fieldTy Log "memTxnNxt"] (struct.get Log "memTxnNxt" (![structT Log] "log")))) + #1 in
    do:  (![struct.fieldTy Log "memTxnNxt"] (struct.get Log "memTxnNxt" (![structT Log] "log"))) <-[uint64T] "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Log "memLock"] (struct.get Log "memLock" (![structT Log] "log")));;;
    return: (#true, ![uint64T] "txn");;;
    do:  #()).

(* XXX just an atomic read? *)
Definition Log__readLogTxnNxt: val :=
  rec: "Log__readLogTxnNxt" "log" :=
    exception_do (let: "log" := ref_to (structT Log) "log" in
    do:  sync.Mutex__Lock (![struct.fieldTy Log "memLock"] (struct.get Log "memLock" (![structT Log] "log")));;;
    let: "n" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![struct.fieldTy Log "logTxnNxt"] (struct.get Log "logTxnNxt" (![structT Log] "log"))) in
    do:  "n" <-[uint64T] "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Log "memLock"] (struct.get Log "memLock" (![structT Log] "log")));;;
    return: (![uint64T] "n");;;
    do:  #()).

Definition Log__diskAppendWait: val :=
  rec: "Log__diskAppendWait" "log" "txn" :=
    exception_do (let: "txn" := ref_to uint64T "txn" in
    let: "log" := ref_to (structT Log) "log" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "logtxn" := ref_zero uint64T #() in
      let: "$a0" := Log__readLogTxnNxt (![structT Log] "log") in
      do:  "logtxn" <-[uint64T] "$a0";;;
      (if: (![uint64T] "txn") < (![uint64T] "logtxn")
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      continue: #();;;
      do:  #());;;
    do:  #()).

Definition Log__Append: val :=
  rec: "Log__Append" "log" "l" :=
    exception_do (let: "l" := ref_to (sliceT disk.blockT) "l" in
    let: "log" := ref_to (structT Log) "log" in
    let: "txn" := ref_zero uint64T #() in
    let: "ok" := ref_zero boolT #() in
    let: ("$a0", "$a1") := Log__memAppend (![structT Log] "log") (![sliceT (sliceT byteT)] "l") in
    do:  "txn" <-[uint64T] "$a1";;;
    do:  "ok" <-[boolT] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  Log__diskAppendWait (![structT Log] "log") (![uint64T] "txn");;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition Log__writeBlocks: val :=
  rec: "Log__writeBlocks" "log" "l" "pos" :=
    exception_do (let: "pos" := ref_to uint64T "pos" in
    let: "l" := ref_to (sliceT disk.blockT) "l" in
    let: "log" := ref_to (structT Log) "log" in
    let: "n" := ref_zero uint64T #() in
    let: "$a0" := slice.len (![sliceT (sliceT byteT)] "l") in
    do:  "n" <-[uint64T] "$a0";;;
    (let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "n")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "bk" := ref_zero (sliceT byteT) #() in
      let: "$a0" := SliceGet (sliceT byteT) (![sliceT (sliceT byteT)] "l") (![uint64T] "i") in
      do:  "bk" <-[sliceT byteT] "$a0";;;
      do:  disk.Write ((![uint64T] "pos") + (![uint64T] "i")) (![sliceT byteT] "bk");;;
      do:  #()));;;
    do:  #()).

Definition Log__diskAppend: val :=
  rec: "Log__diskAppend" "log" :=
    exception_do (let: "log" := ref_to (structT Log) "log" in
    do:  sync.Mutex__Lock (![struct.fieldTy Log "logLock"] (struct.get Log "logLock" (![structT Log] "log")));;;
    let: "disklen" := ref_zero uint64T #() in
    let: "$a0" := Log__readHdr (![structT Log] "log") in
    do:  "disklen" <-[uint64T] "$a0";;;
    do:  sync.Mutex__Lock (![struct.fieldTy Log "memLock"] (struct.get Log "memLock" (![structT Log] "log")));;;
    let: "memlen" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![struct.fieldTy Log "memLen"] (struct.get Log "memLen" (![structT Log] "log"))) in
    do:  "memlen" <-[uint64T] "$a0";;;
    let: "allblks" := ref_zero (sliceT (sliceT byteT)) #() in
    let: "$a0" := ![sliceT (sliceT byteT)] (![struct.fieldTy Log "memLog"] (struct.get Log "memLog" (![structT Log] "log"))) in
    do:  "allblks" <-[sliceT (sliceT byteT)] "$a0";;;
    let: "blks" := ref_zero (sliceT (sliceT byteT)) #() in
    let: "$a0" := SliceSkip (sliceT byteT) (![sliceT (sliceT byteT)] "allblks") (![uint64T] "disklen") in
    do:  "blks" <-[sliceT (sliceT byteT)] "$a0";;;
    let: "memnxt" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![struct.fieldTy Log "memTxnNxt"] (struct.get Log "memTxnNxt" (![structT Log] "log"))) in
    do:  "memnxt" <-[uint64T] "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Log "memLock"] (struct.get Log "memLock" (![structT Log] "log")));;;
    do:  Log__writeBlocks (![structT Log] "log") (![sliceT (sliceT byteT)] "blks") (![uint64T] "disklen");;;
    do:  Log__writeHdr (![structT Log] "log") (![uint64T] "memlen");;;
    let: "$a0" := ![uint64T] "memnxt" in
    do:  (![struct.fieldTy Log "logTxnNxt"] (struct.get Log "logTxnNxt" (![structT Log] "log"))) <-[uint64T] "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Log "logLock"] (struct.get Log "logLock" (![structT Log] "log")));;;
    do:  #()).

Definition Log__Logger: val :=
  rec: "Log__Logger" "log" :=
    exception_do (let: "log" := ref_to (structT Log) "log" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  Log__diskAppend (![structT Log] "log");;;
      do:  #());;;
    do:  #()).

(* txn.go *)

Definition Txn := struct.decl [
  "log" :: ptrT;
  "blks" :: mapT disk.blockT
].

(* XXX wait if cannot reserve space in log *)
Definition Begin: val :=
  rec: "Begin" "log" :=
    exception_do (let: "log" := ref_to ptrT "log" in
    let: "txn" := ref_zero (structT Txn) #() in
    let: "$a0" := struct.mk Txn [
      "log" ::= ![ptrT] "log";
      "blks" ::= NewMap uint64T (sliceT byteT) #()
    ] in
    do:  "txn" <-[structT Txn] "$a0";;;
    return: (![structT Txn] "txn");;;
    do:  #()).

Definition Txn__Write: val :=
  rec: "Txn__Write" "txn" "addr" "blk" :=
    exception_do (let: "blk" := ref_to ptrT "blk" in
    let: "addr" := ref_to uint64T "addr" in
    let: "txn" := ref_to (structT Txn) "txn" in
    let: "ret" := ref_to boolT #true in
    let: "ok" := ref_zero boolT #() in
    let: <> := ref_zero (sliceT byteT) #() in
    let: ("$a0", "$a1") := Fst (MapGet (![struct.fieldTy Txn "blks"] (struct.get Txn "blks" (![structT Txn] "txn"))) (![uint64T] "addr")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "$a0";;;
    (if: ![boolT] "ok"
    then
      let: "$a0" := ![sliceT byteT] (![ptrT] "blk") in
      do:  MapInsert (![struct.fieldTy Txn "blks"] (struct.get Txn "blks" (![structT Txn] "txn"))) (![uint64T] "addr") "$a0";;;
      do:  #()
    else do:  #());;;
    (if: (~ (![boolT] "ok"))
    then
      (if: (![uint64T] "addr") = LOGMAXBLK
      then
        let: "$a0" := #false in
        do:  "ret" <-[boolT] "$a0";;;
        do:  #()
      else
        let: "$a0" := ![sliceT byteT] (![ptrT] "blk") in
        do:  MapInsert (![struct.fieldTy Txn "blks"] (struct.get Txn "blks" (![structT Txn] "txn"))) (![uint64T] "addr") "$a0";;;
        do:  #());;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ret");;;
    do:  #()).

Definition Txn__Read: val :=
  rec: "Txn__Read" "txn" "addr" :=
    exception_do (let: "addr" := ref_to uint64T "addr" in
    let: "txn" := ref_to (structT Txn) "txn" in
    let: "ok" := ref_zero boolT #() in
    let: "v" := ref_zero (sliceT byteT) #() in
    let: ("$a0", "$a1") := Fst (MapGet (![struct.fieldTy Txn "blks"] (struct.get Txn "blks" (![structT Txn] "txn"))) (![uint64T] "addr")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v" <-[sliceT byteT] "$a0";;;
    (if: ![boolT] "ok"
    then
      return: (![sliceT byteT] "v");;;
      do:  #()
    else
      return: (disk.Read ((![uint64T] "addr") + LOGEND));;;
      do:  #());;;
    do:  #()).

Definition Txn__Commit: val :=
  rec: "Txn__Commit" "txn" :=
    exception_do (let: "txn" := ref_to (structT Txn) "txn" in
    let: "blks" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val (sliceT disk.blockT)) in
    do:  "blks" <-[ptrT] "$a0";;;
    do:  MapIter (![struct.fieldTy Txn "blks"] (struct.get Txn "blks" (![structT Txn] "txn"))) (λ: <> "v",
      let: "$a0" := SliceAppend (sliceT byteT) (![sliceT (sliceT byteT)] (![ptrT] "blks")) (![sliceT byteT] "v") in
      do:  (![ptrT] "blks") <-[sliceT (sliceT byteT)] "$a0";;;
      do:  #());;;
    let: "ok" := ref_zero boolT #() in
    let: "$a0" := Log__Append (struct.load Log (![struct.fieldTy Txn "log"] (struct.get Txn "log" (![structT Txn] "txn")))) (![sliceT (sliceT byteT)] (![ptrT] "blks")) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).
