(* autogenerated from github.com/tchajed/goose/internal/examples/simpledb *)
From Perennial.new_goose_lang Require Import prelude.
From Goose Require github_com.tchajed.goose.machine.
From Goose Require github_com.tchajed.goose.machine.filesys.
From Goose Require github_com.tchajed.marshal.
From Goose Require sync.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

(* Package simpledb implements a one-table version of LevelDB

   It buffers all writes in memory; to make data durable, call Compact().
   This operation re-writes all of the data in the database
   (including in-memory writes) in a crash-safe manner.
   Keys in the table are cached for efficient reads. *)

Definition UseMarshal: val :=
  rec: "UseMarshal" <> :=
    exception_do (do:  marshal.NewEnc #0;;;
    do:  #()).

Definition Table := struct.decl [
  "Index" :: mapT uint64T;
  "File" :: fileT
].

(* CreateTable creates a new, empty table. *)
Definition CreateTable: val :=
  rec: "CreateTable" "p" :=
    exception_do (let: "p" := ref_to stringT "p" in
    let: "index" := ref_zero (mapT uint64T) #() in
    let: "$a0" := NewMap uint64T uint64T #() in
    do:  "index" <-[mapT uint64T] "$a0";;;
    let: <> := ref_zero boolT #() in
    let: "f" := ref_zero fileT #() in
    let: ("$a0", "$a1") := filesys.Create #(str "db") (![stringT] "p") in
    do:  "$a1";;;
    do:  "f" <-[fileT] "$a0";;;
    do:  filesys.Close (![fileT] "f");;;
    let: "f2" := ref_zero fileT #() in
    let: "$a0" := filesys.Open #(str "db") (![stringT] "p") in
    do:  "f2" <-[fileT] "$a0";;;
    return: (struct.mk Table [
       "Index" ::= ![mapT uint64T] "index";
       "File" ::= ![fileT] "f2"
     ]);;;
    do:  #()).

Definition Entry := struct.decl [
  "Key" :: uint64T;
  "Value" :: sliceT byteT
].

(* DecodeUInt64 is a Decoder(uint64)

   All decoders have the shape func(p []byte) (T, uint64)

   The uint64 represents the number of bytes consumed; if 0,
   then decoding failed, and the value of type T should be ignored. *)
Definition DecodeUInt64: val :=
  rec: "DecodeUInt64" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    (if: (slice.len (![sliceT byteT] "p")) < #8
    then
      return: (#0, #0);;;
      do:  #()
    else do:  #());;;
    let: "n" := ref_zero uint64T #() in
    let: "$a0" := machine.UInt64Get (![sliceT byteT] "p") in
    do:  "n" <-[uint64T] "$a0";;;
    return: (![uint64T] "n", #8);;;
    do:  #()).

(* DecodeEntry is a Decoder(Entry) *)
Definition DecodeEntry: val :=
  rec: "DecodeEntry" "data" :=
    exception_do (let: "data" := ref_to (sliceT byteT) "data" in
    let: "l1" := ref_zero uint64T #() in
    let: "key" := ref_zero uint64T #() in
    let: ("$a0", "$a1") := DecodeUInt64 (![sliceT byteT] "data") in
    do:  "l1" <-[uint64T] "$a1";;;
    do:  "key" <-[uint64T] "$a0";;;
    (if: (![uint64T] "l1") = #0
    then
      return: (struct.mk Entry [
         "Key" ::= #0;
         "Value" ::= slice.nil
       ], #0);;;
      do:  #()
    else do:  #());;;
    let: "l2" := ref_zero uint64T #() in
    let: "valueLen" := ref_zero uint64T #() in
    let: ("$a0", "$a1") := DecodeUInt64 (SliceSkip byteT (![sliceT byteT] "data") (![uint64T] "l1")) in
    do:  "l2" <-[uint64T] "$a1";;;
    do:  "valueLen" <-[uint64T] "$a0";;;
    (if: (![uint64T] "l2") = #0
    then
      return: (struct.mk Entry [
         "Key" ::= #0;
         "Value" ::= slice.nil
       ], #0);;;
      do:  #()
    else do:  #());;;
    (if: (slice.len (![sliceT byteT] "data")) < (((![uint64T] "l1") + (![uint64T] "l2")) + (![uint64T] "valueLen"))
    then
      return: (struct.mk Entry [
         "Key" ::= #0;
         "Value" ::= slice.nil
       ], #0);;;
      do:  #()
    else do:  #());;;
    let: "value" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceSubslice byteT (![sliceT byteT] "data") ((![uint64T] "l1") + (![uint64T] "l2")) (((![uint64T] "l1") + (![uint64T] "l2")) + (![uint64T] "valueLen")) in
    do:  "value" <-[sliceT byteT] "$a0";;;
    return: (struct.mk Entry [
       "Key" ::= ![uint64T] "key";
       "Value" ::= ![sliceT byteT] "value"
     ], ((![uint64T] "l1") + (![uint64T] "l2")) + (![uint64T] "valueLen"));;;
    do:  #()).

Definition lazyFileBuf := struct.decl [
  "offset" :: uint64T;
  "next" :: sliceT byteT
].

(* readTableIndex parses a complete table on disk into a key->offset index *)
Definition readTableIndex: val :=
  rec: "readTableIndex" "f" "index" :=
    exception_do (let: "index" := ref_to (mapT uint64T) "index" in
    let: "f" := ref_to fileT "f" in
    (let: "buf" := ref_zero (structT lazyFileBuf) #() in
    let: "$a0" := struct.mk lazyFileBuf [
      "offset" ::= #0;
      "next" ::= slice.nil
    ] in
    do:  "buf" <-[structT lazyFileBuf] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "l" := ref_zero uint64T #() in
      let: "e" := ref_zero (structT Entry) #() in
      let: ("$a0", "$a1") := DecodeEntry (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))) in
      do:  "l" <-[uint64T] "$a1";;;
      do:  "e" <-[structT Entry] "$a0";;;
      (if: (![uint64T] "l") > #0
      then
        let: "$a0" := #8 + (![struct.fieldTy lazyFileBuf "offset"] (struct.get lazyFileBuf "offset" (![structT lazyFileBuf] "buf"))) in
        do:  MapInsert (![mapT uint64T] "index") (![struct.fieldTy Entry "Key"] (struct.get Entry "Key" (![structT Entry] "e"))) "$a0";;;
        let: "$a0" := struct.mk lazyFileBuf [
          "offset" ::= (![struct.fieldTy lazyFileBuf "offset"] (struct.get lazyFileBuf "offset" (![structT lazyFileBuf] "buf"))) + (![uint64T] "l");
          "next" ::= SliceSkip byteT (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))) (![uint64T] "l")
        ] in
        do:  "buf" <-[structT lazyFileBuf] "$a0";;;
        continue: #();;;
        do:  #()
      else
        let: "p" := ref_zero (sliceT byteT) #() in
        let: "$a0" := filesys.ReadAt (![fileT] "f") ((![struct.fieldTy lazyFileBuf "offset"] (struct.get lazyFileBuf "offset" (![structT lazyFileBuf] "buf"))) + (slice.len (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))))) #4096 in
        do:  "p" <-[sliceT byteT] "$a0";;;
        (if: (slice.len (![sliceT byteT] "p")) = #0
        then
          break: #();;;
          do:  #()
        else
          let: "newBuf" := ref_zero (sliceT byteT) #() in
          let: "$a0" := SliceAppendSlice byteT (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))) (![sliceT byteT] "p") in
          do:  "newBuf" <-[sliceT byteT] "$a0";;;
          let: "$a0" := struct.mk lazyFileBuf [
            "offset" ::= ![struct.fieldTy lazyFileBuf "offset"] (struct.get lazyFileBuf "offset" (![structT lazyFileBuf] "buf"));
            "next" ::= ![sliceT byteT] "newBuf"
          ] in
          do:  "buf" <-[structT lazyFileBuf] "$a0";;;
          continue: #();;;
          do:  #());;;
        do:  #());;;
      do:  #()));;;
    do:  #()).

(* RecoverTable restores a table from disk on startup. *)
Definition RecoverTable: val :=
  rec: "RecoverTable" "p" :=
    exception_do (let: "p" := ref_to stringT "p" in
    let: "index" := ref_zero (mapT uint64T) #() in
    let: "$a0" := NewMap uint64T uint64T #() in
    do:  "index" <-[mapT uint64T] "$a0";;;
    let: "f" := ref_zero fileT #() in
    let: "$a0" := filesys.Open #(str "db") (![stringT] "p") in
    do:  "f" <-[fileT] "$a0";;;
    do:  readTableIndex (![fileT] "f") (![mapT uint64T] "index");;;
    return: (struct.mk Table [
       "Index" ::= ![mapT uint64T] "index";
       "File" ::= ![fileT] "f"
     ]);;;
    do:  #()).

(* CloseTable frees up the fd held by a table. *)
Definition CloseTable: val :=
  rec: "CloseTable" "t" :=
    exception_do (let: "t" := ref_to (structT Table) "t" in
    do:  filesys.Close (![struct.fieldTy Table "File"] (struct.get Table "File" (![structT Table] "t")));;;
    do:  #()).

Definition readValue: val :=
  rec: "readValue" "f" "off" :=
    exception_do (let: "off" := ref_to uint64T "off" in
    let: "f" := ref_to fileT "f" in
    let: "startBuf" := ref_zero (sliceT byteT) #() in
    let: "$a0" := filesys.ReadAt (![fileT] "f") (![uint64T] "off") #512 in
    do:  "startBuf" <-[sliceT byteT] "$a0";;;
    let: "totalBytes" := ref_zero uint64T #() in
    let: "$a0" := machine.UInt64Get (![sliceT byteT] "startBuf") in
    do:  "totalBytes" <-[uint64T] "$a0";;;
    let: "buf" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceSkip byteT (![sliceT byteT] "startBuf") #8 in
    do:  "buf" <-[sliceT byteT] "$a0";;;
    let: "haveBytes" := ref_zero uint64T #() in
    let: "$a0" := slice.len (![sliceT byteT] "buf") in
    do:  "haveBytes" <-[uint64T] "$a0";;;
    (if: (![uint64T] "haveBytes") < (![uint64T] "totalBytes")
    then
      let: "buf2" := ref_zero (sliceT byteT) #() in
      let: "$a0" := filesys.ReadAt (![fileT] "f") ((![uint64T] "off") + #512) ((![uint64T] "totalBytes") - (![uint64T] "haveBytes")) in
      do:  "buf2" <-[sliceT byteT] "$a0";;;
      let: "newBuf" := ref_zero (sliceT byteT) #() in
      let: "$a0" := SliceAppendSlice byteT (![sliceT byteT] "buf") (![sliceT byteT] "buf2") in
      do:  "newBuf" <-[sliceT byteT] "$a0";;;
      return: (![sliceT byteT] "newBuf");;;
      do:  #()
    else do:  #());;;
    return: (SliceTake (![sliceT byteT] "buf") (![uint64T] "totalBytes"));;;
    do:  #()).

Definition tableRead: val :=
  rec: "tableRead" "t" "k" :=
    exception_do (let: "k" := ref_to uint64T "k" in
    let: "t" := ref_to (structT Table) "t" in
    let: "ok" := ref_zero boolT #() in
    let: "off" := ref_zero uint64T #() in
    let: ("$a0", "$a1") := Fst (MapGet (![struct.fieldTy Table "Index"] (struct.get Table "Index" (![structT Table] "t"))) (![uint64T] "k")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "off" <-[uint64T] "$a0";;;
    (if: (~ (![boolT] "ok"))
    then
      return: (slice.nil, #false);;;
      do:  #()
    else do:  #());;;
    let: "p" := ref_zero (sliceT byteT) #() in
    let: "$a0" := readValue (![struct.fieldTy Table "File"] (struct.get Table "File" (![structT Table] "t"))) (![uint64T] "off") in
    do:  "p" <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "p", #true);;;
    do:  #()).

Definition bufFile := struct.decl [
  "file" :: fileT;
  "buf" :: ptrT
].

Definition newBuf: val :=
  rec: "newBuf" "f" :=
    exception_do (let: "f" := ref_to fileT "f" in
    let: "buf" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val (sliceT byteT)) in
    do:  "buf" <-[ptrT] "$a0";;;
    return: (struct.mk bufFile [
       "file" ::= ![fileT] "f";
       "buf" ::= ![ptrT] "buf"
     ]);;;
    do:  #()).

Definition bufFlush: val :=
  rec: "bufFlush" "f" :=
    exception_do (let: "f" := ref_to (structT bufFile) "f" in
    let: "buf" := ref_zero (sliceT byteT) #() in
    let: "$a0" := ![sliceT byteT] (![struct.fieldTy bufFile "buf"] (struct.get bufFile "buf" (![structT bufFile] "f"))) in
    do:  "buf" <-[sliceT byteT] "$a0";;;
    (if: (slice.len (![sliceT byteT] "buf")) = #0
    then
      return: (#());;;
      do:  #()
    else do:  #());;;
    do:  filesys.Append (![struct.fieldTy bufFile "file"] (struct.get bufFile "file" (![structT bufFile] "f"))) (![sliceT byteT] "buf");;;
    let: "$a0" := slice.nil in
    do:  (![struct.fieldTy bufFile "buf"] (struct.get bufFile "buf" (![structT bufFile] "f"))) <-[sliceT byteT] "$a0";;;
    do:  #()).

Definition bufAppend: val :=
  rec: "bufAppend" "f" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    let: "f" := ref_to (structT bufFile) "f" in
    let: "buf" := ref_zero (sliceT byteT) #() in
    let: "$a0" := ![sliceT byteT] (![struct.fieldTy bufFile "buf"] (struct.get bufFile "buf" (![structT bufFile] "f"))) in
    do:  "buf" <-[sliceT byteT] "$a0";;;
    let: "buf2" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceAppendSlice byteT (![sliceT byteT] "buf") (![sliceT byteT] "p") in
    do:  "buf2" <-[sliceT byteT] "$a0";;;
    let: "$a0" := ![sliceT byteT] "buf2" in
    do:  (![struct.fieldTy bufFile "buf"] (struct.get bufFile "buf" (![structT bufFile] "f"))) <-[sliceT byteT] "$a0";;;
    do:  #()).

Definition bufClose: val :=
  rec: "bufClose" "f" :=
    exception_do (let: "f" := ref_to (structT bufFile) "f" in
    do:  bufFlush (![structT bufFile] "f");;;
    do:  filesys.Close (![struct.fieldTy bufFile "file"] (struct.get bufFile "file" (![structT bufFile] "f")));;;
    do:  #()).

Definition tableWriter := struct.decl [
  "index" :: mapT uint64T;
  "name" :: stringT;
  "file" :: structT bufFile;
  "offset" :: ptrT
].

Definition newTableWriter: val :=
  rec: "newTableWriter" "p" :=
    exception_do (let: "p" := ref_to stringT "p" in
    let: "index" := ref_zero (mapT uint64T) #() in
    let: "$a0" := NewMap uint64T uint64T #() in
    do:  "index" <-[mapT uint64T] "$a0";;;
    let: <> := ref_zero boolT #() in
    let: "f" := ref_zero fileT #() in
    let: ("$a0", "$a1") := filesys.Create #(str "db") (![stringT] "p") in
    do:  "$a1";;;
    do:  "f" <-[fileT] "$a0";;;
    let: "buf" := ref_zero (structT bufFile) #() in
    let: "$a0" := newBuf (![fileT] "f") in
    do:  "buf" <-[structT bufFile] "$a0";;;
    let: "off" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val uint64T) in
    do:  "off" <-[ptrT] "$a0";;;
    return: (struct.mk tableWriter [
       "index" ::= ![mapT uint64T] "index";
       "name" ::= ![stringT] "p";
       "file" ::= ![structT bufFile] "buf";
       "offset" ::= ![ptrT] "off"
     ]);;;
    do:  #()).

Definition tableWriterAppend: val :=
  rec: "tableWriterAppend" "w" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    let: "w" := ref_to (structT tableWriter) "w" in
    do:  bufAppend (![struct.fieldTy tableWriter "file"] (struct.get tableWriter "file" (![structT tableWriter] "w"))) (![sliceT byteT] "p");;;
    let: "off" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![struct.fieldTy tableWriter "offset"] (struct.get tableWriter "offset" (![structT tableWriter] "w"))) in
    do:  "off" <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] "off") + (slice.len (![sliceT byteT] "p")) in
    do:  (![struct.fieldTy tableWriter "offset"] (struct.get tableWriter "offset" (![structT tableWriter] "w"))) <-[uint64T] "$a0";;;
    do:  #()).

Definition tableWriterClose: val :=
  rec: "tableWriterClose" "w" :=
    exception_do (let: "w" := ref_to (structT tableWriter) "w" in
    do:  bufClose (![struct.fieldTy tableWriter "file"] (struct.get tableWriter "file" (![structT tableWriter] "w")));;;
    let: "f" := ref_zero fileT #() in
    let: "$a0" := filesys.Open #(str "db") (![struct.fieldTy tableWriter "name"] (struct.get tableWriter "name" (![structT tableWriter] "w"))) in
    do:  "f" <-[fileT] "$a0";;;
    return: (struct.mk Table [
       "Index" ::= ![struct.fieldTy tableWriter "index"] (struct.get tableWriter "index" (![structT tableWriter] "w"));
       "File" ::= ![fileT] "f"
     ]);;;
    do:  #()).

(* EncodeUInt64 is an Encoder(uint64) *)
Definition EncodeUInt64: val :=
  rec: "EncodeUInt64" "x" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    let: "x" := ref_to uint64T "x" in
    let: "tmp" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #8 in
    do:  "tmp" <-[sliceT byteT] "$a0";;;
    do:  machine.UInt64Put (![sliceT byteT] "tmp") (![uint64T] "x");;;
    let: "p2" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceAppendSlice byteT (![sliceT byteT] "p") (![sliceT byteT] "tmp") in
    do:  "p2" <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "p2");;;
    do:  #()).

(* EncodeSlice is an Encoder([]byte) *)
Definition EncodeSlice: val :=
  rec: "EncodeSlice" "data" "p" :=
    exception_do (let: "p" := ref_to (sliceT byteT) "p" in
    let: "data" := ref_to (sliceT byteT) "data" in
    let: "p2" := ref_zero (sliceT byteT) #() in
    let: "$a0" := EncodeUInt64 (slice.len (![sliceT byteT] "data")) (![sliceT byteT] "p") in
    do:  "p2" <-[sliceT byteT] "$a0";;;
    let: "p3" := ref_zero (sliceT byteT) #() in
    let: "$a0" := SliceAppendSlice byteT (![sliceT byteT] "p2") (![sliceT byteT] "data") in
    do:  "p3" <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "p3");;;
    do:  #()).

Definition tablePut: val :=
  rec: "tablePut" "w" "k" "v" :=
    exception_do (let: "v" := ref_to (sliceT byteT) "v" in
    let: "k" := ref_to uint64T "k" in
    let: "w" := ref_to (structT tableWriter) "w" in
    let: "tmp" := ref_zero (sliceT byteT) #() in
    let: "$a0" := NewSlice byteT #0 in
    do:  "tmp" <-[sliceT byteT] "$a0";;;
    let: "tmp2" := ref_zero (sliceT byteT) #() in
    let: "$a0" := EncodeUInt64 (![uint64T] "k") (![sliceT byteT] "tmp") in
    do:  "tmp2" <-[sliceT byteT] "$a0";;;
    let: "tmp3" := ref_zero (sliceT byteT) #() in
    let: "$a0" := EncodeSlice (![sliceT byteT] "v") (![sliceT byteT] "tmp2") in
    do:  "tmp3" <-[sliceT byteT] "$a0";;;
    let: "off" := ref_zero uint64T #() in
    let: "$a0" := ![uint64T] (![struct.fieldTy tableWriter "offset"] (struct.get tableWriter "offset" (![structT tableWriter] "w"))) in
    do:  "off" <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] "off") + (slice.len (![sliceT byteT] "tmp2")) in
    do:  MapInsert (![struct.fieldTy tableWriter "index"] (struct.get tableWriter "index" (![structT tableWriter] "w"))) (![uint64T] "k") "$a0";;;
    do:  tableWriterAppend (![structT tableWriter] "w") (![sliceT byteT] "tmp3");;;
    do:  #()).

Definition Database := struct.decl [
  "wbuffer" :: ptrT;
  "rbuffer" :: ptrT;
  "bufferL" :: ptrT;
  "table" :: ptrT;
  "tableName" :: ptrT;
  "tableL" :: ptrT;
  "compactionL" :: ptrT
].

Definition makeValueBuffer: val :=
  rec: "makeValueBuffer" <> :=
    exception_do (let: "buf" := ref_zero (mapT (sliceT byteT)) #() in
    let: "$a0" := NewMap uint64T (sliceT byteT) #() in
    do:  "buf" <-[mapT (sliceT byteT)] "$a0";;;
    let: "bufPtr" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val (mapT (sliceT byteT))) in
    do:  "bufPtr" <-[ptrT] "$a0";;;
    let: "$a0" := ![mapT (sliceT byteT)] "buf" in
    do:  (![ptrT] "bufPtr") <-[mapT (sliceT byteT)] "$a0";;;
    return: (![ptrT] "bufPtr");;;
    do:  #()).

(* NewDb initializes a new database on top of an empty filesys. *)
Definition NewDb: val :=
  rec: "NewDb" <> :=
    exception_do (let: "wbuf" := ref_zero ptrT #() in
    let: "$a0" := makeValueBuffer #() in
    do:  "wbuf" <-[ptrT] "$a0";;;
    let: "rbuf" := ref_zero ptrT #() in
    let: "$a0" := makeValueBuffer #() in
    do:  "rbuf" <-[ptrT] "$a0";;;
    let: "bufferL" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "bufferL" <-[ptrT] "$a0";;;
    let: "tableName" := ref_zero stringT #() in
    let: "$a0" := #(str "table.0") in
    do:  "tableName" <-[stringT] "$a0";;;
    let: "tableNameRef" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val stringT) in
    do:  "tableNameRef" <-[ptrT] "$a0";;;
    let: "$a0" := ![stringT] "tableName" in
    do:  (![ptrT] "tableNameRef") <-[stringT] "$a0";;;
    let: "table" := ref_zero (structT Table) #() in
    let: "$a0" := CreateTable (![stringT] "tableName") in
    do:  "table" <-[structT Table] "$a0";;;
    let: "tableRef" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc Table (zero_val (structT Table)) in
    do:  "tableRef" <-[ptrT] "$a0";;;
    let: "$a0" := ![structT Table] "table" in
    do:  struct.store Table (![ptrT] "tableRef") "$a0";;;
    let: "tableL" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "tableL" <-[ptrT] "$a0";;;
    let: "compactionL" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "compactionL" <-[ptrT] "$a0";;;
    return: (struct.mk Database [
       "wbuffer" ::= ![ptrT] "wbuf";
       "rbuffer" ::= ![ptrT] "rbuf";
       "bufferL" ::= ![ptrT] "bufferL";
       "table" ::= ![ptrT] "tableRef";
       "tableName" ::= ![ptrT] "tableNameRef";
       "tableL" ::= ![ptrT] "tableL";
       "compactionL" ::= ![ptrT] "compactionL"
     ]);;;
    do:  #()).

(* Read gets a key from the database.

   Returns a boolean indicating if the k was found and a non-nil slice with
   the value if k was in the database.

   Reflects any completed in-memory writes. *)
Definition Read: val :=
  rec: "Read" "db" "k" :=
    exception_do (let: "k" := ref_to uint64T "k" in
    let: "db" := ref_to (structT Database) "db" in
    do:  sync.Mutex__Lock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    let: "buf" := ref_zero (mapT (sliceT byteT)) #() in
    let: "$a0" := ![mapT (sliceT byteT)] (![struct.fieldTy Database "wbuffer"] (struct.get Database "wbuffer" (![structT Database] "db"))) in
    do:  "buf" <-[mapT (sliceT byteT)] "$a0";;;
    let: "ok" := ref_zero boolT #() in
    let: "v" := ref_zero (sliceT byteT) #() in
    let: ("$a0", "$a1") := Fst (MapGet (![mapT (sliceT byteT)] "buf") (![uint64T] "k")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v" <-[sliceT byteT] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  sync.Mutex__Unlock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
      return: (![sliceT byteT] "v", #true);;;
      do:  #()
    else do:  #());;;
    let: "rbuf" := ref_zero (mapT (sliceT byteT)) #() in
    let: "$a0" := ![mapT (sliceT byteT)] (![struct.fieldTy Database "rbuffer"] (struct.get Database "rbuffer" (![structT Database] "db"))) in
    do:  "rbuf" <-[mapT (sliceT byteT)] "$a0";;;
    let: "v2" := ref_zero (sliceT byteT) #() in
    let: ("$a0", "$a1") := Fst (MapGet (![mapT (sliceT byteT)] "rbuf") (![uint64T] "k")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v2" <-[sliceT byteT] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  sync.Mutex__Unlock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
      return: (![sliceT byteT] "v2", #true);;;
      do:  #()
    else do:  #());;;
    do:  sync.Mutex__Lock (![struct.fieldTy Database "tableL"] (struct.get Database "tableL" (![structT Database] "db")));;;
    let: "tbl" := ref_zero (structT Table) #() in
    let: "$a0" := struct.load Table (![struct.fieldTy Database "table"] (struct.get Database "table" (![structT Database] "db"))) in
    do:  "tbl" <-[structT Table] "$a0";;;
    let: "v3" := ref_zero (sliceT byteT) #() in
    let: ("$a0", "$a1") := tableRead (![structT Table] "tbl") (![uint64T] "k") in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v3" <-[sliceT byteT] "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "tableL"] (struct.get Database "tableL" (![structT Database] "db")));;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    return: (![sliceT byteT] "v3", ![boolT] "ok");;;
    do:  #()).

(* Write sets a key to a new value.

   Creates a new key-value mapping if k is not in the database and overwrites
   the previous value if k is present.

   The new value is buffered in memory. To persist it, call db.Compact(). *)
Definition Write: val :=
  rec: "Write" "db" "k" "v" :=
    exception_do (let: "v" := ref_to (sliceT byteT) "v" in
    let: "k" := ref_to uint64T "k" in
    let: "db" := ref_to (structT Database) "db" in
    do:  sync.Mutex__Lock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    let: "buf" := ref_zero (mapT (sliceT byteT)) #() in
    let: "$a0" := ![mapT (sliceT byteT)] (![struct.fieldTy Database "wbuffer"] (struct.get Database "wbuffer" (![structT Database] "db"))) in
    do:  "buf" <-[mapT (sliceT byteT)] "$a0";;;
    let: "$a0" := ![sliceT byteT] "v" in
    do:  MapInsert (![mapT (sliceT byteT)] "buf") (![uint64T] "k") "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    do:  #()).

Definition freshTable: val :=
  rec: "freshTable" "p" :=
    exception_do (let: "p" := ref_to stringT "p" in
    (if: (![stringT] "p") = #(str "table.0")
    then
      return: (#(str "table.1"));;;
      do:  #()
    else do:  #());;;
    (if: (![stringT] "p") = #(str "table.1")
    then
      return: (#(str "table.0"));;;
      do:  #()
    else do:  #());;;
    return: (![stringT] "p");;;
    do:  #()).

Definition tablePutBuffer: val :=
  rec: "tablePutBuffer" "w" "buf" :=
    exception_do (let: "buf" := ref_to (mapT (sliceT byteT)) "buf" in
    let: "w" := ref_to (structT tableWriter) "w" in
    do:  MapIter (![mapT (sliceT byteT)] "buf") (λ: "k" "v",
      do:  tablePut (![structT tableWriter] "w") (![uint64T] "k") (![sliceT byteT] "v");;;
      do:  #());;;
    do:  #()).

(* add all of table t to the table w being created; skip any keys in the (read)
   buffer b since those writes overwrite old ones *)
Definition tablePutOldTable: val :=
  rec: "tablePutOldTable" "w" "t" "b" :=
    exception_do (let: "b" := ref_to (mapT (sliceT byteT)) "b" in
    let: "t" := ref_to (structT Table) "t" in
    let: "w" := ref_to (structT tableWriter) "w" in
    (let: "buf" := ref_zero (structT lazyFileBuf) #() in
    let: "$a0" := struct.mk lazyFileBuf [
      "offset" ::= #0;
      "next" ::= slice.nil
    ] in
    do:  "buf" <-[structT lazyFileBuf] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "l" := ref_zero uint64T #() in
      let: "e" := ref_zero (structT Entry) #() in
      let: ("$a0", "$a1") := DecodeEntry (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))) in
      do:  "l" <-[uint64T] "$a1";;;
      do:  "e" <-[structT Entry] "$a0";;;
      (if: (![uint64T] "l") > #0
      then
        let: "ok" := ref_zero boolT #() in
        let: <> := ref_zero (sliceT byteT) #() in
        let: ("$a0", "$a1") := Fst (MapGet (![mapT (sliceT byteT)] "b") (![struct.fieldTy Entry "Key"] (struct.get Entry "Key" (![structT Entry] "e")))) in
        do:  "ok" <-[boolT] "$a1";;;
        do:  "$a0";;;
        (if: (~ (![boolT] "ok"))
        then
          do:  tablePut (![structT tableWriter] "w") (![struct.fieldTy Entry "Key"] (struct.get Entry "Key" (![structT Entry] "e"))) (![struct.fieldTy Entry "Value"] (struct.get Entry "Value" (![structT Entry] "e")));;;
          do:  #()
        else do:  #());;;
        let: "$a0" := struct.mk lazyFileBuf [
          "offset" ::= (![struct.fieldTy lazyFileBuf "offset"] (struct.get lazyFileBuf "offset" (![structT lazyFileBuf] "buf"))) + (![uint64T] "l");
          "next" ::= SliceSkip byteT (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))) (![uint64T] "l")
        ] in
        do:  "buf" <-[structT lazyFileBuf] "$a0";;;
        continue: #();;;
        do:  #()
      else
        let: "p" := ref_zero (sliceT byteT) #() in
        let: "$a0" := filesys.ReadAt (![struct.fieldTy Table "File"] (struct.get Table "File" (![structT Table] "t"))) ((![struct.fieldTy lazyFileBuf "offset"] (struct.get lazyFileBuf "offset" (![structT lazyFileBuf] "buf"))) + (slice.len (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))))) #4096 in
        do:  "p" <-[sliceT byteT] "$a0";;;
        (if: (slice.len (![sliceT byteT] "p")) = #0
        then
          break: #();;;
          do:  #()
        else
          let: "newBuf" := ref_zero (sliceT byteT) #() in
          let: "$a0" := SliceAppendSlice byteT (![struct.fieldTy lazyFileBuf "next"] (struct.get lazyFileBuf "next" (![structT lazyFileBuf] "buf"))) (![sliceT byteT] "p") in
          do:  "newBuf" <-[sliceT byteT] "$a0";;;
          let: "$a0" := struct.mk lazyFileBuf [
            "offset" ::= ![struct.fieldTy lazyFileBuf "offset"] (struct.get lazyFileBuf "offset" (![structT lazyFileBuf] "buf"));
            "next" ::= ![sliceT byteT] "newBuf"
          ] in
          do:  "buf" <-[structT lazyFileBuf] "$a0";;;
          continue: #();;;
          do:  #());;;
        do:  #());;;
      do:  #()));;;
    do:  #()).

(* Build a new shadow table that incorporates the current table and a
   (write) buffer wbuf.

   Assumes all the appropriate locks have been taken.

   Returns the old table and new table. *)
Definition constructNewTable: val :=
  rec: "constructNewTable" "db" "wbuf" :=
    exception_do (let: "wbuf" := ref_to (mapT (sliceT byteT)) "wbuf" in
    let: "db" := ref_to (structT Database) "db" in
    let: "oldName" := ref_zero stringT #() in
    let: "$a0" := ![stringT] (![struct.fieldTy Database "tableName"] (struct.get Database "tableName" (![structT Database] "db"))) in
    do:  "oldName" <-[stringT] "$a0";;;
    let: "name" := ref_zero stringT #() in
    let: "$a0" := freshTable (![stringT] "oldName") in
    do:  "name" <-[stringT] "$a0";;;
    let: "w" := ref_zero (structT tableWriter) #() in
    let: "$a0" := newTableWriter (![stringT] "name") in
    do:  "w" <-[structT tableWriter] "$a0";;;
    let: "oldTable" := ref_zero (structT Table) #() in
    let: "$a0" := struct.load Table (![struct.fieldTy Database "table"] (struct.get Database "table" (![structT Database] "db"))) in
    do:  "oldTable" <-[structT Table] "$a0";;;
    do:  tablePutOldTable (![structT tableWriter] "w") (![structT Table] "oldTable") (![mapT (sliceT byteT)] "wbuf");;;
    do:  tablePutBuffer (![structT tableWriter] "w") (![mapT (sliceT byteT)] "wbuf");;;
    let: "newTable" := ref_zero (structT Table) #() in
    let: "$a0" := tableWriterClose (![structT tableWriter] "w") in
    do:  "newTable" <-[structT Table] "$a0";;;
    return: (![structT Table] "oldTable", ![structT Table] "newTable");;;
    do:  #()).

(* Compact persists in-memory writes to a new table.

   This simple database design must re-write all data to combine in-memory
   writes with existing writes. *)
Definition Compact: val :=
  rec: "Compact" "db" :=
    exception_do (let: "db" := ref_to (structT Database) "db" in
    do:  sync.Mutex__Lock (![struct.fieldTy Database "compactionL"] (struct.get Database "compactionL" (![structT Database] "db")));;;
    do:  sync.Mutex__Lock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    let: "buf" := ref_zero (mapT (sliceT byteT)) #() in
    let: "$a0" := ![mapT (sliceT byteT)] (![struct.fieldTy Database "wbuffer"] (struct.get Database "wbuffer" (![structT Database] "db"))) in
    do:  "buf" <-[mapT (sliceT byteT)] "$a0";;;
    let: "emptyWbuffer" := ref_zero (mapT (sliceT byteT)) #() in
    let: "$a0" := NewMap uint64T (sliceT byteT) #() in
    do:  "emptyWbuffer" <-[mapT (sliceT byteT)] "$a0";;;
    let: "$a0" := ![mapT (sliceT byteT)] "emptyWbuffer" in
    do:  (![struct.fieldTy Database "wbuffer"] (struct.get Database "wbuffer" (![structT Database] "db"))) <-[mapT (sliceT byteT)] "$a0";;;
    let: "$a0" := ![mapT (sliceT byteT)] "buf" in
    do:  (![struct.fieldTy Database "rbuffer"] (struct.get Database "rbuffer" (![structT Database] "db"))) <-[mapT (sliceT byteT)] "$a0";;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    do:  sync.Mutex__Lock (![struct.fieldTy Database "tableL"] (struct.get Database "tableL" (![structT Database] "db")));;;
    let: "oldTableName" := ref_zero stringT #() in
    let: "$a0" := ![stringT] (![struct.fieldTy Database "tableName"] (struct.get Database "tableName" (![structT Database] "db"))) in
    do:  "oldTableName" <-[stringT] "$a0";;;
    let: "t" := ref_zero (structT Table) #() in
    let: "oldTable" := ref_zero (structT Table) #() in
    let: ("$a0", "$a1") := constructNewTable (![structT Database] "db") (![mapT (sliceT byteT)] "buf") in
    do:  "t" <-[structT Table] "$a1";;;
    do:  "oldTable" <-[structT Table] "$a0";;;
    let: "newTable" := ref_zero stringT #() in
    let: "$a0" := freshTable (![stringT] "oldTableName") in
    do:  "newTable" <-[stringT] "$a0";;;
    let: "$a0" := ![structT Table] "t" in
    do:  struct.store Table (![struct.fieldTy Database "table"] (struct.get Database "table" (![structT Database] "db"))) "$a0";;;
    let: "$a0" := ![stringT] "newTable" in
    do:  (![struct.fieldTy Database "tableName"] (struct.get Database "tableName" (![structT Database] "db"))) <-[stringT] "$a0";;;
    let: "manifestData" := ref_zero (sliceT byteT) #() in
    let: "$a0" := StringToBytes (![stringT] "newTable") in
    do:  "manifestData" <-[sliceT byteT] "$a0";;;
    do:  filesys.AtomicCreate #(str "db") #(str "manifest") (![sliceT byteT] "manifestData");;;
    do:  CloseTable (![structT Table] "oldTable");;;
    do:  filesys.Delete #(str "db") (![stringT] "oldTableName");;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "tableL"] (struct.get Database "tableL" (![structT Database] "db")));;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "compactionL"] (struct.get Database "compactionL" (![structT Database] "db")));;;
    do:  #()).

Definition recoverManifest: val :=
  rec: "recoverManifest" <> :=
    exception_do (let: "f" := ref_zero fileT #() in
    let: "$a0" := filesys.Open #(str "db") #(str "manifest") in
    do:  "f" <-[fileT] "$a0";;;
    let: "manifestData" := ref_zero (sliceT byteT) #() in
    let: "$a0" := filesys.ReadAt (![fileT] "f") #0 #4096 in
    do:  "manifestData" <-[sliceT byteT] "$a0";;;
    let: "tableName" := ref_zero stringT #() in
    let: "$a0" := StringFromBytes (![sliceT byteT] "manifestData") in
    do:  "tableName" <-[stringT] "$a0";;;
    do:  filesys.Close (![fileT] "f");;;
    return: (![stringT] "tableName");;;
    do:  #()).

(* delete 'name' if it isn't tableName or "manifest" *)
Definition deleteOtherFile: val :=
  rec: "deleteOtherFile" "name" "tableName" :=
    exception_do (let: "tableName" := ref_to stringT "tableName" in
    let: "name" := ref_to stringT "name" in
    (if: (![stringT] "name") = (![stringT] "tableName")
    then
      return: (#());;;
      do:  #()
    else do:  #());;;
    (if: (![stringT] "name") = #(str "manifest")
    then
      return: (#());;;
      do:  #()
    else do:  #());;;
    do:  filesys.Delete #(str "db") (![stringT] "name");;;
    do:  #()).

Definition deleteOtherFiles: val :=
  rec: "deleteOtherFiles" "tableName" :=
    exception_do (let: "tableName" := ref_to stringT "tableName" in
    let: "files" := ref_zero (sliceT stringT) #() in
    let: "$a0" := filesys.List #(str "db") in
    do:  "files" <-[sliceT stringT] "$a0";;;
    let: "nfiles" := ref_zero uint64T #() in
    let: "$a0" := slice.len (![sliceT stringT] "files") in
    do:  "nfiles" <-[uint64T] "$a0";;;
    (let: "i" := ref_zero uint64T #() in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") = (![uint64T] "nfiles")
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "name" := ref_zero stringT #() in
      let: "$a0" := SliceGet stringT (![sliceT stringT] "files") (![uint64T] "i") in
      do:  "name" <-[stringT] "$a0";;;
      do:  deleteOtherFile (![stringT] "name") (![stringT] "tableName");;;
      let: "$a0" := (![uint64T] "i") + #1 in
      do:  "i" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

(* Recover restores a previously created database after a crash or shutdown. *)
Definition Recover: val :=
  rec: "Recover" <> :=
    exception_do (let: "tableName" := ref_zero stringT #() in
    let: "$a0" := recoverManifest #() in
    do:  "tableName" <-[stringT] "$a0";;;
    let: "table" := ref_zero (structT Table) #() in
    let: "$a0" := RecoverTable (![stringT] "tableName") in
    do:  "table" <-[structT Table] "$a0";;;
    let: "tableRef" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc Table (zero_val (structT Table)) in
    do:  "tableRef" <-[ptrT] "$a0";;;
    let: "$a0" := ![structT Table] "table" in
    do:  struct.store Table (![ptrT] "tableRef") "$a0";;;
    let: "tableNameRef" := ref_zero ptrT #() in
    let: "$a0" := ref (zero_val stringT) in
    do:  "tableNameRef" <-[ptrT] "$a0";;;
    let: "$a0" := ![stringT] "tableName" in
    do:  (![ptrT] "tableNameRef") <-[stringT] "$a0";;;
    do:  deleteOtherFiles (![stringT] "tableName");;;
    let: "wbuffer" := ref_zero ptrT #() in
    let: "$a0" := makeValueBuffer #() in
    do:  "wbuffer" <-[ptrT] "$a0";;;
    let: "rbuffer" := ref_zero ptrT #() in
    let: "$a0" := makeValueBuffer #() in
    do:  "rbuffer" <-[ptrT] "$a0";;;
    let: "bufferL" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "bufferL" <-[ptrT] "$a0";;;
    let: "tableL" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "tableL" <-[ptrT] "$a0";;;
    let: "compactionL" := ref_zero ptrT #() in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (structT sync.Mutex)) in
    do:  "compactionL" <-[ptrT] "$a0";;;
    return: (struct.mk Database [
       "wbuffer" ::= ![ptrT] "wbuffer";
       "rbuffer" ::= ![ptrT] "rbuffer";
       "bufferL" ::= ![ptrT] "bufferL";
       "table" ::= ![ptrT] "tableRef";
       "tableName" ::= ![ptrT] "tableNameRef";
       "tableL" ::= ![ptrT] "tableL";
       "compactionL" ::= ![ptrT] "compactionL"
     ]);;;
    do:  #()).

(* Shutdown immediately closes the database.

   Discards any uncommitted in-memory writes; similar to a crash except for
   cleanly closing any open files. *)
Definition Shutdown: val :=
  rec: "Shutdown" "db" :=
    exception_do (let: "db" := ref_to (structT Database) "db" in
    do:  sync.Mutex__Lock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    do:  sync.Mutex__Lock (![struct.fieldTy Database "compactionL"] (struct.get Database "compactionL" (![structT Database] "db")));;;
    let: "t" := ref_zero (structT Table) #() in
    let: "$a0" := struct.load Table (![struct.fieldTy Database "table"] (struct.get Database "table" (![structT Database] "db"))) in
    do:  "t" <-[structT Table] "$a0";;;
    do:  CloseTable (![structT Table] "t");;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "compactionL"] (struct.get Database "compactionL" (![structT Database] "db")));;;
    do:  sync.Mutex__Unlock (![struct.fieldTy Database "bufferL"] (struct.get Database "bufferL" (![structT Database] "db")));;;
    do:  #()).

(* Close closes an open database cleanly, flushing any in-memory writes.

   db should not be used afterward *)
Definition Close: val :=
  rec: "Close" "db" :=
    exception_do (let: "db" := ref_to (structT Database) "db" in
    do:  Compact (![structT Database] "db");;;
    do:  Shutdown (![structT Database] "db");;;
    do:  #()).

End code.
