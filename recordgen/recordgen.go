package recordgen

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"io"
	"strings"

	"github.com/goose-lang/goose/glang"
	"golang.org/x/tools/go/packages"
)

func toCoqType(t types.Type) string {
	switch t := t.(type) {
	case *types.Basic:
		switch t.Name() {
		case "uint64", "int64":
			return "w64"
		case "uint32", "int32":
			return "w32"
		case "uint8", "int8", "byte":
			return "w8"
		case "int":
			return "w64"
		case "bool":
			return "bool"
		case "string", "untyped string":
			return "string"
		}
	case *types.Slice:
		return "slice.t"
	case *types.Array:
		panic("Arrays unsupported in this tool")
	case *types.Pointer:
		return "loc"
	case *types.Signature:
		return "func.t"
	case *types.Interface:
		return "interface.t"
	case *types.Map, *types.Chan:
		return "loc"
	case *types.Named:
		u := t.Underlying()
		if _, ok := u.(*types.Struct); ok {
			return t.String() + ".t"
		}
		return toCoqType(u)
	}
	panic(fmt.Sprint("Unknown type", t))
}

func toCoqName(n string) string {
	if n == "Type" {
		return "Type'"
	}
	return n
}

func Decl(w io.Writer, info types.Info, d ast.Decl) {
	switch d := d.(type) {
	case *ast.FuncDecl:
	case *ast.GenDecl:
		switch d.Tok {
		case token.TYPE:
			for _, spec := range d.Specs {
				spec := spec.(*ast.TypeSpec)
				if s, ok := info.TypeOf(spec.Type).(*types.Struct); ok {
					// Emit record type
					fieldVals := new(strings.Builder)
					for i := 0; i < s.NumFields(); i++ {
						fmt.Fprintf(fieldVals, "  %s : %s;\n",
							s.Field(i).Name(),
							toCoqType(s.Field(i).Type()),
						)
					}

					fmt.Fprintf(w, `
Module %s.
Record t := mk {
%s}.
End %s.
`, spec.Name.Name, fieldVals.String(), spec.Name.Name)
				}
			}
		}
	case *ast.BadDecl:
	default:
	}
}

func Package(w io.Writer, pkg *packages.Package) {
	fmt.Fprintf(w, "(* autogenerated by goose record generator; do not modify *)\n")
	// FIXME: import package code
	coqPath := strings.ReplaceAll(glang.ThisIsBadAndShouldBeDeprecatedGoPathToCoqPath(pkg.PkgPath), "/", ".")
	fmt.Fprintf(w, "From New.code Require %s.\n", coqPath)
	fmt.Fprintf(w, "From New.golang Require Import theory.\n\n")

	for _, f := range pkg.Syntax {
		for _, d := range f.Decls {
			Decl(w, *pkg.TypesInfo, d)
		}
	}
}
