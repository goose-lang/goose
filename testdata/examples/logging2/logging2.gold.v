(* autogenerated from github.com/tchajed/goose/testdata/examples/logging2 *)
From New.golang Require Import defn.
From New.code Require github_com.tchajed.goose.machine.
From New.code Require github_com.tchajed.goose.machine.disk.
From New.code Require sync.

From New Require Import disk_prelude.

(* logging2.go *)

Definition LOGCOMMIT : expr := #0.

Definition LOGSTART : expr := #1.

Definition LOGMAXBLK : expr := #510.

Definition LOGEND : expr := LOGMAXBLK + LOGSTART.

Definition Log : go_type := structT [
  "logLock" :: ptrT;
  "memLock" :: ptrT;
  "logSz" :: uint64T;
  "memLog" :: ptrT;
  "memLen" :: ptrT;
  "memTxnNxt" :: ptrT;
  "logTxnNxt" :: ptrT
].

Definition Log__writeHdr : val :=
  rec: "Log__writeHdr" "log" "len" :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "len" := ref_ty uint64T "len" in
    let: "hdr" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #4096 in
    do:  "hdr" <-[sliceT byteT] "$a0";;;
    do:  machine.UInt64Put (![sliceT byteT] "hdr") (![uint64T] "len");;;
    do:  disk.Write LOGCOMMIT (![sliceT byteT] "hdr");;;
    do:  #()).

Definition Init : val :=
  rec: "Init" "logSz" :=
    exception_do (let: "logSz" := ref_ty uint64T "logSz" in
    let: "log" := ref_ty Log (zero_val Log) in
    let: "$a0" := struct.make Log [{
      "logLock" ::= ref_ty sync.Mutex (zero_val sync.Mutex);
      "memLock" ::= ref_ty sync.Mutex (zero_val sync.Mutex);
      "logSz" ::= ![uint64T] "logSz";
      "memLog" ::= ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT)));
      "memLen" ::= ref_ty uint64T (zero_val uint64T);
      "memTxnNxt" ::= ref_ty uint64T (zero_val uint64T);
      "logTxnNxt" ::= ref_ty uint64T (zero_val uint64T)
    }] in
    do:  "log" <-[Log] "$a0";;;
    do:  (Log__writeHdr (![Log] "log")) #0;;;
    return: (![Log] "log");;;
    do:  #()).

Definition Log__readHdr : val :=
  rec: "Log__readHdr" "log" <> :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "hdr" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := disk.Read LOGCOMMIT in
    do:  "hdr" <-[sliceT byteT] "$a0";;;
    let: "disklen" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := machine.UInt64Get (![sliceT byteT] "hdr") in
    do:  "disklen" <-[uint64T] "$a0";;;
    return: (![uint64T] "disklen");;;
    do:  #()).

Definition Log__readBlocks : val :=
  rec: "Log__readBlocks" "log" "len" :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "len" := ref_ty uint64T "len" in
    let: "blks" := ref_ty (sliceT (sliceT byteT)) (slice.make2 (sliceT byteT) #0) in
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "len")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "blk" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
      let: "$a0" := disk.Read (LOGSTART + (![uint64T] "i")) in
      do:  "blk" <-[sliceT byteT] "$a0";;;
      let: "$a0" := slice.append (sliceT byteT) (![sliceT (sliceT byteT)] "blks") (slice.literal (sliceT byteT) [![sliceT byteT] "blk"]) in
      do:  "blks" <-[sliceT (sliceT byteT)] "$a0";;;
      do:  #()));;;
    return: (![sliceT (sliceT byteT)] "blks");;;
    do:  #()).

Definition Log__Read : val :=
  rec: "Log__Read" "log" <> :=
    exception_do (let: "log" := ref_ty Log "log" in
    do:  (sync.Mutex__Lock (![ptrT] (struct.field_ref Log "logLock" "log"))) #();;;
    let: "disklen" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := (Log__readHdr (![Log] "log")) #() in
    do:  "disklen" <-[uint64T] "$a0";;;
    let: "blks" := ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT))) in
    let: "$a0" := (Log__readBlocks (![Log] "log")) (![uint64T] "disklen") in
    do:  "blks" <-[sliceT (sliceT byteT)] "$a0";;;
    do:  (sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "logLock" "log"))) #();;;
    return: (![sliceT (sliceT byteT)] "blks");;;
    do:  #()).

Definition Log__memWrite : val :=
  rec: "Log__memWrite" "log" "l" :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "l" := ref_ty (sliceT (sliceT byteT)) "l" in
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := slice.len (![sliceT (sliceT byteT)] "l") in
    do:  "n" <-[uint64T] "$a0";;;
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "n")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "$a0" := slice.append (sliceT byteT) (![sliceT (sliceT byteT)] (![ptrT] (struct.field_ref Log "memLog" "log"))) (slice.literal (sliceT byteT) [![sliceT byteT] (slice.elem_ref (sliceT byteT) (![sliceT (sliceT byteT)] "l") (![uint64T] "i"))]) in
      do:  (![ptrT] (struct.field_ref Log "memLog" "log")) <-[sliceT (sliceT byteT)] "$a0";;;
      do:  #()));;;
    do:  #()).

Definition Log__memAppend : val :=
  rec: "Log__memAppend" "log" "l" :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "l" := ref_ty (sliceT (sliceT byteT)) "l" in
    do:  (sync.Mutex__Lock (![ptrT] (struct.field_ref Log "memLock" "log"))) #();;;
    (if: ((![uint64T] (![ptrT] (struct.field_ref Log "memLen" "log"))) + (slice.len (![sliceT (sliceT byteT)] "l"))) ≥ (![uint64T] (struct.field_ref Log "logSz" "log"))
    then
      do:  (sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #();;;
      return: (#false, #0);;;
      do:  #()
    else do:  #());;;
    let: "txn" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "memTxnNxt" "log")) in
    do:  "txn" <-[uint64T] "$a0";;;
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := (![uint64T] (![ptrT] (struct.field_ref Log "memLen" "log"))) + (slice.len (![sliceT (sliceT byteT)] "l")) in
    do:  "n" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "n" in
    do:  (![ptrT] (struct.field_ref Log "memLen" "log")) <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] (![ptrT] (struct.field_ref Log "memTxnNxt" "log"))) + #1 in
    do:  (![ptrT] (struct.field_ref Log "memTxnNxt" "log")) <-[uint64T] "$a0";;;
    do:  (sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #();;;
    return: (#true, ![uint64T] "txn");;;
    do:  #()).

(* XXX just an atomic read? *)
Definition Log__readLogTxnNxt : val :=
  rec: "Log__readLogTxnNxt" "log" <> :=
    exception_do (let: "log" := ref_ty Log "log" in
    do:  (sync.Mutex__Lock (![ptrT] (struct.field_ref Log "memLock" "log"))) #();;;
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "logTxnNxt" "log")) in
    do:  "n" <-[uint64T] "$a0";;;
    do:  (sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #();;;
    return: (![uint64T] "n");;;
    do:  #()).

Definition Log__diskAppendWait : val :=
  rec: "Log__diskAppendWait" "log" "txn" :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "txn" := ref_ty uint64T "txn" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "logtxn" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := (Log__readLogTxnNxt (![Log] "log")) #() in
      do:  "logtxn" <-[uint64T] "$a0";;;
      (if: (![uint64T] "txn") < (![uint64T] "logtxn")
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      continue: #();;;
      do:  #());;;
    do:  #()).

Definition Log__Append : val :=
  rec: "Log__Append" "log" "l" :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "l" := ref_ty (sliceT (sliceT byteT)) "l" in
    let: "txn" := ref_ty uint64T (zero_val uint64T) in
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: ("$a0", "$a1") := (Log__memAppend (![Log] "log")) (![sliceT (sliceT byteT)] "l") in
    do:  "txn" <-[uint64T] "$a1";;;
    do:  "ok" <-[boolT] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  (Log__diskAppendWait (![Log] "log")) (![uint64T] "txn");;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition Log__writeBlocks : val :=
  rec: "Log__writeBlocks" "log" "l" "pos" :=
    exception_do (let: "log" := ref_ty Log "log" in
    let: "pos" := ref_ty uint64T "pos" in
    let: "l" := ref_ty (sliceT (sliceT byteT)) "l" in
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := slice.len (![sliceT (sliceT byteT)] "l") in
    do:  "n" <-[uint64T] "$a0";;;
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "n")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "bk" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
      let: "$a0" := ![sliceT byteT] (slice.elem_ref (sliceT byteT) (![sliceT (sliceT byteT)] "l") (![uint64T] "i")) in
      do:  "bk" <-[sliceT byteT] "$a0";;;
      do:  disk.Write ((![uint64T] "pos") + (![uint64T] "i")) (![sliceT byteT] "bk");;;
      do:  #()));;;
    do:  #()).

Definition Log__diskAppend : val :=
  rec: "Log__diskAppend" "log" <> :=
    exception_do (let: "log" := ref_ty Log "log" in
    do:  (sync.Mutex__Lock (![ptrT] (struct.field_ref Log "logLock" "log"))) #();;;
    let: "disklen" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := (Log__readHdr (![Log] "log")) #() in
    do:  "disklen" <-[uint64T] "$a0";;;
    do:  (sync.Mutex__Lock (![ptrT] (struct.field_ref Log "memLock" "log"))) #();;;
    let: "memlen" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "memLen" "log")) in
    do:  "memlen" <-[uint64T] "$a0";;;
    let: "allblks" := ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT))) in
    let: "$a0" := ![sliceT (sliceT byteT)] (![ptrT] (struct.field_ref Log "memLog" "log")) in
    do:  "allblks" <-[sliceT (sliceT byteT)] "$a0";;;
    let: "blks" := ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT))) in
    let: "$a0" := let: "$s" := ![sliceT (sliceT byteT)] "allblks" in
    slice.slice (sliceT byteT) "$s" (![uint64T] "disklen") (slice.len "$s") in
    do:  "blks" <-[sliceT (sliceT byteT)] "$a0";;;
    let: "memnxt" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "memTxnNxt" "log")) in
    do:  "memnxt" <-[uint64T] "$a0";;;
    do:  (sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #();;;
    do:  (Log__writeBlocks (![Log] "log")) (![sliceT (sliceT byteT)] "blks") (![uint64T] "disklen");;;
    do:  (Log__writeHdr (![Log] "log")) (![uint64T] "memlen");;;
    let: "$a0" := ![uint64T] "memnxt" in
    do:  (![ptrT] (struct.field_ref Log "logTxnNxt" "log")) <-[uint64T] "$a0";;;
    do:  (sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "logLock" "log"))) #();;;
    do:  #()).

Definition Log__Logger : val :=
  rec: "Log__Logger" "log" <> :=
    exception_do (let: "log" := ref_ty Log "log" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  (Log__diskAppend (![Log] "log")) #();;;
      do:  #());;;
    do:  #()).

(* txn.go *)

Definition Txn : go_type := structT [
  "log" :: ptrT;
  "blks" :: mapT uint64T (sliceT byteT)
].

(* XXX wait if cannot reserve space in log *)
Definition Begin : val :=
  rec: "Begin" "log" :=
    exception_do (let: "log" := ref_ty ptrT "log" in
    let: "txn" := ref_ty Txn (zero_val Txn) in
    let: "$a0" := struct.make Txn [{
      "log" ::= ![ptrT] "log";
      "blks" ::= map.make uint64T (sliceT byteT) #()
    }] in
    do:  "txn" <-[Txn] "$a0";;;
    return: (![Txn] "txn");;;
    do:  #()).

Definition Txn__Write : val :=
  rec: "Txn__Write" "txn" "addr" "blk" :=
    exception_do (let: "txn" := ref_ty Txn "txn" in
    let: "blk" := ref_ty ptrT "blk" in
    let: "addr" := ref_ty uint64T "addr" in
    let: "ret" := ref_ty boolT #true in
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: <> := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: ("$a0", "$a1") := Fst (map.get (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "$a0";;;
    (if: ![boolT] "ok"
    then
      let: "$a0" := ![sliceT byteT] (![ptrT] "blk") in
      do:  map.insert (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr") "$a0";;;
      do:  #()
    else do:  #());;;
    (if: (~ (![boolT] "ok"))
    then
      (if: (![uint64T] "addr") = LOGMAXBLK
      then
        let: "$a0" := #false in
        do:  "ret" <-[boolT] "$a0";;;
        do:  #()
      else
        let: "$a0" := ![sliceT byteT] (![ptrT] "blk") in
        do:  map.insert (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr") "$a0";;;
        do:  #());;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ret");;;
    do:  #()).

Definition Txn__Read : val :=
  rec: "Txn__Read" "txn" "addr" :=
    exception_do (let: "txn" := ref_ty Txn "txn" in
    let: "addr" := ref_ty uint64T "addr" in
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "v" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: ("$a0", "$a1") := Fst (map.get (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v" <-[sliceT byteT] "$a0";;;
    (if: ![boolT] "ok"
    then
      return: (![sliceT byteT] "v");;;
      do:  #()
    else
      return: (disk.Read ((![uint64T] "addr") + LOGEND));;;
      do:  #());;;
    do:  #()).

Definition Txn__Commit : val :=
  rec: "Txn__Commit" "txn" <> :=
    exception_do (let: "txn" := ref_ty Txn "txn" in
    let: "blks" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT))) in
    do:  "blks" <-[ptrT] "$a0";;;
    do:  MapIter (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (λ: <> "v",
      let: "$a0" := slice.append (sliceT byteT) (![sliceT (sliceT byteT)] (![ptrT] "blks")) (slice.literal (sliceT byteT) [![sliceT byteT] "v"]) in
      do:  (![ptrT] "blks") <-[sliceT (sliceT byteT)] "$a0";;;
      do:  #());;;
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "$a0" := (Log__Append (![Log] (![ptrT] (struct.field_ref Txn "log" "txn")))) (![sliceT (sliceT byteT)] (![ptrT] "blks")) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).
