(* autogenerated from github.com/goose-lang/goose/testdata/examples/logging2 *)
From New.golang Require Import defn.
From New.code Require github_com.goose_lang.primitive.
From New.code Require github_com.goose_lang.primitive.disk.
From New.code Require sync.

From New Require Import disk_prelude.

Definition LOGCOMMIT : expr := #(W64 0).

Definition LOGSTART : expr := #(W64 1).

Definition LOGMAXBLK : expr := #(W64 510).

Definition LOGEND : expr := LOGMAXBLK + LOGSTART.

Definition Log : go_type := structT [
  "logLock" :: ptrT;
  "memLock" :: ptrT;
  "logSz" :: uint64T;
  "memLog" :: ptrT;
  "memLen" :: ptrT;
  "memTxnNxt" :: ptrT;
  "logTxnNxt" :: ptrT
].

(* XXX just an atomic read?

   go: logging2.go:90:16 *)
Definition Log__readLogTxnNxt : val :=
  rec: "Log__readLogTxnNxt" "log" <> :=
    exception_do (let: "log" := (ref_ty Log "log") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Log "memLock" "log"))) #());;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "logTxnNxt" "log"))) in
    do:  ("n" <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #());;;
    return: (![uint64T] "n")).

(* go: logging2.go:97:16 *)
Definition Log__diskAppendWait : val :=
  rec: "Log__diskAppendWait" "log" "txn" :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "txn" := (ref_ty uint64T "txn") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "logtxn" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := ((Log__readLogTxnNxt (![Log] "log")) #()) in
      do:  ("logtxn" <-[uint64T] "$r0");;;
      (if: (![uint64T] "txn") < (![uint64T] "logtxn")
      then break: #()
      else do:  #());;;
      continue: #())).

(* go: logging2.go:75:16 *)
Definition Log__memAppend : val :=
  rec: "Log__memAppend" "log" "l" :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "l" := (ref_ty (sliceT (sliceT byteT)) "l") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Log "memLock" "log"))) #());;;
    (if: ((![uint64T] (![ptrT] (struct.field_ref Log "memLen" "log"))) + (let: "$a0" := (![sliceT (sliceT byteT)] "l") in
    slice.len "$a0")) ≥ (![uint64T] (struct.field_ref Log "logSz" "log"))
    then
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #());;;
      return: (#false, #(W64 0))
    else do:  #());;;
    let: "txn" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "memTxnNxt" "log"))) in
    do:  ("txn" <-[uint64T] "$r0");;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (![ptrT] (struct.field_ref Log "memLen" "log"))) + (let: "$a0" := (![sliceT (sliceT byteT)] "l") in
    slice.len "$a0")) in
    do:  ("n" <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] "n") in
    do:  ((![ptrT] (struct.field_ref Log "memLen" "log")) <-[uint64T] "$r0");;;
    let: "$r0" := ((![uint64T] (![ptrT] (struct.field_ref Log "memTxnNxt" "log"))) + #(W64 1)) in
    do:  ((![ptrT] (struct.field_ref Log "memTxnNxt" "log")) <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #());;;
    return: (#true, ![uint64T] "txn")).

(* go: logging2.go:107:16 *)
Definition Log__Append : val :=
  rec: "Log__Append" "log" "l" :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "l" := (ref_ty (sliceT (sliceT byteT)) "l") in
    let: "txn" := (ref_ty uint64T (zero_val uint64T)) in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT (sliceT byteT)] "l") in
    (Log__memAppend (![Log] "log")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  ("txn" <-[uint64T] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  (let: "$a0" := (![uint64T] "txn") in
      (Log__diskAppendWait (![Log] "log")) "$a0")
    else do:  #());;;
    return: (![boolT] "ok")).

(* go: logging2.go:25:16 *)
Definition Log__writeHdr : val :=
  rec: "Log__writeHdr" "log" "len" :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "len" := (ref_ty uint64T "len") in
    let: "hdr" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (slice.make2 byteT #(W64 4096)) in
    do:  ("hdr" <-[sliceT byteT] "$r0");;;
    do:  (let: "$a0" := (![sliceT byteT] "hdr") in
    let: "$a1" := (![uint64T] "len") in
    primitive.UInt64Put "$a0" "$a1");;;
    do:  (let: "$a0" := LOGCOMMIT in
    let: "$a1" := (![sliceT byteT] "hdr") in
    disk.Write "$a0" "$a1")).

(* go: logging2.go:115:16 *)
Definition Log__writeBlocks : val :=
  rec: "Log__writeBlocks" "log" "l" "pos" :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "pos" := (ref_ty uint64T "pos") in
    let: "l" := (ref_ty (sliceT (sliceT byteT)) "l") in
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT (sliceT byteT)] "l") in
    slice.len "$a0") in
    do:  ("n" <-[uint64T] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "n")); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "bk" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
      let: "$r0" := (![sliceT byteT] (slice.elem_ref (sliceT byteT) (![sliceT (sliceT byteT)] "l") (![uint64T] "i"))) in
      do:  ("bk" <-[sliceT byteT] "$r0");;;
      do:  (let: "$a0" := ((![uint64T] "pos") + (![uint64T] "i")) in
      let: "$a1" := (![sliceT byteT] "bk") in
      disk.Write "$a0" "$a1")))).

(* go: logging2.go:45:16 *)
Definition Log__readHdr : val :=
  rec: "Log__readHdr" "log" <> :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "hdr" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (let: "$a0" := LOGCOMMIT in
    disk.Read "$a0") in
    do:  ("hdr" <-[sliceT byteT] "$r0");;;
    let: "disklen" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "hdr") in
    primitive.UInt64Get "$a0") in
    do:  ("disklen" <-[uint64T] "$r0");;;
    return: (![uint64T] "disklen")).

(* go: logging2.go:123:16 *)
Definition Log__diskAppend : val :=
  rec: "Log__diskAppend" "log" <> :=
    exception_do (let: "log" := (ref_ty Log "log") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Log "logLock" "log"))) #());;;
    let: "disklen" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((Log__readHdr (![Log] "log")) #()) in
    do:  ("disklen" <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Log "memLock" "log"))) #());;;
    let: "memlen" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "memLen" "log"))) in
    do:  ("memlen" <-[uint64T] "$r0");;;
    let: "allblks" := (ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT)))) in
    let: "$r0" := (![sliceT (sliceT byteT)] (![ptrT] (struct.field_ref Log "memLog" "log"))) in
    do:  ("allblks" <-[sliceT (sliceT byteT)] "$r0");;;
    let: "blks" := (ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT)))) in
    let: "$r0" := (let: "$s" := (![sliceT (sliceT byteT)] "allblks") in
    slice.slice (sliceT byteT) "$s" (![uint64T] "disklen") (slice.len "$s")) in
    do:  ("blks" <-[sliceT (sliceT byteT)] "$r0");;;
    let: "memnxt" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "memTxnNxt" "log"))) in
    do:  ("memnxt" <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "memLock" "log"))) #());;;
    do:  (let: "$a0" := (![sliceT (sliceT byteT)] "blks") in
    let: "$a1" := (![uint64T] "disklen") in
    (Log__writeBlocks (![Log] "log")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![uint64T] "memlen") in
    (Log__writeHdr (![Log] "log")) "$a0");;;
    let: "$r0" := (![uint64T] "memnxt") in
    do:  ((![ptrT] (struct.field_ref Log "logTxnNxt" "log")) <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "logLock" "log"))) #())).

(* go: logging2.go:142:16 *)
Definition Log__Logger : val :=
  rec: "Log__Logger" "log" <> :=
    exception_do (let: "log" := (ref_ty Log "log") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((Log__diskAppend (![Log] "log")) #()))).

(* go: logging2.go:51:16 *)
Definition Log__readBlocks : val :=
  rec: "Log__readBlocks" "log" "len" :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "len" := (ref_ty uint64T "len") in
    let: "blks" := (ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT)))) in
    let: "$r0" := (slice.make2 (sliceT byteT) #(W64 0)) in
    do:  ("blks" <-[sliceT (sliceT byteT)] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "len")); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "blk" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
      let: "$r0" := (let: "$a0" := (LOGSTART + (![uint64T] "i")) in
      disk.Read "$a0") in
      do:  ("blk" <-[sliceT byteT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![sliceT (sliceT byteT)] "blks") in
      let: "$a1" := ((let: "$sl0" := (![sliceT byteT] "blk") in
      slice.literal (sliceT byteT) ["$sl0"])) in
      (slice.append (sliceT (sliceT byteT))) "$a0" "$a1") in
      do:  ("blks" <-[sliceT (sliceT byteT)] "$r0")));;;
    return: (![sliceT (sliceT byteT)] "blks")).

(* go: logging2.go:60:16 *)
Definition Log__Read : val :=
  rec: "Log__Read" "log" <> :=
    exception_do (let: "log" := (ref_ty Log "log") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Log "logLock" "log"))) #());;;
    let: "disklen" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((Log__readHdr (![Log] "log")) #()) in
    do:  ("disklen" <-[uint64T] "$r0");;;
    let: "blks" := (ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT)))) in
    let: "$r0" := (let: "$a0" := (![uint64T] "disklen") in
    (Log__readBlocks (![Log] "log")) "$a0") in
    do:  ("blks" <-[sliceT (sliceT byteT)] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "logLock" "log"))) #());;;
    return: (![sliceT (sliceT byteT)] "blks")).

(* go: logging2.go:68:16 *)
Definition Log__memWrite : val :=
  rec: "Log__memWrite" "log" "l" :=
    exception_do (let: "log" := (ref_ty Log "log") in
    let: "l" := (ref_ty (sliceT (sliceT byteT)) "l") in
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT (sliceT byteT)] "l") in
    slice.len "$a0") in
    do:  ("n" <-[uint64T] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "n")); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$a0" := (![sliceT (sliceT byteT)] (![ptrT] (struct.field_ref Log "memLog" "log"))) in
      let: "$a1" := ((let: "$sl0" := (![sliceT byteT] (slice.elem_ref (sliceT byteT) (![sliceT (sliceT byteT)] "l") (![uint64T] "i"))) in
      slice.literal (sliceT byteT) ["$sl0"])) in
      (slice.append (sliceT (sliceT byteT))) "$a0" "$a1") in
      do:  ((![ptrT] (struct.field_ref Log "memLog" "log")) <-[sliceT (sliceT byteT)] "$r0")))).

Definition Log__mset : list (string * val) := [
  ("Append", Log__Append%V);
  ("Logger", Log__Logger%V);
  ("Read", Log__Read%V);
  ("diskAppend", Log__diskAppend%V);
  ("diskAppendWait", Log__diskAppendWait%V);
  ("memAppend", Log__memAppend%V);
  ("memWrite", Log__memWrite%V);
  ("readBlocks", Log__readBlocks%V);
  ("readHdr", Log__readHdr%V);
  ("readLogTxnNxt", Log__readLogTxnNxt%V);
  ("writeBlocks", Log__writeBlocks%V);
  ("writeHdr", Log__writeHdr%V)
].

Definition Log__mset_ptr : list (string * val) := [
  ("Append", (λ: "$recvAddr",
    Log__Append (![Log] "$recvAddr")
    )%V);
  ("Logger", (λ: "$recvAddr",
    Log__Logger (![Log] "$recvAddr")
    )%V);
  ("Read", (λ: "$recvAddr",
    Log__Read (![Log] "$recvAddr")
    )%V);
  ("diskAppend", (λ: "$recvAddr",
    Log__diskAppend (![Log] "$recvAddr")
    )%V);
  ("diskAppendWait", (λ: "$recvAddr",
    Log__diskAppendWait (![Log] "$recvAddr")
    )%V);
  ("memAppend", (λ: "$recvAddr",
    Log__memAppend (![Log] "$recvAddr")
    )%V);
  ("memWrite", (λ: "$recvAddr",
    Log__memWrite (![Log] "$recvAddr")
    )%V);
  ("readBlocks", (λ: "$recvAddr",
    Log__readBlocks (![Log] "$recvAddr")
    )%V);
  ("readHdr", (λ: "$recvAddr",
    Log__readHdr (![Log] "$recvAddr")
    )%V);
  ("readLogTxnNxt", (λ: "$recvAddr",
    Log__readLogTxnNxt (![Log] "$recvAddr")
    )%V);
  ("writeBlocks", (λ: "$recvAddr",
    Log__writeBlocks (![Log] "$recvAddr")
    )%V);
  ("writeHdr", (λ: "$recvAddr",
    Log__writeHdr (![Log] "$recvAddr")
    )%V)
].

(* go: logging2.go:31:6 *)
Definition Init : val :=
  rec: "Init" "logSz" :=
    exception_do (let: "logSz" := (ref_ty uint64T "logSz") in
    let: "log" := (ref_ty Log (zero_val Log)) in
    let: "$r0" := (struct.make Log [{
      "logLock" ::= ref_ty sync.Mutex (zero_val sync.Mutex);
      "memLock" ::= ref_ty sync.Mutex (zero_val sync.Mutex);
      "logSz" ::= ![uint64T] "logSz";
      "memLog" ::= ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT)));
      "memLen" ::= ref_ty uint64T (zero_val uint64T);
      "memTxnNxt" ::= ref_ty uint64T (zero_val uint64T);
      "logTxnNxt" ::= ref_ty uint64T (zero_val uint64T)
    }]) in
    do:  ("log" <-[Log] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    (Log__writeHdr (![Log] "log")) "$a0");;;
    return: (![Log] "log")).

Definition Txn : go_type := structT [
  "log" :: ptrT;
  "blks" :: mapT uint64T (sliceT byteT)
].

(* go: txn.go:47:16 *)
Definition Txn__Commit : val :=
  rec: "Txn__Commit" "txn" <> :=
    exception_do (let: "txn" := (ref_ty Txn "txn") in
    let: "blks" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT)))) in
    do:  ("blks" <-[ptrT] "$r0");;;
    do:  (map.for_range (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (λ: <> "v",
      let: "$r0" := (let: "$a0" := (![sliceT (sliceT byteT)] (![ptrT] "blks")) in
      let: "$a1" := ((let: "$sl0" := (![sliceT byteT] "v") in
      slice.literal (sliceT byteT) ["$sl0"])) in
      (slice.append (sliceT (sliceT byteT))) "$a0" "$a1") in
      do:  ((![ptrT] "blks") <-[sliceT (sliceT byteT)] "$r0")));;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := (let: "$a0" := (![sliceT (sliceT byteT)] (![ptrT] "blks")) in
    (Log__Append (![Log] (![ptrT] (struct.field_ref Txn "log" "txn")))) "$a0") in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: txn.go:38:16 *)
Definition Txn__Read : val :=
  rec: "Txn__Read" "txn" "addr" :=
    exception_do (let: "txn" := (ref_ty Txn "txn") in
    let: "addr" := (ref_ty uint64T "addr") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "v" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[sliceT byteT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![sliceT byteT] "v")
    else
      return: (let: "$a0" := ((![uint64T] "addr") + LOGEND) in
       disk.Read "$a0"))).

(* go: txn.go:21:16 *)
Definition Txn__Write : val :=
  rec: "Txn__Write" "txn" "addr" "blk" :=
    exception_do (let: "txn" := (ref_ty Txn "txn") in
    let: "blk" := (ref_ty ptrT "blk") in
    let: "addr" := (ref_ty uint64T "addr") in
    let: "ret" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ret" <-[boolT] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      let: "$r0" := (![sliceT byteT] (![ptrT] "blk")) in
      do:  (map.insert (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr") "$r0")
    else do:  #());;;
    (if: (~ (![boolT] "ok"))
    then
      (if: (![uint64T] "addr") = LOGMAXBLK
      then
        let: "$r0" := #false in
        do:  ("ret" <-[boolT] "$r0")
      else
        let: "$r0" := (![sliceT byteT] (![ptrT] "blk")) in
        do:  (map.insert (![mapT uint64T (sliceT byteT)] (struct.field_ref Txn "blks" "txn")) (![uint64T] "addr") "$r0"))
    else do:  #());;;
    return: (![boolT] "ret")).

Definition Txn__mset : list (string * val) := [
  ("Commit", Txn__Commit%V);
  ("Read", Txn__Read%V);
  ("Write", Txn__Write%V)
].

Definition Txn__mset_ptr : list (string * val) := [
  ("Commit", (λ: "$recvAddr",
    Txn__Commit (![Txn] "$recvAddr")
    )%V);
  ("Read", (λ: "$recvAddr",
    Txn__Read (![Txn] "$recvAddr")
    )%V);
  ("Write", (λ: "$recvAddr",
    Txn__Write (![Txn] "$recvAddr")
    )%V)
].

(* XXX wait if cannot reserve space in log

   go: txn.go:13:6 *)
Definition Begin : val :=
  rec: "Begin" "log" :=
    exception_do (let: "log" := (ref_ty ptrT "log") in
    let: "txn" := (ref_ty Txn (zero_val Txn)) in
    let: "$r0" := (struct.make Txn [{
      "log" ::= ![ptrT] "log";
      "blks" ::= map.make uint64T (sliceT byteT) #()
    }]) in
    do:  ("txn" <-[Txn] "$r0");;;
    return: (![Txn] "txn")).
