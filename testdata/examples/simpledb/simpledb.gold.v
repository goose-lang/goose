(* autogenerated from github.com/goose-lang/goose/testdata/examples/simpledb *)
From New.golang Require Import defn.
From New.code Require github_com.goose_lang.primitive.
From New.code Require github_com.goose_lang.primitive.filesys.
From New.code Require github_com.tchajed.marshal.
From New.code Require sync.

Section code.
Context `{ffi_syntax}.

(* go: simpledb.go:20:6 *)
Definition UseMarshal : val :=
  rec: "UseMarshal" <> :=
    exception_do (do:  (let: "$a0" := #(W64 0) in
    marshal.NewEnc "$a0")).

Definition Table : go_type := structT [
  "Index" :: mapT uint64T uint64T;
  "File" :: fileT
].

Definition Table__mset : list (go_string * val) := [
].

Definition Table__mset_ptr : list (go_string * val) := [
].

(* CreateTable creates a new, empty table.

   go: simpledb.go:32:6 *)
Definition CreateTable : val :=
  rec: "CreateTable" "p" :=
    exception_do (let: "p" := (ref_ty stringT "p") in
    let: "index" := (ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T))) in
    let: "$r0" := (map.make uint64T uint64T #()) in
    do:  ("index" <-[mapT uint64T uint64T] "$r0");;;
    let: "f" := (ref_ty fileT (zero_val fileT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := #"db"%go in
    let: "$a1" := (![stringT] "p") in
    filesys.Create "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("f" <-[fileT] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![fileT] "f") in
    filesys.Close "$a0");;;
    let: "f2" := (ref_ty fileT (zero_val fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := (![stringT] "p") in
    filesys.Open "$a0" "$a1") in
    do:  ("f2" <-[fileT] "$r0");;;
    return: (let: "$Index" := (![mapT uint64T uint64T] "index") in
     let: "$File" := (![fileT] "f2") in
     struct.make Table [{
       "Index" ::= "$Index";
       "File" ::= "$File"
     }])).

Definition Entry : go_type := structT [
  "Key" :: uint64T;
  "Value" :: sliceT
].

Definition Entry__mset : list (go_string * val) := [
].

Definition Entry__mset_ptr : list (go_string * val) := [
].

(* DecodeUInt64 is a Decoder(uint64)

   All decoders have the shape func(p []byte) (T, uint64)

   The uint64 represents the number of bytes consumed; if 0,
   then decoding failed, and the value of type T should be ignored.

   go: simpledb.go:52:6 *)
Definition DecodeUInt64 : val :=
  rec: "DecodeUInt64" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    (if: int_lt (let: "$a0" := (![sliceT] "p") in
    slice.len "$a0") #(W64 8)
    then return: (#(W64 0), #(W64 0))
    else do:  #());;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "p") in
    primitive.UInt64Get "$a0") in
    do:  ("n" <-[uint64T] "$r0");;;
    return: (![uint64T] "n", #(W64 8))).

(* DecodeEntry is a Decoder(Entry)

   go: simpledb.go:61:6 *)
Definition DecodeEntry : val :=
  rec: "DecodeEntry" "data" :=
    exception_do (let: "data" := (ref_ty sliceT "data") in
    let: "l1" := (ref_ty uint64T (zero_val uint64T)) in
    let: "key" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "data") in
    DecodeUInt64 "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("key" <-[uint64T] "$r0");;;
    do:  ("l1" <-[uint64T] "$r1");;;
    (if: (![uint64T] "l1") = #(W64 0)
    then
      return: (let: "$Key" := #(W64 0) in
       let: "$Value" := #slice.nil in
       struct.make Entry [{
         "Key" ::= "$Key";
         "Value" ::= "$Value"
       }], #(W64 0))
    else do:  #());;;
    let: "l2" := (ref_ty uint64T (zero_val uint64T)) in
    let: "valueLen" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (let: "$s" := (![sliceT] "data") in
    slice.slice byteT "$s" (![uint64T] "l1") (slice.len "$s")) in
    DecodeUInt64 "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("valueLen" <-[uint64T] "$r0");;;
    do:  ("l2" <-[uint64T] "$r1");;;
    (if: (![uint64T] "l2") = #(W64 0)
    then
      return: (let: "$Key" := #(W64 0) in
       let: "$Value" := #slice.nil in
       struct.make Entry [{
         "Key" ::= "$Key";
         "Value" ::= "$Value"
       }], #(W64 0))
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] "data") in
    slice.len "$a0") < (((![uint64T] "l1") + (![uint64T] "l2")) + (![uint64T] "valueLen"))
    then
      return: (let: "$Key" := #(W64 0) in
       let: "$Value" := #slice.nil in
       struct.make Entry [{
         "Key" ::= "$Key";
         "Value" ::= "$Value"
       }], #(W64 0))
    else do:  #());;;
    let: "value" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "data") in
    slice.slice byteT "$s" ((![uint64T] "l1") + (![uint64T] "l2")) (((![uint64T] "l1") + (![uint64T] "l2")) + (![uint64T] "valueLen"))) in
    do:  ("value" <-[sliceT] "$r0");;;
    return: (let: "$Key" := (![uint64T] "key") in
     let: "$Value" := (![sliceT] "value") in
     struct.make Entry [{
       "Key" ::= "$Key";
       "Value" ::= "$Value"
     }], ((![uint64T] "l1") + (![uint64T] "l2")) + (![uint64T] "valueLen"))).

Definition lazyFileBuf : go_type := structT [
  "offset" :: uint64T;
  "next" :: sliceT
].

Definition lazyFileBuf__mset : list (go_string * val) := [
].

Definition lazyFileBuf__mset_ptr : list (go_string * val) := [
].

(* readTableIndex parses a complete table on disk into a key->offset index

   go: simpledb.go:86:6 *)
Definition readTableIndex : val :=
  rec: "readTableIndex" "f" "index" :=
    exception_do (let: "index" := (ref_ty (mapT uint64T uint64T) "index") in
    let: "f" := (ref_ty fileT "f") in
    (let: "buf" := (ref_ty lazyFileBuf (zero_val lazyFileBuf)) in
    let: "$r0" := (let: "$offset" := #(W64 0) in
    let: "$next" := #slice.nil in
    struct.make lazyFileBuf [{
      "offset" ::= "$offset";
      "next" ::= "$next"
    }]) in
    do:  ("buf" <-[lazyFileBuf] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "l" := (ref_ty uint64T (zero_val uint64T)) in
      let: "e" := (ref_ty Entry (zero_val Entry)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
      DecodeEntry "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[Entry] "$r0");;;
      do:  ("l" <-[uint64T] "$r1");;;
      (if: (![uint64T] "l") > #(W64 0)
      then
        let: "$r0" := (#(W64 8) + (![uint64T] (struct.field_ref lazyFileBuf "offset" "buf"))) in
        do:  (map.insert (![mapT uint64T uint64T] "index") (![uint64T] (struct.field_ref Entry "Key" "e")) "$r0");;;
        let: "$r0" := (let: "$offset" := ((![uint64T] (struct.field_ref lazyFileBuf "offset" "buf")) + (![uint64T] "l")) in
        let: "$next" := (let: "$s" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
        slice.slice byteT "$s" (![uint64T] "l") (slice.len "$s")) in
        struct.make lazyFileBuf [{
          "offset" ::= "$offset";
          "next" ::= "$next"
        }]) in
        do:  ("buf" <-[lazyFileBuf] "$r0");;;
        continue: #()
      else
        let: "p" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (let: "$a0" := (![fileT] "f") in
        let: "$a1" := ((![uint64T] (struct.field_ref lazyFileBuf "offset" "buf")) + (let: "$a0" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
        slice.len "$a0")) in
        let: "$a2" := #(W64 4096) in
        filesys.ReadAt "$a0" "$a1" "$a2") in
        do:  ("p" <-[sliceT] "$r0");;;
        (if: (let: "$a0" := (![sliceT] "p") in
        slice.len "$a0") = #(W64 0)
        then break: #()
        else
          let: "newBuf" := (ref_ty sliceT (zero_val sliceT)) in
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
          let: "$a1" := (![sliceT] "p") in
          (slice.append sliceT) "$a0" "$a1") in
          do:  ("newBuf" <-[sliceT] "$r0");;;
          let: "$r0" := (let: "$offset" := (![uint64T] (struct.field_ref lazyFileBuf "offset" "buf")) in
          let: "$next" := (![sliceT] "newBuf") in
          struct.make lazyFileBuf [{
            "offset" ::= "$offset";
            "next" ::= "$next"
          }]) in
          do:  ("buf" <-[lazyFileBuf] "$r0");;;
          continue: #()))))).

(* RecoverTable restores a table from disk on startup.

   go: simpledb.go:111:6 *)
Definition RecoverTable : val :=
  rec: "RecoverTable" "p" :=
    exception_do (let: "p" := (ref_ty stringT "p") in
    let: "index" := (ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T))) in
    let: "$r0" := (map.make uint64T uint64T #()) in
    do:  ("index" <-[mapT uint64T uint64T] "$r0");;;
    let: "f" := (ref_ty fileT (zero_val fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := (![stringT] "p") in
    filesys.Open "$a0" "$a1") in
    do:  ("f" <-[fileT] "$r0");;;
    do:  (let: "$a0" := (![fileT] "f") in
    let: "$a1" := (![mapT uint64T uint64T] "index") in
    readTableIndex "$a0" "$a1");;;
    return: (let: "$Index" := (![mapT uint64T uint64T] "index") in
     let: "$File" := (![fileT] "f") in
     struct.make Table [{
       "Index" ::= "$Index";
       "File" ::= "$File"
     }])).

(* CloseTable frees up the fd held by a table.

   go: simpledb.go:119:6 *)
Definition CloseTable : val :=
  rec: "CloseTable" "t" :=
    exception_do (let: "t" := (ref_ty Table "t") in
    do:  (let: "$a0" := (![fileT] (struct.field_ref Table "File" "t")) in
    filesys.Close "$a0")).

(* go: simpledb.go:123:6 *)
Definition readValue : val :=
  rec: "readValue" "f" "off" :=
    exception_do (let: "off" := (ref_ty uint64T "off") in
    let: "f" := (ref_ty fileT "f") in
    let: "startBuf" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![fileT] "f") in
    let: "$a1" := (![uint64T] "off") in
    let: "$a2" := #(W64 512) in
    filesys.ReadAt "$a0" "$a1" "$a2") in
    do:  ("startBuf" <-[sliceT] "$r0");;;
    let: "totalBytes" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "startBuf") in
    primitive.UInt64Get "$a0") in
    do:  ("totalBytes" <-[uint64T] "$r0");;;
    let: "buf" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "startBuf") in
    slice.slice byteT "$s" #(W64 8) (slice.len "$s")) in
    do:  ("buf" <-[sliceT] "$r0");;;
    let: "haveBytes" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "buf") in
    slice.len "$a0") in
    do:  ("haveBytes" <-[uint64T] "$r0");;;
    (if: (![uint64T] "haveBytes") < (![uint64T] "totalBytes")
    then
      let: "buf2" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (let: "$a0" := (![fileT] "f") in
      let: "$a1" := ((![uint64T] "off") + #(W64 512)) in
      let: "$a2" := ((![uint64T] "totalBytes") - (![uint64T] "haveBytes")) in
      filesys.ReadAt "$a0" "$a1" "$a2") in
      do:  ("buf2" <-[sliceT] "$r0");;;
      let: "newBuf" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "buf") in
      let: "$a1" := (![sliceT] "buf2") in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("newBuf" <-[sliceT] "$r0");;;
      return: (![sliceT] "newBuf")
    else do:  #());;;
    return: (let: "$s" := (![sliceT] "buf") in
     slice.slice byteT "$s" #(W64 0) (![uint64T] "totalBytes"))).

(* go: simpledb.go:137:6 *)
Definition tableRead : val :=
  rec: "tableRead" "t" "k" :=
    exception_do (let: "k" := (ref_ty uint64T "k") in
    let: "t" := (ref_ty Table "t") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "off" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T uint64T] (struct.field_ref Table "Index" "t")) (![uint64T] "k")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("off" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (#slice.nil, #false)
    else do:  #());;;
    let: "p" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![fileT] (struct.field_ref Table "File" "t")) in
    let: "$a1" := (![uint64T] "off") in
    readValue "$a0" "$a1") in
    do:  ("p" <-[sliceT] "$r0");;;
    return: (![sliceT] "p", #true)).

Definition bufFile : go_type := structT [
  "file" :: fileT;
  "buf" :: ptrT
].

Definition bufFile__mset : list (go_string * val) := [
].

Definition bufFile__mset_ptr : list (go_string * val) := [
].

(* go: simpledb.go:151:6 *)
Definition newBuf : val :=
  rec: "newBuf" "f" :=
    exception_do (let: "f" := (ref_ty fileT "f") in
    let: "buf" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sliceT (zero_val sliceT)) in
    do:  ("buf" <-[ptrT] "$r0");;;
    return: (let: "$file" := (![fileT] "f") in
     let: "$buf" := (![ptrT] "buf") in
     struct.make bufFile [{
       "file" ::= "$file";
       "buf" ::= "$buf"
     }])).

(* go: simpledb.go:159:6 *)
Definition bufFlush : val :=
  rec: "bufFlush" "f" :=
    exception_do (let: "f" := (ref_ty bufFile "f") in
    let: "buf" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (![ptrT] (struct.field_ref bufFile "buf" "f"))) in
    do:  ("buf" <-[sliceT] "$r0");;;
    (if: (let: "$a0" := (![sliceT] "buf") in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := (![fileT] (struct.field_ref bufFile "file" "f")) in
    let: "$a1" := (![sliceT] "buf") in
    filesys.Append "$a0" "$a1");;;
    let: "$r0" := #slice.nil in
    do:  ((![ptrT] (struct.field_ref bufFile "buf" "f")) <-[sliceT] "$r0")).

(* go: simpledb.go:168:6 *)
Definition bufAppend : val :=
  rec: "bufAppend" "f" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    let: "f" := (ref_ty bufFile "f") in
    let: "buf" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (![ptrT] (struct.field_ref bufFile "buf" "f"))) in
    do:  ("buf" <-[sliceT] "$r0");;;
    let: "buf2" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "buf") in
    let: "$a1" := (![sliceT] "p") in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ("buf2" <-[sliceT] "$r0");;;
    let: "$r0" := (![sliceT] "buf2") in
    do:  ((![ptrT] (struct.field_ref bufFile "buf" "f")) <-[sliceT] "$r0")).

(* go: simpledb.go:174:6 *)
Definition bufClose : val :=
  rec: "bufClose" "f" :=
    exception_do (let: "f" := (ref_ty bufFile "f") in
    do:  (let: "$a0" := (![bufFile] "f") in
    bufFlush "$a0");;;
    do:  (let: "$a0" := (![fileT] (struct.field_ref bufFile "file" "f")) in
    filesys.Close "$a0")).

Definition tableWriter : go_type := structT [
  "index" :: mapT uint64T uint64T;
  "name" :: stringT;
  "file" :: bufFile;
  "offset" :: ptrT
].

Definition tableWriter__mset : list (go_string * val) := [
].

Definition tableWriter__mset_ptr : list (go_string * val) := [
].

(* go: simpledb.go:186:6 *)
Definition newTableWriter : val :=
  rec: "newTableWriter" "p" :=
    exception_do (let: "p" := (ref_ty stringT "p") in
    let: "index" := (ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T))) in
    let: "$r0" := (map.make uint64T uint64T #()) in
    do:  ("index" <-[mapT uint64T uint64T] "$r0");;;
    let: "f" := (ref_ty fileT (zero_val fileT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := #"db"%go in
    let: "$a1" := (![stringT] "p") in
    filesys.Create "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("f" <-[fileT] "$r0");;;
    do:  "$r1";;;
    let: "buf" := (ref_ty bufFile (zero_val bufFile)) in
    let: "$r0" := (let: "$a0" := (![fileT] "f") in
    newBuf "$a0") in
    do:  ("buf" <-[bufFile] "$r0");;;
    let: "off" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("off" <-[ptrT] "$r0");;;
    return: (let: "$index" := (![mapT uint64T uint64T] "index") in
     let: "$name" := (![stringT] "p") in
     let: "$file" := (![bufFile] "buf") in
     let: "$offset" := (![ptrT] "off") in
     struct.make tableWriter [{
       "index" ::= "$index";
       "name" ::= "$name";
       "file" ::= "$file";
       "offset" ::= "$offset"
     }])).

(* go: simpledb.go:199:6 *)
Definition tableWriterAppend : val :=
  rec: "tableWriterAppend" "w" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    let: "w" := (ref_ty tableWriter "w") in
    do:  (let: "$a0" := (![bufFile] (struct.field_ref tableWriter "file" "w")) in
    let: "$a1" := (![sliceT] "p") in
    bufAppend "$a0" "$a1");;;
    let: "off" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref tableWriter "offset" "w"))) in
    do:  ("off" <-[uint64T] "$r0");;;
    let: "$r0" := ((![uint64T] "off") + (let: "$a0" := (![sliceT] "p") in
    slice.len "$a0")) in
    do:  ((![ptrT] (struct.field_ref tableWriter "offset" "w")) <-[uint64T] "$r0")).

(* go: simpledb.go:205:6 *)
Definition tableWriterClose : val :=
  rec: "tableWriterClose" "w" :=
    exception_do (let: "w" := (ref_ty tableWriter "w") in
    do:  (let: "$a0" := (![bufFile] (struct.field_ref tableWriter "file" "w")) in
    bufClose "$a0");;;
    let: "f" := (ref_ty fileT (zero_val fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := (![stringT] (struct.field_ref tableWriter "name" "w")) in
    filesys.Open "$a0" "$a1") in
    do:  ("f" <-[fileT] "$r0");;;
    return: (let: "$Index" := (![mapT uint64T uint64T] (struct.field_ref tableWriter "index" "w")) in
     let: "$File" := (![fileT] "f") in
     struct.make Table [{
       "Index" ::= "$Index";
       "File" ::= "$File"
     }])).

(* EncodeUInt64 is an Encoder(uint64)

   go: simpledb.go:215:6 *)
Definition EncodeUInt64 : val :=
  rec: "EncodeUInt64" "x" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    let: "x" := (ref_ty uint64T "x") in
    let: "tmp" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 8)) in
    do:  ("tmp" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "tmp") in
    let: "$a1" := (![uint64T] "x") in
    primitive.UInt64Put "$a0" "$a1");;;
    let: "p2" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "p") in
    let: "$a1" := (![sliceT] "tmp") in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ("p2" <-[sliceT] "$r0");;;
    return: (![sliceT] "p2")).

(* EncodeSlice is an Encoder([]byte)

   go: simpledb.go:223:6 *)
Definition EncodeSlice : val :=
  rec: "EncodeSlice" "data" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    let: "data" := (ref_ty sliceT "data") in
    let: "p2" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![sliceT] "data") in
    slice.len "$a0") in
    let: "$a1" := (![sliceT] "p") in
    EncodeUInt64 "$a0" "$a1") in
    do:  ("p2" <-[sliceT] "$r0");;;
    let: "p3" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "p2") in
    let: "$a1" := (![sliceT] "data") in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ("p3" <-[sliceT] "$r0");;;
    return: (![sliceT] "p3")).

(* go: simpledb.go:229:6 *)
Definition tablePut : val :=
  rec: "tablePut" "w" "k" "v" :=
    exception_do (let: "v" := (ref_ty sliceT "v") in
    let: "k" := (ref_ty uint64T "k") in
    let: "w" := (ref_ty tableWriter "w") in
    let: "tmp" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 0)) in
    do:  ("tmp" <-[sliceT] "$r0");;;
    let: "tmp2" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "k") in
    let: "$a1" := (![sliceT] "tmp") in
    EncodeUInt64 "$a0" "$a1") in
    do:  ("tmp2" <-[sliceT] "$r0");;;
    let: "tmp3" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "v") in
    let: "$a1" := (![sliceT] "tmp2") in
    EncodeSlice "$a0" "$a1") in
    do:  ("tmp3" <-[sliceT] "$r0");;;
    let: "off" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref tableWriter "offset" "w"))) in
    do:  ("off" <-[uint64T] "$r0");;;
    let: "$r0" := ((![uint64T] "off") + (let: "$a0" := (![sliceT] "tmp2") in
    slice.len "$a0")) in
    do:  (map.insert (![mapT uint64T uint64T] (struct.field_ref tableWriter "index" "w")) (![uint64T] "k") "$r0");;;
    do:  (let: "$a0" := (![tableWriter] "w") in
    let: "$a1" := (![sliceT] "tmp3") in
    tableWriterAppend "$a0" "$a1")).

Definition Database : go_type := structT [
  "wbuffer" :: ptrT;
  "rbuffer" :: ptrT;
  "bufferL" :: ptrT;
  "table" :: ptrT;
  "tableName" :: ptrT;
  "tableL" :: ptrT;
  "compactionL" :: ptrT
].

Definition Database__mset : list (go_string * val) := [
].

Definition Database__mset_ptr : list (go_string * val) := [
].

(* go: simpledb.go:256:6 *)
Definition makeValueBuffer : val :=
  rec: "makeValueBuffer" <> :=
    exception_do (let: "buf" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (map.make uint64T sliceT #()) in
    do:  ("buf" <-[mapT uint64T sliceT] "$r0");;;
    let: "bufPtr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    do:  ("bufPtr" <-[ptrT] "$r0");;;
    let: "$r0" := (![mapT uint64T sliceT] "buf") in
    do:  ((![ptrT] "bufPtr") <-[mapT uint64T sliceT] "$r0");;;
    return: (![ptrT] "bufPtr")).

(* NewDb initializes a new database on top of an empty filesys.

   go: simpledb.go:264:6 *)
Definition NewDb : val :=
  rec: "NewDb" <> :=
    exception_do (let: "wbuf" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (makeValueBuffer #()) in
    do:  ("wbuf" <-[ptrT] "$r0");;;
    let: "rbuf" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (makeValueBuffer #()) in
    do:  ("rbuf" <-[ptrT] "$r0");;;
    let: "bufferL" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("bufferL" <-[ptrT] "$r0");;;
    let: "tableName" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := #"table.0"%go in
    do:  ("tableName" <-[stringT] "$r0");;;
    let: "tableNameRef" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty stringT (zero_val stringT)) in
    do:  ("tableNameRef" <-[ptrT] "$r0");;;
    let: "$r0" := (![stringT] "tableName") in
    do:  ((![ptrT] "tableNameRef") <-[stringT] "$r0");;;
    let: "table" := (ref_ty Table (zero_val Table)) in
    let: "$r0" := (let: "$a0" := (![stringT] "tableName") in
    CreateTable "$a0") in
    do:  ("table" <-[Table] "$r0");;;
    let: "tableRef" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Table (zero_val Table)) in
    do:  ("tableRef" <-[ptrT] "$r0");;;
    let: "$r0" := (![Table] "table") in
    do:  ((![ptrT] "tableRef") <-[Table] "$r0");;;
    let: "tableL" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("tableL" <-[ptrT] "$r0");;;
    let: "compactionL" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("compactionL" <-[ptrT] "$r0");;;
    return: (let: "$wbuffer" := (![ptrT] "wbuf") in
     let: "$rbuffer" := (![ptrT] "rbuf") in
     let: "$bufferL" := (![ptrT] "bufferL") in
     let: "$table" := (![ptrT] "tableRef") in
     let: "$tableName" := (![ptrT] "tableNameRef") in
     let: "$tableL" := (![ptrT] "tableL") in
     let: "$compactionL" := (![ptrT] "compactionL") in
     struct.make Database [{
       "wbuffer" ::= "$wbuffer";
       "rbuffer" ::= "$rbuffer";
       "bufferL" ::= "$bufferL";
       "table" ::= "$table";
       "tableName" ::= "$tableName";
       "tableL" ::= "$tableL";
       "compactionL" ::= "$compactionL"
     }])).

(* Read gets a key from the database.

   Returns a boolean indicating if the k was found and a non-nil slice with
   the value if k was in the database.

   Reflects any completed in-memory writes.

   go: simpledb.go:293:6 *)
Definition Read : val :=
  rec: "Read" "db" "k" :=
    exception_do (let: "k" := (ref_ty uint64T "k") in
    let: "db" := (ref_ty Database "db") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
    let: "buf" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (![mapT uint64T sliceT] (![ptrT] (struct.field_ref Database "wbuffer" "db"))) in
    do:  ("buf" <-[mapT uint64T sliceT] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "v" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T sliceT] "buf") (![uint64T] "k")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[sliceT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
      return: (![sliceT] "v", #true)
    else do:  #());;;
    let: "rbuf" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (![mapT uint64T sliceT] (![ptrT] (struct.field_ref Database "rbuffer" "db"))) in
    do:  ("rbuf" <-[mapT uint64T sliceT] "$r0");;;
    let: "v2" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T sliceT] "rbuf") (![uint64T] "k")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[sliceT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
      return: (![sliceT] "v2", #true)
    else do:  #());;;
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "tableL" "db"))) #());;;
    let: "tbl" := (ref_ty Table (zero_val Table)) in
    let: "$r0" := (![Table] (![ptrT] (struct.field_ref Database "table" "db"))) in
    do:  ("tbl" <-[Table] "$r0");;;
    let: "v3" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![Table] "tbl") in
    let: "$a1" := (![uint64T] "k") in
    tableRead "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v3" <-[sliceT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "tableL" "db"))) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
    return: (![sliceT] "v3", ![boolT] "ok")).

(* Write sets a key to a new value.

   Creates a new key-value mapping if k is not in the database and overwrites
   the previous value if k is present.

   The new value is buffered in memory. To persist it, call db.Compact().

   go: simpledb.go:326:6 *)
Definition Write : val :=
  rec: "Write" "db" "k" "v" :=
    exception_do (let: "v" := (ref_ty sliceT "v") in
    let: "k" := (ref_ty uint64T "k") in
    let: "db" := (ref_ty Database "db") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
    let: "buf" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (![mapT uint64T sliceT] (![ptrT] (struct.field_ref Database "wbuffer" "db"))) in
    do:  ("buf" <-[mapT uint64T sliceT] "$r0");;;
    let: "$r0" := (![sliceT] "v") in
    do:  (map.insert (![mapT uint64T sliceT] "buf") (![uint64T] "k") "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #())).

(* go: simpledb.go:333:6 *)
Definition freshTable : val :=
  rec: "freshTable" "p" :=
    exception_do (let: "p" := (ref_ty stringT "p") in
    (if: (![stringT] "p") = #"table.0"%go
    then return: (#"table.1"%go)
    else do:  #());;;
    (if: (![stringT] "p") = #"table.1"%go
    then return: (#"table.0"%go)
    else do:  #());;;
    return: (![stringT] "p")).

(* go: simpledb.go:345:6 *)
Definition tablePutBuffer : val :=
  rec: "tablePutBuffer" "w" "buf" :=
    exception_do (let: "buf" := (ref_ty (mapT uint64T sliceT) "buf") in
    let: "w" := (ref_ty tableWriter "w") in
    do:  (map.for_range (![mapT uint64T sliceT] "buf") (λ: "k" "v",
      do:  (let: "$a0" := (![tableWriter] "w") in
      let: "$a1" := (![uint64T] "k") in
      let: "$a2" := (![sliceT] "v") in
      tablePut "$a0" "$a1" "$a2")))).

(* add all of table t to the table w being created; skip any keys in the (read)
   buffer b since those writes overwrite old ones

   go: simpledb.go:353:6 *)
Definition tablePutOldTable : val :=
  rec: "tablePutOldTable" "w" "t" "b" :=
    exception_do (let: "b" := (ref_ty (mapT uint64T sliceT) "b") in
    let: "t" := (ref_ty Table "t") in
    let: "w" := (ref_ty tableWriter "w") in
    (let: "buf" := (ref_ty lazyFileBuf (zero_val lazyFileBuf)) in
    let: "$r0" := (let: "$offset" := #(W64 0) in
    let: "$next" := #slice.nil in
    struct.make lazyFileBuf [{
      "offset" ::= "$offset";
      "next" ::= "$next"
    }]) in
    do:  ("buf" <-[lazyFileBuf] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "l" := (ref_ty uint64T (zero_val uint64T)) in
      let: "e" := (ref_ty Entry (zero_val Entry)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
      DecodeEntry "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[Entry] "$r0");;;
      do:  ("l" <-[uint64T] "$r1");;;
      (if: (![uint64T] "l") > #(W64 0)
      then
        let: "ok" := (ref_ty boolT (zero_val boolT)) in
        let: ("$ret0", "$ret1") := (map.get (![mapT uint64T sliceT] "b") (![uint64T] (struct.field_ref Entry "Key" "e"))) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  "$r0";;;
        do:  ("ok" <-[boolT] "$r1");;;
        (if: (~ (![boolT] "ok"))
        then
          do:  (let: "$a0" := (![tableWriter] "w") in
          let: "$a1" := (![uint64T] (struct.field_ref Entry "Key" "e")) in
          let: "$a2" := (![sliceT] (struct.field_ref Entry "Value" "e")) in
          tablePut "$a0" "$a1" "$a2")
        else do:  #());;;
        let: "$r0" := (let: "$offset" := ((![uint64T] (struct.field_ref lazyFileBuf "offset" "buf")) + (![uint64T] "l")) in
        let: "$next" := (let: "$s" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
        slice.slice byteT "$s" (![uint64T] "l") (slice.len "$s")) in
        struct.make lazyFileBuf [{
          "offset" ::= "$offset";
          "next" ::= "$next"
        }]) in
        do:  ("buf" <-[lazyFileBuf] "$r0");;;
        continue: #()
      else
        let: "p" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (let: "$a0" := (![fileT] (struct.field_ref Table "File" "t")) in
        let: "$a1" := ((![uint64T] (struct.field_ref lazyFileBuf "offset" "buf")) + (let: "$a0" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
        slice.len "$a0")) in
        let: "$a2" := #(W64 4096) in
        filesys.ReadAt "$a0" "$a1" "$a2") in
        do:  ("p" <-[sliceT] "$r0");;;
        (if: (let: "$a0" := (![sliceT] "p") in
        slice.len "$a0") = #(W64 0)
        then break: #()
        else
          let: "newBuf" := (ref_ty sliceT (zero_val sliceT)) in
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref lazyFileBuf "next" "buf")) in
          let: "$a1" := (![sliceT] "p") in
          (slice.append sliceT) "$a0" "$a1") in
          do:  ("newBuf" <-[sliceT] "$r0");;;
          let: "$r0" := (let: "$offset" := (![uint64T] (struct.field_ref lazyFileBuf "offset" "buf")) in
          let: "$next" := (![sliceT] "newBuf") in
          struct.make lazyFileBuf [{
            "offset" ::= "$offset";
            "next" ::= "$next"
          }]) in
          do:  ("buf" <-[lazyFileBuf] "$r0");;;
          continue: #()))))).

(* Build a new shadow table that incorporates the current table and a
   (write) buffer wbuf.

   Assumes all the appropriate locks have been taken.

   Returns the old table and new table.

   go: simpledb.go:388:6 *)
Definition constructNewTable : val :=
  rec: "constructNewTable" "db" "wbuf" :=
    exception_do (let: "wbuf" := (ref_ty (mapT uint64T sliceT) "wbuf") in
    let: "db" := (ref_ty Database "db") in
    let: "oldName" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (![stringT] (![ptrT] (struct.field_ref Database "tableName" "db"))) in
    do:  ("oldName" <-[stringT] "$r0");;;
    let: "name" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (let: "$a0" := (![stringT] "oldName") in
    freshTable "$a0") in
    do:  ("name" <-[stringT] "$r0");;;
    let: "w" := (ref_ty tableWriter (zero_val tableWriter)) in
    let: "$r0" := (let: "$a0" := (![stringT] "name") in
    newTableWriter "$a0") in
    do:  ("w" <-[tableWriter] "$r0");;;
    let: "oldTable" := (ref_ty Table (zero_val Table)) in
    let: "$r0" := (![Table] (![ptrT] (struct.field_ref Database "table" "db"))) in
    do:  ("oldTable" <-[Table] "$r0");;;
    do:  (let: "$a0" := (![tableWriter] "w") in
    let: "$a1" := (![Table] "oldTable") in
    let: "$a2" := (![mapT uint64T sliceT] "wbuf") in
    tablePutOldTable "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![tableWriter] "w") in
    let: "$a1" := (![mapT uint64T sliceT] "wbuf") in
    tablePutBuffer "$a0" "$a1");;;
    let: "newTable" := (ref_ty Table (zero_val Table)) in
    let: "$r0" := (let: "$a0" := (![tableWriter] "w") in
    tableWriterClose "$a0") in
    do:  ("newTable" <-[Table] "$r0");;;
    return: (![Table] "oldTable", ![Table] "newTable")).

(* Compact persists in-memory writes to a new table.

   This simple database design must re-write all data to combine in-memory
   writes with existing writes.

   go: simpledb.go:405:6 *)
Definition Compact : val :=
  rec: "Compact" "db" :=
    exception_do (let: "db" := (ref_ty Database "db") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "compactionL" "db"))) #());;;
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
    let: "buf" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (![mapT uint64T sliceT] (![ptrT] (struct.field_ref Database "wbuffer" "db"))) in
    do:  ("buf" <-[mapT uint64T sliceT] "$r0");;;
    let: "emptyWbuffer" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (map.make uint64T sliceT #()) in
    do:  ("emptyWbuffer" <-[mapT uint64T sliceT] "$r0");;;
    let: "$r0" := (![mapT uint64T sliceT] "emptyWbuffer") in
    do:  ((![ptrT] (struct.field_ref Database "wbuffer" "db")) <-[mapT uint64T sliceT] "$r0");;;
    let: "$r0" := (![mapT uint64T sliceT] "buf") in
    do:  ((![ptrT] (struct.field_ref Database "rbuffer" "db")) <-[mapT uint64T sliceT] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "tableL" "db"))) #());;;
    let: "oldTableName" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (![stringT] (![ptrT] (struct.field_ref Database "tableName" "db"))) in
    do:  ("oldTableName" <-[stringT] "$r0");;;
    let: "t" := (ref_ty Table (zero_val Table)) in
    let: "oldTable" := (ref_ty Table (zero_val Table)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![Database] "db") in
    let: "$a1" := (![mapT uint64T sliceT] "buf") in
    constructNewTable "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("oldTable" <-[Table] "$r0");;;
    do:  ("t" <-[Table] "$r1");;;
    let: "newTable" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (let: "$a0" := (![stringT] "oldTableName") in
    freshTable "$a0") in
    do:  ("newTable" <-[stringT] "$r0");;;
    let: "$r0" := (![Table] "t") in
    do:  ((![ptrT] (struct.field_ref Database "table" "db")) <-[Table] "$r0");;;
    let: "$r0" := (![stringT] "newTable") in
    do:  ((![ptrT] (struct.field_ref Database "tableName" "db")) <-[stringT] "$r0");;;
    let: "manifestData" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (string.to_bytes (![stringT] "newTable")) in
    do:  ("manifestData" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := #"db"%go in
    let: "$a1" := #"manifest"%go in
    let: "$a2" := (![sliceT] "manifestData") in
    filesys.AtomicCreate "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![Table] "oldTable") in
    CloseTable "$a0");;;
    do:  (let: "$a0" := #"db"%go in
    let: "$a1" := (![stringT] "oldTableName") in
    filesys.Delete "$a0" "$a1");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "tableL" "db"))) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "compactionL" "db"))) #())).

(* go: simpledb.go:450:6 *)
Definition recoverManifest : val :=
  rec: "recoverManifest" <> :=
    exception_do (let: "f" := (ref_ty fileT (zero_val fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := #"manifest"%go in
    filesys.Open "$a0" "$a1") in
    do:  ("f" <-[fileT] "$r0");;;
    let: "manifestData" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![fileT] "f") in
    let: "$a1" := #(W64 0) in
    let: "$a2" := #(W64 4096) in
    filesys.ReadAt "$a0" "$a1" "$a2") in
    do:  ("manifestData" <-[sliceT] "$r0");;;
    let: "tableName" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT] "manifestData")) in
    do:  ("tableName" <-[stringT] "$r0");;;
    do:  (let: "$a0" := (![fileT] "f") in
    filesys.Close "$a0");;;
    return: (![stringT] "tableName")).

(* delete 'name' if it isn't tableName or "manifest"

   go: simpledb.go:464:6 *)
Definition deleteOtherFile : val :=
  rec: "deleteOtherFile" "name" "tableName" :=
    exception_do (let: "tableName" := (ref_ty stringT "tableName") in
    let: "name" := (ref_ty stringT "name") in
    (if: (![stringT] "name") = (![stringT] "tableName")
    then return: (#())
    else do:  #());;;
    (if: (![stringT] "name") = #"manifest"%go
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := #"db"%go in
    let: "$a1" := (![stringT] "name") in
    filesys.Delete "$a0" "$a1")).

(* go: simpledb.go:474:6 *)
Definition deleteOtherFiles : val :=
  rec: "deleteOtherFiles" "tableName" :=
    exception_do (let: "tableName" := (ref_ty stringT "tableName") in
    let: "files" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    filesys.List "$a0") in
    do:  ("files" <-[sliceT] "$r0");;;
    let: "nfiles" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "files") in
    slice.len "$a0") in
    do:  ("nfiles" <-[uint64T] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") = (![uint64T] "nfiles")
      then break: #()
      else do:  #());;;
      let: "name" := (ref_ty stringT (zero_val stringT)) in
      let: "$r0" := (![stringT] (slice.elem_ref stringT (![sliceT] "files") (![uint64T] "i"))) in
      do:  ("name" <-[stringT] "$r0");;;
      do:  (let: "$a0" := (![stringT] "name") in
      let: "$a1" := (![stringT] "tableName") in
      deleteOtherFile "$a0" "$a1");;;
      let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[uint64T] "$r0");;;
      continue: #()))).

(* Recover restores a previously created database after a crash or shutdown.

   go: simpledb.go:489:6 *)
Definition Recover : val :=
  rec: "Recover" <> :=
    exception_do (let: "tableName" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (recoverManifest #()) in
    do:  ("tableName" <-[stringT] "$r0");;;
    let: "table" := (ref_ty Table (zero_val Table)) in
    let: "$r0" := (let: "$a0" := (![stringT] "tableName") in
    RecoverTable "$a0") in
    do:  ("table" <-[Table] "$r0");;;
    let: "tableRef" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Table (zero_val Table)) in
    do:  ("tableRef" <-[ptrT] "$r0");;;
    let: "$r0" := (![Table] "table") in
    do:  ((![ptrT] "tableRef") <-[Table] "$r0");;;
    let: "tableNameRef" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty stringT (zero_val stringT)) in
    do:  ("tableNameRef" <-[ptrT] "$r0");;;
    let: "$r0" := (![stringT] "tableName") in
    do:  ((![ptrT] "tableNameRef") <-[stringT] "$r0");;;
    do:  (let: "$a0" := (![stringT] "tableName") in
    deleteOtherFiles "$a0");;;
    let: "wbuffer" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (makeValueBuffer #()) in
    do:  ("wbuffer" <-[ptrT] "$r0");;;
    let: "rbuffer" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (makeValueBuffer #()) in
    do:  ("rbuffer" <-[ptrT] "$r0");;;
    let: "bufferL" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("bufferL" <-[ptrT] "$r0");;;
    let: "tableL" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("tableL" <-[ptrT] "$r0");;;
    let: "compactionL" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("compactionL" <-[ptrT] "$r0");;;
    return: (let: "$wbuffer" := (![ptrT] "wbuffer") in
     let: "$rbuffer" := (![ptrT] "rbuffer") in
     let: "$bufferL" := (![ptrT] "bufferL") in
     let: "$table" := (![ptrT] "tableRef") in
     let: "$tableName" := (![ptrT] "tableNameRef") in
     let: "$tableL" := (![ptrT] "tableL") in
     let: "$compactionL" := (![ptrT] "compactionL") in
     struct.make Database [{
       "wbuffer" ::= "$wbuffer";
       "rbuffer" ::= "$rbuffer";
       "bufferL" ::= "$bufferL";
       "table" ::= "$table";
       "tableName" ::= "$tableName";
       "tableL" ::= "$tableL";
       "compactionL" ::= "$compactionL"
     }])).

(* Shutdown immediately closes the database.

   Discards any uncommitted in-memory writes; similar to a crash except for
   cleanly closing any open files.

   go: simpledb.go:520:6 *)
Definition Shutdown : val :=
  rec: "Shutdown" "db" :=
    exception_do (let: "db" := (ref_ty Database "db") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #());;;
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Database "compactionL" "db"))) #());;;
    let: "t" := (ref_ty Table (zero_val Table)) in
    let: "$r0" := (![Table] (![ptrT] (struct.field_ref Database "table" "db"))) in
    do:  ("t" <-[Table] "$r0");;;
    do:  (let: "$a0" := (![Table] "t") in
    CloseTable "$a0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "compactionL" "db"))) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Database "bufferL" "db"))) #())).

(* Close closes an open database cleanly, flushing any in-memory writes.

   db should not be used afterward

   go: simpledb.go:534:6 *)
Definition Close : val :=
  rec: "Close" "db" :=
    exception_do (let: "db" := (ref_ty Database "db") in
    do:  (let: "$a0" := (![Database] "db") in
    Compact "$a0");;;
    do:  (let: "$a0" := (![Database] "db") in
    Shutdown "$a0")).

Definition pkg_name' : go_string := "github.com/goose-lang/goose/testdata/examples/simpledb".

Definition define' : val :=
  rec: "define'" <> :=
    exception_do (do:  #()).

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init pkg_name' (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  filesys.initialize';;;
      do:  primitive.initialize';;;
      do:  sync.initialize';;;
      do:  (define' #()))
      ).

End code.
