(* autogenerated from github.com/goose-lang/goose/testdata/examples/simpledb *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.filesys.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

Definition simpledb : go_string := "github.com/goose-lang/goose/testdata/examples/simpledb".

Module simpledb.
Section code.
Context `{ffi_syntax}.


(* go: simpledb.go:20:6 *)
Definition UseMarshal : val :=
  rec: "UseMarshal" <> :=
    exception_do (do:  (let: "$a0" := #(W64 0) in
    (func_call #marshal #"NewEnc"%go) "$a0")).

Definition Table : go_type := structT [
  "Index" :: mapT uint64T uint64T;
  "File" :: fileT
].

(* CreateTable creates a new, empty table.

   go: simpledb.go:32:6 *)
Definition CreateTable : val :=
  rec: "CreateTable" "p" :=
    exception_do (let: "p" := (alloc "p") in
    let: "index" := (alloc (type.zero_val #(mapT uint64T uint64T))) in
    let: "$r0" := (map.make #uint64T) in
    do:  ("index" <-[#(mapT uint64T uint64T)] "$r0");;;
    let: "f" := (alloc (type.zero_val #fileT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := #"db"%go in
    let: "$a1" := (![#stringT] "p") in
    (func_call #filesys #"Create"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("f" <-[#fileT] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![#fileT] "f") in
    (func_call #filesys #"Close"%go) "$a0");;;
    let: "f2" := (alloc (type.zero_val #fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := (![#stringT] "p") in
    (func_call #filesys #"Open"%go) "$a0" "$a1") in
    do:  ("f2" <-[#fileT] "$r0");;;
    return: (let: "$Index" := (![#(mapT uint64T uint64T)] "index") in
     let: "$File" := (![#fileT] "f2") in
     struct.make #Table [{
       "Index" ::= "$Index";
       "File" ::= "$File"
     }])).

Definition Entry : go_type := structT [
  "Key" :: uint64T;
  "Value" :: sliceT
].

(* DecodeUInt64 is a Decoder(uint64)

   All decoders have the shape func(p []byte) (T, uint64)

   The uint64 represents the number of bytes consumed; if 0,
   then decoding failed, and the value of type T should be ignored.

   go: simpledb.go:52:6 *)
Definition DecodeUInt64 : val :=
  rec: "DecodeUInt64" "p" :=
    exception_do (let: "p" := (alloc "p") in
    (if: int_lt (let: "$a0" := (![#sliceT] "p") in
    slice.len "$a0") #(W64 8)
    then return: (#(W64 0), #(W64 0))
    else do:  #());;;
    let: "n" := (alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "p") in
    (func_call #primitive #"UInt64Get"%go) "$a0") in
    do:  ("n" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "n", #(W64 8))).

(* DecodeEntry is a Decoder(Entry)

   go: simpledb.go:61:6 *)
Definition DecodeEntry : val :=
  rec: "DecodeEntry" "data" :=
    exception_do (let: "data" := (alloc "data") in
    let: "l1" := (alloc (type.zero_val #uint64T)) in
    let: "key" := (alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
    (func_call #simpledb.simpledb #"DecodeUInt64"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("key" <-[#uint64T] "$r0");;;
    do:  ("l1" <-[#uint64T] "$r1");;;
    (if: (![#uint64T] "l1") = #(W64 0)
    then
      return: (let: "$Key" := #(W64 0) in
       let: "$Value" := #slice.nil in
       struct.make #Entry [{
         "Key" ::= "$Key";
         "Value" ::= "$Value"
       }], #(W64 0))
    else do:  #());;;
    let: "l2" := (alloc (type.zero_val #uint64T)) in
    let: "valueLen" := (alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (let: "$s" := (![#sliceT] "data") in
    slice.slice #byteT "$s" (![#uint64T] "l1") (slice.len "$s")) in
    (func_call #simpledb.simpledb #"DecodeUInt64"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("valueLen" <-[#uint64T] "$r0");;;
    do:  ("l2" <-[#uint64T] "$r1");;;
    (if: (![#uint64T] "l2") = #(W64 0)
    then
      return: (let: "$Key" := #(W64 0) in
       let: "$Value" := #slice.nil in
       struct.make #Entry [{
         "Key" ::= "$Key";
         "Value" ::= "$Value"
       }], #(W64 0))
    else do:  #());;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) < (((![#uint64T] "l1") + (![#uint64T] "l2")) + (![#uint64T] "valueLen"))
    then
      return: (let: "$Key" := #(W64 0) in
       let: "$Value" := #slice.nil in
       struct.make #Entry [{
         "Key" ::= "$Key";
         "Value" ::= "$Value"
       }], #(W64 0))
    else do:  #());;;
    let: "value" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "data") in
    slice.slice #byteT "$s" ((![#uint64T] "l1") + (![#uint64T] "l2")) (((![#uint64T] "l1") + (![#uint64T] "l2")) + (![#uint64T] "valueLen"))) in
    do:  ("value" <-[#sliceT] "$r0");;;
    return: (let: "$Key" := (![#uint64T] "key") in
     let: "$Value" := (![#sliceT] "value") in
     struct.make #Entry [{
       "Key" ::= "$Key";
       "Value" ::= "$Value"
     }], ((![#uint64T] "l1") + (![#uint64T] "l2")) + (![#uint64T] "valueLen"))).

Definition lazyFileBuf : go_type := structT [
  "offset" :: uint64T;
  "next" :: sliceT
].

(* readTableIndex parses a complete table on disk into a key->offset index

   go: simpledb.go:86:6 *)
Definition readTableIndex : val :=
  rec: "readTableIndex" "f" "index" :=
    exception_do (let: "index" := (alloc "index") in
    let: "f" := (alloc "f") in
    (let: "buf" := (alloc (type.zero_val #lazyFileBuf)) in
    let: "$r0" := (let: "$offset" := #(W64 0) in
    let: "$next" := #slice.nil in
    struct.make #lazyFileBuf [{
      "offset" ::= "$offset";
      "next" ::= "$next"
    }]) in
    do:  ("buf" <-[#lazyFileBuf] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "l" := (alloc (type.zero_val #uint64T)) in
      let: "e" := (alloc (type.zero_val #Entry)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
      (func_call #simpledb.simpledb #"DecodeEntry"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[#Entry] "$r0");;;
      do:  ("l" <-[#uint64T] "$r1");;;
      (if: (![#uint64T] "l") > #(W64 0)
      then
        let: "$r0" := (#(W64 8) + (![#uint64T] (struct.field_ref #lazyFileBuf #"offset"%go "buf"))) in
        do:  (map.insert (![#(mapT uint64T uint64T)] "index") (![#uint64T] (struct.field_ref #Entry #"Key"%go "e")) "$r0");;;
        let: "$r0" := (let: "$offset" := ((![#uint64T] (struct.field_ref #lazyFileBuf #"offset"%go "buf")) + (![#uint64T] "l")) in
        let: "$next" := (let: "$s" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
        slice.slice #byteT "$s" (![#uint64T] "l") (slice.len "$s")) in
        struct.make #lazyFileBuf [{
          "offset" ::= "$offset";
          "next" ::= "$next"
        }]) in
        do:  ("buf" <-[#lazyFileBuf] "$r0");;;
        continue: #()
      else
        let: "p" := (alloc (type.zero_val #sliceT)) in
        let: "$r0" := (let: "$a0" := (![#fileT] "f") in
        let: "$a1" := ((![#uint64T] (struct.field_ref #lazyFileBuf #"offset"%go "buf")) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
        slice.len "$a0"))) in
        let: "$a2" := #(W64 4096) in
        (func_call #filesys #"ReadAt"%go) "$a0" "$a1" "$a2") in
        do:  ("p" <-[#sliceT] "$r0");;;
        (if: (let: "$a0" := (![#sliceT] "p") in
        slice.len "$a0") = #(W64 0)
        then break: #()
        else
          let: "newBuf" := (alloc (type.zero_val #sliceT)) in
          let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
          let: "$a1" := (![#sliceT] "p") in
          (slice.append #byteT) "$a0" "$a1") in
          do:  ("newBuf" <-[#sliceT] "$r0");;;
          let: "$r0" := (let: "$offset" := (![#uint64T] (struct.field_ref #lazyFileBuf #"offset"%go "buf")) in
          let: "$next" := (![#sliceT] "newBuf") in
          struct.make #lazyFileBuf [{
            "offset" ::= "$offset";
            "next" ::= "$next"
          }]) in
          do:  ("buf" <-[#lazyFileBuf] "$r0");;;
          continue: #()))))).

(* RecoverTable restores a table from disk on startup.

   go: simpledb.go:111:6 *)
Definition RecoverTable : val :=
  rec: "RecoverTable" "p" :=
    exception_do (let: "p" := (alloc "p") in
    let: "index" := (alloc (type.zero_val #(mapT uint64T uint64T))) in
    let: "$r0" := (map.make #uint64T) in
    do:  ("index" <-[#(mapT uint64T uint64T)] "$r0");;;
    let: "f" := (alloc (type.zero_val #fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := (![#stringT] "p") in
    (func_call #filesys #"Open"%go) "$a0" "$a1") in
    do:  ("f" <-[#fileT] "$r0");;;
    do:  (let: "$a0" := (![#fileT] "f") in
    let: "$a1" := (![#(mapT uint64T uint64T)] "index") in
    (func_call #simpledb.simpledb #"readTableIndex"%go) "$a0" "$a1");;;
    return: (let: "$Index" := (![#(mapT uint64T uint64T)] "index") in
     let: "$File" := (![#fileT] "f") in
     struct.make #Table [{
       "Index" ::= "$Index";
       "File" ::= "$File"
     }])).

(* CloseTable frees up the fd held by a table.

   go: simpledb.go:119:6 *)
Definition CloseTable : val :=
  rec: "CloseTable" "t" :=
    exception_do (let: "t" := (alloc "t") in
    do:  (let: "$a0" := (![#fileT] (struct.field_ref #Table #"File"%go "t")) in
    (func_call #filesys #"Close"%go) "$a0")).

(* go: simpledb.go:123:6 *)
Definition readValue : val :=
  rec: "readValue" "f" "off" :=
    exception_do (let: "off" := (alloc "off") in
    let: "f" := (alloc "f") in
    let: "startBuf" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#fileT] "f") in
    let: "$a1" := (![#uint64T] "off") in
    let: "$a2" := #(W64 512) in
    (func_call #filesys #"ReadAt"%go) "$a0" "$a1" "$a2") in
    do:  ("startBuf" <-[#sliceT] "$r0");;;
    let: "totalBytes" := (alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "startBuf") in
    (func_call #primitive #"UInt64Get"%go) "$a0") in
    do:  ("totalBytes" <-[#uint64T] "$r0");;;
    let: "buf" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "startBuf") in
    slice.slice #byteT "$s" #(W64 8) (slice.len "$s")) in
    do:  ("buf" <-[#sliceT] "$r0");;;
    let: "haveBytes" := (alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "buf") in
    slice.len "$a0")) in
    do:  ("haveBytes" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "haveBytes") < (![#uint64T] "totalBytes")
    then
      let: "buf2" := (alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#fileT] "f") in
      let: "$a1" := ((![#uint64T] "off") + #(W64 512)) in
      let: "$a2" := ((![#uint64T] "totalBytes") - (![#uint64T] "haveBytes")) in
      (func_call #filesys #"ReadAt"%go) "$a0" "$a1" "$a2") in
      do:  ("buf2" <-[#sliceT] "$r0");;;
      let: "newBuf" := (alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "buf") in
      let: "$a1" := (![#sliceT] "buf2") in
      (slice.append #byteT) "$a0" "$a1") in
      do:  ("newBuf" <-[#sliceT] "$r0");;;
      return: (![#sliceT] "newBuf")
    else do:  #());;;
    return: (let: "$s" := (![#sliceT] "buf") in
     slice.slice #byteT "$s" #(W64 0) (![#uint64T] "totalBytes"))).

(* go: simpledb.go:137:6 *)
Definition tableRead : val :=
  rec: "tableRead" "t" "k" :=
    exception_do (let: "k" := (alloc "k") in
    let: "t" := (alloc "t") in
    let: "ok" := (alloc (type.zero_val #boolT)) in
    let: "off" := (alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![#(mapT uint64T uint64T)] (struct.field_ref #Table #"Index"%go "t")) (![#uint64T] "k")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("off" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok"))
    then return: (#slice.nil, #false)
    else do:  #());;;
    let: "p" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#fileT] (struct.field_ref #Table #"File"%go "t")) in
    let: "$a1" := (![#uint64T] "off") in
    (func_call #simpledb.simpledb #"readValue"%go) "$a0" "$a1") in
    do:  ("p" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "p", #true)).

Definition bufFile : go_type := structT [
  "file" :: fileT;
  "buf" :: ptrT
].

(* go: simpledb.go:151:6 *)
Definition newBuf : val :=
  rec: "newBuf" "f" :=
    exception_do (let: "f" := (alloc "f") in
    let: "buf" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #sliceT)) in
    do:  ("buf" <-[#ptrT] "$r0");;;
    return: (let: "$file" := (![#fileT] "f") in
     let: "$buf" := (![#ptrT] "buf") in
     struct.make #bufFile [{
       "file" ::= "$file";
       "buf" ::= "$buf"
     }])).

(* go: simpledb.go:159:6 *)
Definition bufFlush : val :=
  rec: "bufFlush" "f" :=
    exception_do (let: "f" := (alloc "f") in
    let: "buf" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (![#ptrT] (struct.field_ref #bufFile #"buf"%go "f"))) in
    do:  ("buf" <-[#sliceT] "$r0");;;
    (if: (let: "$a0" := (![#sliceT] "buf") in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := (![#fileT] (struct.field_ref #bufFile #"file"%go "f")) in
    let: "$a1" := (![#sliceT] "buf") in
    (func_call #filesys #"Append"%go) "$a0" "$a1");;;
    let: "$r0" := #slice.nil in
    do:  ((![#ptrT] (struct.field_ref #bufFile #"buf"%go "f")) <-[#sliceT] "$r0")).

(* go: simpledb.go:168:6 *)
Definition bufAppend : val :=
  rec: "bufAppend" "f" "p" :=
    exception_do (let: "p" := (alloc "p") in
    let: "f" := (alloc "f") in
    let: "buf" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (![#ptrT] (struct.field_ref #bufFile #"buf"%go "f"))) in
    do:  ("buf" <-[#sliceT] "$r0");;;
    let: "buf2" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "buf") in
    let: "$a1" := (![#sliceT] "p") in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ("buf2" <-[#sliceT] "$r0");;;
    let: "$r0" := (![#sliceT] "buf2") in
    do:  ((![#ptrT] (struct.field_ref #bufFile #"buf"%go "f")) <-[#sliceT] "$r0")).

(* go: simpledb.go:174:6 *)
Definition bufClose : val :=
  rec: "bufClose" "f" :=
    exception_do (let: "f" := (alloc "f") in
    do:  (let: "$a0" := (![#bufFile] "f") in
    (func_call #simpledb.simpledb #"bufFlush"%go) "$a0");;;
    do:  (let: "$a0" := (![#fileT] (struct.field_ref #bufFile #"file"%go "f")) in
    (func_call #filesys #"Close"%go) "$a0")).

Definition tableWriter : go_type := structT [
  "index" :: mapT uint64T uint64T;
  "name" :: stringT;
  "file" :: bufFile;
  "offset" :: ptrT
].

(* go: simpledb.go:186:6 *)
Definition newTableWriter : val :=
  rec: "newTableWriter" "p" :=
    exception_do (let: "p" := (alloc "p") in
    let: "index" := (alloc (type.zero_val #(mapT uint64T uint64T))) in
    let: "$r0" := (map.make #uint64T) in
    do:  ("index" <-[#(mapT uint64T uint64T)] "$r0");;;
    let: "f" := (alloc (type.zero_val #fileT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := #"db"%go in
    let: "$a1" := (![#stringT] "p") in
    (func_call #filesys #"Create"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("f" <-[#fileT] "$r0");;;
    do:  "$r1";;;
    let: "buf" := (alloc (type.zero_val #bufFile)) in
    let: "$r0" := (let: "$a0" := (![#fileT] "f") in
    (func_call #simpledb.simpledb #"newBuf"%go) "$a0") in
    do:  ("buf" <-[#bufFile] "$r0");;;
    let: "off" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #uint64T)) in
    do:  ("off" <-[#ptrT] "$r0");;;
    return: (let: "$index" := (![#(mapT uint64T uint64T)] "index") in
     let: "$name" := (![#stringT] "p") in
     let: "$file" := (![#bufFile] "buf") in
     let: "$offset" := (![#ptrT] "off") in
     struct.make #tableWriter [{
       "index" ::= "$index";
       "name" ::= "$name";
       "file" ::= "$file";
       "offset" ::= "$offset"
     }])).

(* go: simpledb.go:199:6 *)
Definition tableWriterAppend : val :=
  rec: "tableWriterAppend" "w" "p" :=
    exception_do (let: "p" := (alloc "p") in
    let: "w" := (alloc "w") in
    do:  (let: "$a0" := (![#bufFile] (struct.field_ref #tableWriter #"file"%go "w")) in
    let: "$a1" := (![#sliceT] "p") in
    (func_call #simpledb.simpledb #"bufAppend"%go) "$a0" "$a1");;;
    let: "off" := (alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] (struct.field_ref #tableWriter #"offset"%go "w"))) in
    do:  ("off" <-[#uint64T] "$r0");;;
    let: "$r0" := ((![#uint64T] "off") + (s_to_w64 (let: "$a0" := (![#sliceT] "p") in
    slice.len "$a0"))) in
    do:  ((![#ptrT] (struct.field_ref #tableWriter #"offset"%go "w")) <-[#uint64T] "$r0")).

(* go: simpledb.go:205:6 *)
Definition tableWriterClose : val :=
  rec: "tableWriterClose" "w" :=
    exception_do (let: "w" := (alloc "w") in
    do:  (let: "$a0" := (![#bufFile] (struct.field_ref #tableWriter #"file"%go "w")) in
    (func_call #simpledb.simpledb #"bufClose"%go) "$a0");;;
    let: "f" := (alloc (type.zero_val #fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := (![#stringT] (struct.field_ref #tableWriter #"name"%go "w")) in
    (func_call #filesys #"Open"%go) "$a0" "$a1") in
    do:  ("f" <-[#fileT] "$r0");;;
    return: (let: "$Index" := (![#(mapT uint64T uint64T)] (struct.field_ref #tableWriter #"index"%go "w")) in
     let: "$File" := (![#fileT] "f") in
     struct.make #Table [{
       "Index" ::= "$Index";
       "File" ::= "$File"
     }])).

(* EncodeUInt64 is an Encoder(uint64)

   go: simpledb.go:215:6 *)
Definition EncodeUInt64 : val :=
  rec: "EncodeUInt64" "x" "p" :=
    exception_do (let: "p" := (alloc "p") in
    let: "x" := (alloc "x") in
    let: "tmp" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 8)) in
    do:  ("tmp" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "tmp") in
    let: "$a1" := (![#uint64T] "x") in
    (func_call #primitive #"UInt64Put"%go) "$a0" "$a1");;;
    let: "p2" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "p") in
    let: "$a1" := (![#sliceT] "tmp") in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ("p2" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "p2")).

(* EncodeSlice is an Encoder([]byte)

   go: simpledb.go:223:6 *)
Definition EncodeSlice : val :=
  rec: "EncodeSlice" "data" "p" :=
    exception_do (let: "p" := (alloc "p") in
    let: "data" := (alloc "data") in
    let: "p2" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    let: "$a1" := (![#sliceT] "p") in
    (func_call #simpledb.simpledb #"EncodeUInt64"%go) "$a0" "$a1") in
    do:  ("p2" <-[#sliceT] "$r0");;;
    let: "p3" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "p2") in
    let: "$a1" := (![#sliceT] "data") in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ("p3" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "p3")).

(* go: simpledb.go:229:6 *)
Definition tablePut : val :=
  rec: "tablePut" "w" "k" "v" :=
    exception_do (let: "v" := (alloc "v") in
    let: "k" := (alloc "k") in
    let: "w" := (alloc "w") in
    let: "tmp" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 0)) in
    do:  ("tmp" <-[#sliceT] "$r0");;;
    let: "tmp2" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "k") in
    let: "$a1" := (![#sliceT] "tmp") in
    (func_call #simpledb.simpledb #"EncodeUInt64"%go) "$a0" "$a1") in
    do:  ("tmp2" <-[#sliceT] "$r0");;;
    let: "tmp3" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "v") in
    let: "$a1" := (![#sliceT] "tmp2") in
    (func_call #simpledb.simpledb #"EncodeSlice"%go) "$a0" "$a1") in
    do:  ("tmp3" <-[#sliceT] "$r0");;;
    let: "off" := (alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] (struct.field_ref #tableWriter #"offset"%go "w"))) in
    do:  ("off" <-[#uint64T] "$r0");;;
    let: "$r0" := ((![#uint64T] "off") + (s_to_w64 (let: "$a0" := (![#sliceT] "tmp2") in
    slice.len "$a0"))) in
    do:  (map.insert (![#(mapT uint64T uint64T)] (struct.field_ref #tableWriter #"index"%go "w")) (![#uint64T] "k") "$r0");;;
    do:  (let: "$a0" := (![#tableWriter] "w") in
    let: "$a1" := (![#sliceT] "tmp3") in
    (func_call #simpledb.simpledb #"tableWriterAppend"%go) "$a0" "$a1")).

Definition Database : go_type := structT [
  "wbuffer" :: ptrT;
  "rbuffer" :: ptrT;
  "bufferL" :: ptrT;
  "table" :: ptrT;
  "tableName" :: ptrT;
  "tableL" :: ptrT;
  "compactionL" :: ptrT
].

(* go: simpledb.go:256:6 *)
Definition makeValueBuffer : val :=
  rec: "makeValueBuffer" <> :=
    exception_do (let: "buf" := (alloc (type.zero_val #(mapT uint64T sliceT))) in
    let: "$r0" := (map.make #sliceT) in
    do:  ("buf" <-[#(mapT uint64T sliceT)] "$r0");;;
    let: "bufPtr" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #(mapT uint64T sliceT))) in
    do:  ("bufPtr" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#(mapT uint64T sliceT)] "buf") in
    do:  ((![#ptrT] "bufPtr") <-[#(mapT uint64T sliceT)] "$r0");;;
    return: (![#ptrT] "bufPtr")).

(* NewDb initializes a new database on top of an empty filesys.

   go: simpledb.go:264:6 *)
Definition NewDb : val :=
  rec: "NewDb" <> :=
    exception_do (let: "wbuf" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #simpledb.simpledb #"makeValueBuffer"%go) #()) in
    do:  ("wbuf" <-[#ptrT] "$r0");;;
    let: "rbuf" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #simpledb.simpledb #"makeValueBuffer"%go) #()) in
    do:  ("rbuf" <-[#ptrT] "$r0");;;
    let: "bufferL" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #sync.Mutex)) in
    do:  ("bufferL" <-[#ptrT] "$r0");;;
    let: "tableName" := (alloc (type.zero_val #stringT)) in
    let: "$r0" := #"table.0"%go in
    do:  ("tableName" <-[#stringT] "$r0");;;
    let: "tableNameRef" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #stringT)) in
    do:  ("tableNameRef" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#stringT] "tableName") in
    do:  ((![#ptrT] "tableNameRef") <-[#stringT] "$r0");;;
    let: "table" := (alloc (type.zero_val #Table)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "tableName") in
    (func_call #simpledb.simpledb #"CreateTable"%go) "$a0") in
    do:  ("table" <-[#Table] "$r0");;;
    let: "tableRef" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #Table)) in
    do:  ("tableRef" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#Table] "table") in
    do:  ((![#ptrT] "tableRef") <-[#Table] "$r0");;;
    let: "tableL" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #sync.Mutex)) in
    do:  ("tableL" <-[#ptrT] "$r0");;;
    let: "compactionL" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #sync.Mutex)) in
    do:  ("compactionL" <-[#ptrT] "$r0");;;
    return: (let: "$wbuffer" := (![#ptrT] "wbuf") in
     let: "$rbuffer" := (![#ptrT] "rbuf") in
     let: "$bufferL" := (![#ptrT] "bufferL") in
     let: "$table" := (![#ptrT] "tableRef") in
     let: "$tableName" := (![#ptrT] "tableNameRef") in
     let: "$tableL" := (![#ptrT] "tableL") in
     let: "$compactionL" := (![#ptrT] "compactionL") in
     struct.make #Database [{
       "wbuffer" ::= "$wbuffer";
       "rbuffer" ::= "$rbuffer";
       "bufferL" ::= "$bufferL";
       "table" ::= "$table";
       "tableName" ::= "$tableName";
       "tableL" ::= "$tableL";
       "compactionL" ::= "$compactionL"
     }])).

(* Read gets a key from the database.

   Returns a boolean indicating if the k was found and a non-nil slice with
   the value if k was in the database.

   Reflects any completed in-memory writes.

   go: simpledb.go:293:6 *)
Definition Read : val :=
  rec: "Read" "db" "k" :=
    exception_do (let: "k" := (alloc "k") in
    let: "db" := (alloc "db") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
    let: "buf" := (alloc (type.zero_val #(mapT uint64T sliceT))) in
    let: "$r0" := (![#(mapT uint64T sliceT)] (![#ptrT] (struct.field_ref #Database #"wbuffer"%go "db"))) in
    do:  ("buf" <-[#(mapT uint64T sliceT)] "$r0");;;
    let: "ok" := (alloc (type.zero_val #boolT)) in
    let: "v" := (alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![#(mapT uint64T sliceT)] "buf") (![#uint64T] "k")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
      return: (![#sliceT] "v", #true)
    else do:  #());;;
    let: "rbuf" := (alloc (type.zero_val #(mapT uint64T sliceT))) in
    let: "$r0" := (![#(mapT uint64T sliceT)] (![#ptrT] (struct.field_ref #Database #"rbuffer"%go "db"))) in
    do:  ("rbuf" <-[#(mapT uint64T sliceT)] "$r0");;;
    let: "v2" := (alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![#(mapT uint64T sliceT)] "rbuf") (![#uint64T] "k")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
      return: (![#sliceT] "v2", #true)
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"tableL"%go "db"))) #());;;
    let: "tbl" := (alloc (type.zero_val #Table)) in
    let: "$r0" := (![#Table] (![#ptrT] (struct.field_ref #Database #"table"%go "db"))) in
    do:  ("tbl" <-[#Table] "$r0");;;
    let: "v3" := (alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#Table] "tbl") in
    let: "$a1" := (![#uint64T] "k") in
    (func_call #simpledb.simpledb #"tableRead"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v3" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"tableL"%go "db"))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
    return: (![#sliceT] "v3", ![#boolT] "ok")).

(* Write sets a key to a new value.

   Creates a new key-value mapping if k is not in the database and overwrites
   the previous value if k is present.

   The new value is buffered in memory. To persist it, call db.Compact().

   go: simpledb.go:326:6 *)
Definition Write : val :=
  rec: "Write" "db" "k" "v" :=
    exception_do (let: "v" := (alloc "v") in
    let: "k" := (alloc "k") in
    let: "db" := (alloc "db") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
    let: "buf" := (alloc (type.zero_val #(mapT uint64T sliceT))) in
    let: "$r0" := (![#(mapT uint64T sliceT)] (![#ptrT] (struct.field_ref #Database #"wbuffer"%go "db"))) in
    do:  ("buf" <-[#(mapT uint64T sliceT)] "$r0");;;
    let: "$r0" := (![#sliceT] "v") in
    do:  (map.insert (![#(mapT uint64T sliceT)] "buf") (![#uint64T] "k") "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #())).

(* go: simpledb.go:333:6 *)
Definition freshTable : val :=
  rec: "freshTable" "p" :=
    exception_do (let: "p" := (alloc "p") in
    (if: (![#stringT] "p") = #"table.0"%go
    then return: (#"table.1"%go)
    else do:  #());;;
    (if: (![#stringT] "p") = #"table.1"%go
    then return: (#"table.0"%go)
    else do:  #());;;
    return: (![#stringT] "p")).

(* go: simpledb.go:345:6 *)
Definition tablePutBuffer : val :=
  rec: "tablePutBuffer" "w" "buf" :=
    exception_do (let: "buf" := (alloc "buf") in
    let: "w" := (alloc "w") in
    let: "$range" := (![#(mapT uint64T sliceT)] "buf") in
    (let: "v" := (alloc (type.zero_val #uint64T)) in
    let: "k" := (alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#sliceT] "$value");;;
      do:  ("k" <-[#uint64T] "$key");;;
      do:  (let: "$a0" := (![#tableWriter] "w") in
      let: "$a1" := (![#uint64T] "k") in
      let: "$a2" := (![#sliceT] "v") in
      (func_call #simpledb.simpledb #"tablePut"%go) "$a0" "$a1" "$a2")))).

(* add all of table t to the table w being created; skip any keys in the (read)
   buffer b since those writes overwrite old ones

   go: simpledb.go:353:6 *)
Definition tablePutOldTable : val :=
  rec: "tablePutOldTable" "w" "t" "b" :=
    exception_do (let: "b" := (alloc "b") in
    let: "t" := (alloc "t") in
    let: "w" := (alloc "w") in
    (let: "buf" := (alloc (type.zero_val #lazyFileBuf)) in
    let: "$r0" := (let: "$offset" := #(W64 0) in
    let: "$next" := #slice.nil in
    struct.make #lazyFileBuf [{
      "offset" ::= "$offset";
      "next" ::= "$next"
    }]) in
    do:  ("buf" <-[#lazyFileBuf] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "l" := (alloc (type.zero_val #uint64T)) in
      let: "e" := (alloc (type.zero_val #Entry)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
      (func_call #simpledb.simpledb #"DecodeEntry"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[#Entry] "$r0");;;
      do:  ("l" <-[#uint64T] "$r1");;;
      (if: (![#uint64T] "l") > #(W64 0)
      then
        let: "ok" := (alloc (type.zero_val #boolT)) in
        let: ("$ret0", "$ret1") := (map.get (![#(mapT uint64T sliceT)] "b") (![#uint64T] (struct.field_ref #Entry #"Key"%go "e"))) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  "$r0";;;
        do:  ("ok" <-[#boolT] "$r1");;;
        (if: (~ (![#boolT] "ok"))
        then
          do:  (let: "$a0" := (![#tableWriter] "w") in
          let: "$a1" := (![#uint64T] (struct.field_ref #Entry #"Key"%go "e")) in
          let: "$a2" := (![#sliceT] (struct.field_ref #Entry #"Value"%go "e")) in
          (func_call #simpledb.simpledb #"tablePut"%go) "$a0" "$a1" "$a2")
        else do:  #());;;
        let: "$r0" := (let: "$offset" := ((![#uint64T] (struct.field_ref #lazyFileBuf #"offset"%go "buf")) + (![#uint64T] "l")) in
        let: "$next" := (let: "$s" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
        slice.slice #byteT "$s" (![#uint64T] "l") (slice.len "$s")) in
        struct.make #lazyFileBuf [{
          "offset" ::= "$offset";
          "next" ::= "$next"
        }]) in
        do:  ("buf" <-[#lazyFileBuf] "$r0");;;
        continue: #()
      else
        let: "p" := (alloc (type.zero_val #sliceT)) in
        let: "$r0" := (let: "$a0" := (![#fileT] (struct.field_ref #Table #"File"%go "t")) in
        let: "$a1" := ((![#uint64T] (struct.field_ref #lazyFileBuf #"offset"%go "buf")) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
        slice.len "$a0"))) in
        let: "$a2" := #(W64 4096) in
        (func_call #filesys #"ReadAt"%go) "$a0" "$a1" "$a2") in
        do:  ("p" <-[#sliceT] "$r0");;;
        (if: (let: "$a0" := (![#sliceT] "p") in
        slice.len "$a0") = #(W64 0)
        then break: #()
        else
          let: "newBuf" := (alloc (type.zero_val #sliceT)) in
          let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #lazyFileBuf #"next"%go "buf")) in
          let: "$a1" := (![#sliceT] "p") in
          (slice.append #byteT) "$a0" "$a1") in
          do:  ("newBuf" <-[#sliceT] "$r0");;;
          let: "$r0" := (let: "$offset" := (![#uint64T] (struct.field_ref #lazyFileBuf #"offset"%go "buf")) in
          let: "$next" := (![#sliceT] "newBuf") in
          struct.make #lazyFileBuf [{
            "offset" ::= "$offset";
            "next" ::= "$next"
          }]) in
          do:  ("buf" <-[#lazyFileBuf] "$r0");;;
          continue: #()))))).

(* Build a new shadow table that incorporates the current table and a
   (write) buffer wbuf.

   Assumes all the appropriate locks have been taken.

   Returns the old table and new table.

   go: simpledb.go:388:6 *)
Definition constructNewTable : val :=
  rec: "constructNewTable" "db" "wbuf" :=
    exception_do (let: "wbuf" := (alloc "wbuf") in
    let: "db" := (alloc "db") in
    let: "oldName" := (alloc (type.zero_val #stringT)) in
    let: "$r0" := (![#stringT] (![#ptrT] (struct.field_ref #Database #"tableName"%go "db"))) in
    do:  ("oldName" <-[#stringT] "$r0");;;
    let: "name" := (alloc (type.zero_val #stringT)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "oldName") in
    (func_call #simpledb.simpledb #"freshTable"%go) "$a0") in
    do:  ("name" <-[#stringT] "$r0");;;
    let: "w" := (alloc (type.zero_val #tableWriter)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "name") in
    (func_call #simpledb.simpledb #"newTableWriter"%go) "$a0") in
    do:  ("w" <-[#tableWriter] "$r0");;;
    let: "oldTable" := (alloc (type.zero_val #Table)) in
    let: "$r0" := (![#Table] (![#ptrT] (struct.field_ref #Database #"table"%go "db"))) in
    do:  ("oldTable" <-[#Table] "$r0");;;
    do:  (let: "$a0" := (![#tableWriter] "w") in
    let: "$a1" := (![#Table] "oldTable") in
    let: "$a2" := (![#(mapT uint64T sliceT)] "wbuf") in
    (func_call #simpledb.simpledb #"tablePutOldTable"%go) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![#tableWriter] "w") in
    let: "$a1" := (![#(mapT uint64T sliceT)] "wbuf") in
    (func_call #simpledb.simpledb #"tablePutBuffer"%go) "$a0" "$a1");;;
    let: "newTable" := (alloc (type.zero_val #Table)) in
    let: "$r0" := (let: "$a0" := (![#tableWriter] "w") in
    (func_call #simpledb.simpledb #"tableWriterClose"%go) "$a0") in
    do:  ("newTable" <-[#Table] "$r0");;;
    return: (![#Table] "oldTable", ![#Table] "newTable")).

(* Compact persists in-memory writes to a new table.

   This simple database design must re-write all data to combine in-memory
   writes with existing writes.

   go: simpledb.go:405:6 *)
Definition Compact : val :=
  rec: "Compact" "db" :=
    exception_do (let: "db" := (alloc "db") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"compactionL"%go "db"))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
    let: "buf" := (alloc (type.zero_val #(mapT uint64T sliceT))) in
    let: "$r0" := (![#(mapT uint64T sliceT)] (![#ptrT] (struct.field_ref #Database #"wbuffer"%go "db"))) in
    do:  ("buf" <-[#(mapT uint64T sliceT)] "$r0");;;
    let: "emptyWbuffer" := (alloc (type.zero_val #(mapT uint64T sliceT))) in
    let: "$r0" := (map.make #sliceT) in
    do:  ("emptyWbuffer" <-[#(mapT uint64T sliceT)] "$r0");;;
    let: "$r0" := (![#(mapT uint64T sliceT)] "emptyWbuffer") in
    do:  ((![#ptrT] (struct.field_ref #Database #"wbuffer"%go "db")) <-[#(mapT uint64T sliceT)] "$r0");;;
    let: "$r0" := (![#(mapT uint64T sliceT)] "buf") in
    do:  ((![#ptrT] (struct.field_ref #Database #"rbuffer"%go "db")) <-[#(mapT uint64T sliceT)] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"tableL"%go "db"))) #());;;
    let: "oldTableName" := (alloc (type.zero_val #stringT)) in
    let: "$r0" := (![#stringT] (![#ptrT] (struct.field_ref #Database #"tableName"%go "db"))) in
    do:  ("oldTableName" <-[#stringT] "$r0");;;
    let: "t" := (alloc (type.zero_val #Table)) in
    let: "oldTable" := (alloc (type.zero_val #Table)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#Database] "db") in
    let: "$a1" := (![#(mapT uint64T sliceT)] "buf") in
    (func_call #simpledb.simpledb #"constructNewTable"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("oldTable" <-[#Table] "$r0");;;
    do:  ("t" <-[#Table] "$r1");;;
    let: "newTable" := (alloc (type.zero_val #stringT)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "oldTableName") in
    (func_call #simpledb.simpledb #"freshTable"%go) "$a0") in
    do:  ("newTable" <-[#stringT] "$r0");;;
    let: "$r0" := (![#Table] "t") in
    do:  ((![#ptrT] (struct.field_ref #Database #"table"%go "db")) <-[#Table] "$r0");;;
    let: "$r0" := (![#stringT] "newTable") in
    do:  ((![#ptrT] (struct.field_ref #Database #"tableName"%go "db")) <-[#stringT] "$r0");;;
    let: "manifestData" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (string.to_bytes (![#stringT] "newTable")) in
    do:  ("manifestData" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := #"db"%go in
    let: "$a1" := #"manifest"%go in
    let: "$a2" := (![#sliceT] "manifestData") in
    (func_call #filesys #"AtomicCreate"%go) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![#Table] "oldTable") in
    (func_call #simpledb.simpledb #"CloseTable"%go) "$a0");;;
    do:  (let: "$a0" := #"db"%go in
    let: "$a1" := (![#stringT] "oldTableName") in
    (func_call #filesys #"Delete"%go) "$a0" "$a1");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"tableL"%go "db"))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"compactionL"%go "db"))) #())).

(* go: simpledb.go:450:6 *)
Definition recoverManifest : val :=
  rec: "recoverManifest" <> :=
    exception_do (let: "f" := (alloc (type.zero_val #fileT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    let: "$a1" := #"manifest"%go in
    (func_call #filesys #"Open"%go) "$a0" "$a1") in
    do:  ("f" <-[#fileT] "$r0");;;
    let: "manifestData" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#fileT] "f") in
    let: "$a1" := #(W64 0) in
    let: "$a2" := #(W64 4096) in
    (func_call #filesys #"ReadAt"%go) "$a0" "$a1" "$a2") in
    do:  ("manifestData" <-[#sliceT] "$r0");;;
    let: "tableName" := (alloc (type.zero_val #stringT)) in
    let: "$r0" := (string.from_bytes (![#sliceT] "manifestData")) in
    do:  ("tableName" <-[#stringT] "$r0");;;
    do:  (let: "$a0" := (![#fileT] "f") in
    (func_call #filesys #"Close"%go) "$a0");;;
    return: (![#stringT] "tableName")).

(* delete 'name' if it isn't tableName or "manifest"

   go: simpledb.go:464:6 *)
Definition deleteOtherFile : val :=
  rec: "deleteOtherFile" "name" "tableName" :=
    exception_do (let: "tableName" := (alloc "tableName") in
    let: "name" := (alloc "name") in
    (if: (![#stringT] "name") = (![#stringT] "tableName")
    then return: (#())
    else do:  #());;;
    (if: (![#stringT] "name") = #"manifest"%go
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := #"db"%go in
    let: "$a1" := (![#stringT] "name") in
    (func_call #filesys #"Delete"%go) "$a0" "$a1")).

(* go: simpledb.go:474:6 *)
Definition deleteOtherFiles : val :=
  rec: "deleteOtherFiles" "tableName" :=
    exception_do (let: "tableName" := (alloc "tableName") in
    let: "files" := (alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #"db"%go in
    (func_call #filesys #"List"%go) "$a0") in
    do:  ("files" <-[#sliceT] "$r0");;;
    let: "nfiles" := (alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "files") in
    slice.len "$a0")) in
    do:  ("nfiles" <-[#uint64T] "$r0");;;
    (let: "i" := (alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![#uint64T] "i") = (![#uint64T] "nfiles")
      then break: #()
      else do:  #());;;
      let: "name" := (alloc (type.zero_val #stringT)) in
      let: "$r0" := (![#stringT] (slice.elem_ref #stringT (![#sliceT] "files") (![#uint64T] "i"))) in
      do:  ("name" <-[#stringT] "$r0");;;
      do:  (let: "$a0" := (![#stringT] "name") in
      let: "$a1" := (![#stringT] "tableName") in
      (func_call #simpledb.simpledb #"deleteOtherFile"%go) "$a0" "$a1");;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[#uint64T] "$r0");;;
      continue: #()))).

(* Recover restores a previously created database after a crash or shutdown.

   go: simpledb.go:489:6 *)
Definition Recover : val :=
  rec: "Recover" <> :=
    exception_do (let: "tableName" := (alloc (type.zero_val #stringT)) in
    let: "$r0" := ((func_call #simpledb.simpledb #"recoverManifest"%go) #()) in
    do:  ("tableName" <-[#stringT] "$r0");;;
    let: "table" := (alloc (type.zero_val #Table)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "tableName") in
    (func_call #simpledb.simpledb #"RecoverTable"%go) "$a0") in
    do:  ("table" <-[#Table] "$r0");;;
    let: "tableRef" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #Table)) in
    do:  ("tableRef" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#Table] "table") in
    do:  ((![#ptrT] "tableRef") <-[#Table] "$r0");;;
    let: "tableNameRef" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #stringT)) in
    do:  ("tableNameRef" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#stringT] "tableName") in
    do:  ((![#ptrT] "tableNameRef") <-[#stringT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "tableName") in
    (func_call #simpledb.simpledb #"deleteOtherFiles"%go) "$a0");;;
    let: "wbuffer" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #simpledb.simpledb #"makeValueBuffer"%go) #()) in
    do:  ("wbuffer" <-[#ptrT] "$r0");;;
    let: "rbuffer" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #simpledb.simpledb #"makeValueBuffer"%go) #()) in
    do:  ("rbuffer" <-[#ptrT] "$r0");;;
    let: "bufferL" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #sync.Mutex)) in
    do:  ("bufferL" <-[#ptrT] "$r0");;;
    let: "tableL" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #sync.Mutex)) in
    do:  ("tableL" <-[#ptrT] "$r0");;;
    let: "compactionL" := (alloc (type.zero_val #ptrT)) in
    let: "$r0" := (alloc (type.zero_val #sync.Mutex)) in
    do:  ("compactionL" <-[#ptrT] "$r0");;;
    return: (let: "$wbuffer" := (![#ptrT] "wbuffer") in
     let: "$rbuffer" := (![#ptrT] "rbuffer") in
     let: "$bufferL" := (![#ptrT] "bufferL") in
     let: "$table" := (![#ptrT] "tableRef") in
     let: "$tableName" := (![#ptrT] "tableNameRef") in
     let: "$tableL" := (![#ptrT] "tableL") in
     let: "$compactionL" := (![#ptrT] "compactionL") in
     struct.make #Database [{
       "wbuffer" ::= "$wbuffer";
       "rbuffer" ::= "$rbuffer";
       "bufferL" ::= "$bufferL";
       "table" ::= "$table";
       "tableName" ::= "$tableName";
       "tableL" ::= "$tableL";
       "compactionL" ::= "$compactionL"
     }])).

(* Shutdown immediately closes the database.

   Discards any uncommitted in-memory writes; similar to a crash except for
   cleanly closing any open files.

   go: simpledb.go:520:6 *)
Definition Shutdown : val :=
  rec: "Shutdown" "db" :=
    exception_do (let: "db" := (alloc "db") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Database #"compactionL"%go "db"))) #());;;
    let: "t" := (alloc (type.zero_val #Table)) in
    let: "$r0" := (![#Table] (![#ptrT] (struct.field_ref #Database #"table"%go "db"))) in
    do:  ("t" <-[#Table] "$r0");;;
    do:  (let: "$a0" := (![#Table] "t") in
    (func_call #simpledb.simpledb #"CloseTable"%go) "$a0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"compactionL"%go "db"))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Database #"bufferL"%go "db"))) #())).

(* Close closes an open database cleanly, flushing any in-memory writes.

   db should not be used afterward

   go: simpledb.go:534:6 *)
Definition Close : val :=
  rec: "Close" "db" :=
    exception_do (let: "db" := (alloc "db") in
    do:  (let: "$a0" := (![#Database] "db") in
    (func_call #simpledb.simpledb #"Compact"%go) "$a0");;;
    do:  (let: "$a0" := (![#Database] "db") in
    (func_call #simpledb.simpledb #"Shutdown"%go) "$a0")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("UseMarshal"%go, UseMarshal); ("CreateTable"%go, CreateTable); ("DecodeUInt64"%go, DecodeUInt64); ("DecodeEntry"%go, DecodeEntry); ("readTableIndex"%go, readTableIndex); ("RecoverTable"%go, RecoverTable); ("CloseTable"%go, CloseTable); ("readValue"%go, readValue); ("tableRead"%go, tableRead); ("newBuf"%go, newBuf); ("bufFlush"%go, bufFlush); ("bufAppend"%go, bufAppend); ("bufClose"%go, bufClose); ("newTableWriter"%go, newTableWriter); ("tableWriterAppend"%go, tableWriterAppend); ("tableWriterClose"%go, tableWriterClose); ("EncodeUInt64"%go, EncodeUInt64); ("EncodeSlice"%go, EncodeSlice); ("tablePut"%go, tablePut); ("makeValueBuffer"%go, makeValueBuffer); ("NewDb"%go, NewDb); ("Read"%go, Read); ("Write"%go, Write); ("freshTable"%go, freshTable); ("tablePutBuffer"%go, tablePutBuffer); ("tablePutOldTable"%go, tablePutOldTable); ("constructNewTable"%go, constructNewTable); ("Compact"%go, Compact); ("recoverManifest"%go, recoverManifest); ("deleteOtherFile"%go, deleteOtherFile); ("deleteOtherFiles"%go, deleteOtherFiles); ("Recover"%go, Recover); ("Shutdown"%go, Shutdown); ("Close"%go, Close)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Table"%go, []); ("Table'ptr"%go, []); ("Entry"%go, []); ("Entry'ptr"%go, []); ("lazyFileBuf"%go, []); ("lazyFileBuf'ptr"%go, []); ("bufFile"%go, []); ("bufFile'ptr"%go, []); ("tableWriter"%go, []); ("tableWriter'ptr"%go, []); ("Database"%go, []); ("Database'ptr"%go, [])].

#[global] Instance info' : PkgInfo simpledb.simpledb :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync; primitive; filesys; marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init simpledb.simpledb (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  filesys.initialize';;;
      do:  primitive.initialize';;;
      do:  sync.initialize')
      ).

End code.
End simpledb.
