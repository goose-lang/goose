(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest *)
From New.golang Require Import defn.
From New.code Require github_com.goose_lang.goose.machine.
From New.code Require github_com.goose_lang.goose.machine.disk.
From New.code Require github_com.tchajed.marshal.
From New.code Require log.
From New.code Require sync.

From New Require Import disk_prelude.

(* comments.go *)

(* unittest is a package full of many independent and small translation examples *)

Definition importantStruct : go_type := structT [
].

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing) *)
Definition doSubtleThings : val :=
  rec: "doSubtleThings" <> :=
    exception_do do:  #().

(* This comment starts a Coq comment ( * *)
Definition hasStartComment : val :=
  rec: "hasStartComment" <> :=
    exception_do do:  #().

(* This comment * ) ends a Coq comment *)
Definition hasEndComment : val :=
  rec: "hasEndComment" <> :=
    exception_do do:  #().

(* condvar.go *)

Definition condvarWrapping : val :=
  rec: "condvarWrapping" <> :=
    exception_do (let: "mu" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "mu" <-[ptrT] "$a0";;;
    let: "cond1" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := sync.NewCond (![ptrT] "mu") in
    do:  "cond1" <-[ptrT] "$a0";;;
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "mu" <-[ptrT] "$a0";;;
    do:  (sync.Cond__Wait (![ptrT] "cond1")) #();;;
    do:  #()).

(* const.go *)

Definition GlobalConstant : expr := #(str "foo").

(* an untyped string *)
Definition UntypedStringConstant : expr := #(str "bar").

Definition TypedInt : expr := #32.

Definition ConstWithArith : expr := #4 + (#3 * TypedInt).

Definition TypedInt32 : expr := #(U32 3).

Definition DivisionInConst : expr := (#4096 - #8) `quot` #8.

(* 517 *)
Definition ModInConst : expr := #513 + (#12 `rem` #8).

(* 5 *)
Definition ModInConstParens : expr := (#513 + #12) `rem` #8.

(* control_flow.go *)

Definition conditionalReturn : val :=
  rec: "conditionalReturn" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#0);;;
      do:  #()
    else do:  #());;;
    return: (#1);;;
    do:  #()).

Definition alwaysReturn : val :=
  rec: "alwaysReturn" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#0);;;
      do:  #()
    else
      return: (#1);;;
      do:  #());;;
    do:  #()).

Definition alwaysReturnInNestedBranches : val :=
  rec: "alwaysReturnInNestedBranches" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: (~ (![boolT] "x"))
    then
      (if: ![boolT] "x"
      then
        return: (#0);;;
        do:  #()
      else
        return: (#1);;;
        do:  #());;;
      do:  #()
    else do:  #());;;
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #14 in
    do:  "y" <-[uint64T] "$a0";;;
    return: (![uint64T] "y");;;
    do:  #()).

Definition earlyReturn : val :=
  rec: "earlyReturn" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#());;;
      do:  #()
    else do:  #());;;
    do:  #()).

Definition conditionalAssign : val :=
  rec: "conditionalAssign" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    (if: ![boolT] "x"
    then
      let: "$a0" := #1 in
      do:  "y" <-[uint64T] "$a0";;;
      do:  #()
    else
      let: "$a0" := #2 in
      do:  "y" <-[uint64T] "$a0";;;
      do:  #());;;
    do:  "y" <-[uint64T] ((![uint64T] "y") + #1);;;
    return: (![uint64T] "y");;;
    do:  #()).

Definition elseIf : val :=
  rec: "elseIf" "x" "y" :=
    exception_do (let: "y" := ref_ty boolT "y" in
    let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then
      return: (#0);;;
      do:  #()
    else
      (if: ![boolT] "y"
      then
        return: (#1);;;
        do:  #()
      else
        return: (#2);;;
        do:  #());;;
      #());;;
    do:  #()).

(* conversions.go *)

Definition stringWrapper : go_type := stringT.

Definition typedLiteral : val :=
  rec: "typedLiteral" <> :=
    exception_do (return: (#3);;;
    do:  #()).

Definition literalCast : val :=
  rec: "literalCast" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #2 in
    do:  "x" <-[uint64T] "$a0";;;
    return: ((![uint64T] "x") + #2);;;
    do:  #()).

Definition castInt : val :=
  rec: "castInt" "p" :=
    exception_do (let: "p" := ref_ty (sliceT byteT) "p" in
    return: (slice.len (![sliceT byteT] "p"));;;
    do:  #()).

Definition stringToByteSlice : val :=
  rec: "stringToByteSlice" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    let: "p" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := StringToBytes (![stringT] "s") in
    do:  "p" <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "p");;;
    do:  #()).

Definition byteSliceToString : val :=
  rec: "byteSliceToString" "p" :=
    exception_do (let: "p" := ref_ty (sliceT byteT) "p" in
    let: "s" := ref_ty stringT (zero_val stringT) in
    let: "$a0" := StringFromBytes (![sliceT byteT] "p") in
    do:  "s" <-[stringT] "$a0";;;
    return: (![stringT] "s");;;
    do:  #()).

Definition stringToStringWrapper : val :=
  rec: "stringToStringWrapper" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    return: (![stringT] "s");;;
    do:  #()).

Definition stringWrapperToString : val :=
  rec: "stringWrapperToString" "s" :=
    exception_do (let: "s" := ref_ty stringWrapper "s" in
    return: (![stringWrapper] "s");;;
    do:  #()).

(* copy.go *)

Definition testCopySimple : val :=
  rec: "testCopySimple" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #10 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 1) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #3) <-[byteT] "$a0";;;
    let: "y" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #10 in
    do:  "y" <-[sliceT byteT] "$a0";;;
    do:  slice.copy byteT (![sliceT byteT] "y") (![sliceT byteT] "x");;;
    return: ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #3)) = #(U8 1));;;
    do:  #()).

Definition testCopyDifferentLengths : val :=
  rec: "testCopyDifferentLengths" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #15 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 1) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #3) <-[byteT] "$a0";;;
    let: "$a0" := #(U8 2) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #12) <-[byteT] "$a0";;;
    let: "y" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #10 in
    do:  "y" <-[sliceT byteT] "$a0";;;
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := slice.copy byteT (![sliceT byteT] "y") (![sliceT byteT] "x") in
    do:  "n" <-[uint64T] "$a0";;;
    return: (((![uint64T] "n") = #10) && ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #3)) = #(U8 1)));;;
    do:  #()).

(* data_structures.go *)

Definition atomicCreateStub : val :=
  rec: "atomicCreateStub" "dir" "fname" "data" :=
    exception_do (let: "data" := ref_ty (sliceT byteT) "data" in
    let: "fname" := ref_ty stringT "fname" in
    let: "dir" := ref_ty stringT "dir" in
    do:  #()).

Definition useSlice : val :=
  rec: "useSlice" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #1 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    let: "s1" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.append byteT (![sliceT byteT] "s") (![sliceT byteT] "s") in
    do:  "s1" <-[sliceT byteT] "$a0";;;
    do:  atomicCreateStub #(str "dir") #(str "file") (![sliceT byteT] "s1");;;
    do:  #()).

Definition useSliceIndexing : val :=
  rec: "useSliceIndexing" <> :=
    exception_do (let: "s" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := slice.make2 uint64T #2 in
    do:  "s" <-[sliceT uint64T] "$a0";;;
    let: "$a0" := #2 in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "s") #1) <-[uint64T] "$a0";;;
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "s") #0) in
    do:  "x" <-[uint64T] "$a0";;;
    return: (![uint64T] "x");;;
    do:  #()).

Definition useMap : val :=
  rec: "useMap" <> :=
    exception_do (let: "m" := ref_ty (mapT uint64T (sliceT byteT)) (zero_val (mapT uint64T (sliceT byteT))) in
    let: "$a0" := map.make uint64T (sliceT byteT) #() in
    do:  "m" <-[mapT uint64T (sliceT byteT)] "$a0";;;
    let: "$a0" := slice.nil in
    do:  map.insert (![mapT uint64T (sliceT byteT)] "m") #1 "$a0";;;
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: ("$a0", "$a1") := Fst (map.get (![mapT uint64T (sliceT byteT)] "m") #2) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "x" <-[sliceT byteT] "$a0";;;
    (if: ![boolT] "ok"
    then
      return: (#());;;
      do:  #()
    else do:  #());;;
    let: "$a0" := ![sliceT byteT] "x" in
    do:  map.insert (![mapT uint64T (sliceT byteT)] "m") #3 "$a0";;;
    do:  #()).

Definition usePtr : val :=
  rec: "usePtr" <> :=
    exception_do (let: "p" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "p" <-[ptrT] "$a0";;;
    let: "$a0" := #1 in
    do:  (![ptrT] "p") <-[uint64T] "$a0";;;
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] "p") in
    do:  "x" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "x" in
    do:  (![ptrT] "p") <-[uint64T] "$a0";;;
    do:  #()).

Definition iterMapKeysAndValues : val :=
  rec: "iterMapKeysAndValues" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    let: "sumPtr" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "sumPtr" <-[ptrT] "$a0";;;
    do:  MapIter (![mapT uint64T uint64T] "m") (λ: "k" "v",
      let: "sum" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
      do:  "sum" <-[uint64T] "$a0";;;
      let: "$a0" := ((![uint64T] "sum") + (![uint64T] "k")) + (![uint64T] "v") in
      do:  (![ptrT] "sumPtr") <-[uint64T] "$a0";;;
      do:  #());;;
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
    do:  "sum" <-[uint64T] "$a0";;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition iterMapKeys : val :=
  rec: "iterMapKeys" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    let: "keysSlice" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := slice.make2 uint64T #0 in
    do:  "keysSlice" <-[sliceT uint64T] "$a0";;;
    let: "keysRef" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    do:  "keysRef" <-[ptrT] "$a0";;;
    let: "$a0" := ![sliceT uint64T] "keysSlice" in
    do:  (![ptrT] "keysRef") <-[sliceT uint64T] "$a0";;;
    do:  MapIter (![mapT uint64T uint64T] "m") (λ: "k" <>,
      let: "keys" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
      let: "$a0" := ![sliceT uint64T] (![ptrT] "keysRef") in
      do:  "keys" <-[sliceT uint64T] "$a0";;;
      let: "newKeys" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
      let: "$a0" := slice.append uint64T (![sliceT uint64T] "keys") (slice.literal uint64T [![uint64T] "k"]) in
      do:  "newKeys" <-[sliceT uint64T] "$a0";;;
      let: "$a0" := ![sliceT uint64T] "newKeys" in
      do:  (![ptrT] "keysRef") <-[sliceT uint64T] "$a0";;;
      do:  #());;;
    let: "keys" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := ![sliceT uint64T] (![ptrT] "keysRef") in
    do:  "keys" <-[sliceT uint64T] "$a0";;;
    return: (![sliceT uint64T] "keys");;;
    do:  #()).

Definition getRandom : val :=
  rec: "getRandom" <> :=
    exception_do (let: "r" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := machine.RandomUint64 #() in
    do:  "r" <-[uint64T] "$a0";;;
    return: (![uint64T] "r");;;
    do:  #()).

(* disk.go *)

Definition diskWrapper : go_type := structT [
  "d" :: disk.Disk
].

Definition diskArgument : val :=
  rec: "diskArgument" "d" :=
    exception_do (let: "d" := ref_ty disk.Disk "d" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := (__Read (![disk.Disk] "d")) #0 in
    do:  "b" <-[sliceT byteT] "$a0";;;
    do:  (__Write (![disk.Disk] "d")) #1 (![sliceT byteT] "b");;;
    do:  #()).

(* empty_functions.go *)

Definition empty : val :=
  rec: "empty" <> :=
    exception_do do:  #().

Definition emptyReturn : val :=
  rec: "emptyReturn" <> :=
    exception_do (return: (#());;;
    do:  #()).

(* encoding.go *)

Definition Enc : go_type := structT [
  "p" :: sliceT byteT
].

Definition Enc__consume : val :=
  rec: "Enc__consume" "e" "n" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "n" := ref_ty uint64T "n" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Enc "p" (![ptrT] "e")) in
    slice.slice byteT "$s" #0 (![uint64T] "n") in
    do:  "b" <-[sliceT byteT] "$a0";;;
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Enc "p" (![ptrT] "e")) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s") in
    do:  (struct.field_ref Enc "p" (![ptrT] "e")) <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "b");;;
    do:  #()).

Definition Enc__UInt64 : val :=
  rec: "Enc__UInt64" "e" "x" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "x" := ref_ty uint64T "x" in
    do:  machine.UInt64Put ((Enc__consume (![ptrT] "e")) #8) (![uint64T] "x");;;
    do:  #()).

Definition Enc__UInt32 : val :=
  rec: "Enc__UInt32" "e" "x" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "x" := ref_ty uint32T "x" in
    do:  machine.UInt32Put ((Enc__consume (![ptrT] "e")) #4) (![uint32T] "x");;;
    do:  #()).

Definition Dec : go_type := structT [
  "p" :: sliceT byteT
].

Definition Dec__consume : val :=
  rec: "Dec__consume" "d" "n" :=
    exception_do (let: "d" := ref_ty ptrT "d" in
    let: "n" := ref_ty uint64T "n" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Dec "p" (![ptrT] "d")) in
    slice.slice byteT "$s" #0 (![uint64T] "n") in
    do:  "b" <-[sliceT byteT] "$a0";;;
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Dec "p" (![ptrT] "d")) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s") in
    do:  (struct.field_ref Dec "p" (![ptrT] "d")) <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "b");;;
    do:  #()).

Definition Dec__UInt64 : val :=
  rec: "Dec__UInt64" "d" <> :=
    exception_do (let: "d" := ref_ty ptrT "d" in
    return: (machine.UInt64Get ((Dec__consume (![ptrT] "d")) #8));;;
    do:  #()).

Definition Dec__UInt32 : val :=
  rec: "Dec__UInt32" "d" <> :=
    exception_do (let: "d" := ref_ty ptrT "d" in
    return: (machine.UInt32Get ((Dec__consume (![ptrT] "d")) #4));;;
    do:  #()).

(* higher_order.go *)

Definition TakesFunctionType : val :=
  rec: "TakesFunctionType" "f" :=
    exception_do (let: "f" := ref_ty funcT "f" in
    do:  (![funcT] "f") #();;;
    do:  #()).

(* interfaces.go *)

Definition Fooer : go_type := interfaceT.

Definition concreteFooer : go_type := structT [
  "a" :: uint64T
].

Definition concreteFooer__Foo : val :=
  rec: "concreteFooer__Foo" "f" <> :=
    exception_do (let: "f" := ref_ty ptrT "f" in
    do:  #()).

Definition fooConsumer : val :=
  rec: "fooConsumer" "f" :=
    exception_do (let: "f" := ref_ty Fooer "f" in
    do:  (__Foo (![Fooer] "f")) #();;;
    do:  #()).

Definition m : val :=
  rec: "m" <> :=
    exception_do (let: "c" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty concreteFooer (struct.make concreteFooer [{
    }]) in
    do:  "c" <-[ptrT] "$a0";;;
    do:  fooConsumer (![ptrT] "c");;;
    let: "f" := ref_ty ptrT (![ptrT] "c") in
    do:  fooConsumer (![Fooer] "f");;;
    do:  (concreteFooer__Foo (![ptrT] "c")) #();;;
    do:  (__Foo (![Fooer] "f")) #();;;
    do:  #()).

(* ints.go *)

Definition useInts : val :=
  rec: "useInts" "x" "y" :=
    exception_do (let: "y" := ref_ty uint32T "y" in
    let: "x" := ref_ty uint64T "x" in
    let: "z" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := to_u64 (![uint32T] "y") in
    do:  "z" <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] "z") + #1 in
    do:  "z" <-[uint64T] "$a0";;;
    let: "y2" := ref_ty uint32T (zero_val uint32T) in
    let: "$a0" := (![uint32T] "y") + #(U32 3) in
    do:  "y2" <-[uint32T] "$a0";;;
    return: (![uint64T] "z", ![uint32T] "y2");;;
    do:  #()).

Definition my_u32 : go_type := uint32T.

Definition also_u32 : go_type := my_u32.

Definition ConstWithAbbrevType : expr := #(U32 3).

(* literals.go *)

Definition allTheLiterals : go_type := structT [
  "int" :: uint64T;
  "s" :: stringT;
  "b" :: boolT
].

Definition normalLiterals : val :=
  rec: "normalLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #0;
       "s" ::= #(str "foo");
       "b" ::= #true
     }]);;;
    do:  #()).

Definition specialLiterals : val :=
  rec: "specialLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #4096;
       "s" ::= #(str "");
       "b" ::= #false
     }]);;;
    do:  #()).

Definition oddLiterals : val :=
  rec: "oddLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #5;
       "s" ::= #(str "backquote string");
       "b" ::= #false
     }]);;;
    do:  #()).

Definition unKeyedLiteral : val :=
  rec: "unKeyedLiteral" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #0;
       "s" ::= #(str "a");
       "b" ::= #false
     }]);;;
    do:  #()).

(* locks.go *)

Definition useLocks : val :=
  rec: "useLocks" <> :=
    exception_do (let: "m" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "m" <-[ptrT] "$a0";;;
    do:  (sync.Mutex__Lock (![ptrT] "m")) #();;;
    do:  (sync.Mutex__Unlock (![ptrT] "m")) #();;;
    do:  #()).

Definition useCondVar : val :=
  rec: "useCondVar" <> :=
    exception_do (let: "m" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "m" <-[ptrT] "$a0";;;
    let: "c" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := sync.NewCond (![ptrT] "m") in
    do:  "c" <-[ptrT] "$a0";;;
    do:  (sync.Mutex__Lock (![ptrT] "m")) #();;;
    do:  (sync.Cond__Signal (![ptrT] "c")) #();;;
    do:  (sync.Cond__Wait (![ptrT] "c")) #();;;
    do:  (sync.Mutex__Unlock (![ptrT] "m")) #();;;
    do:  #()).

Definition hasCondVar : go_type := structT [
  "cond" :: ptrT
].

(* log_debugging.go *)

Definition ToBeDebugged : val :=
  rec: "ToBeDebugged" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    do:  log.Println #(str "starting function");;;
    do:  log.Printf #(str "called with %!!(MISSING)d(MISSING)") (![uint64T] "x");;;
    do:  log.Println #(str "ending function");;;
    return: (![uint64T] "x");;;
    do:  #()).

Definition DoNothing : val :=
  rec: "DoNothing" <> :=
    exception_do (do:  log.Println #(str "doing nothing");;;
    do:  #()).

(* loops.go *)

(* DoSomething is an impure function *)
Definition DoSomething : val :=
  rec: "DoSomething" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    do:  #()).

Definition standardForLoop : val :=
  rec: "standardForLoop" "s" :=
    exception_do (let: "s" := ref_ty (sliceT uint64T) "s" in
    let: "sumPtr" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "sumPtr" <-[ptrT] "$a0";;;
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (slice.len (![sliceT uint64T] "s"))
      then
        let: "sum" := ref_ty uint64T (zero_val uint64T) in
        let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
        do:  "sum" <-[uint64T] "$a0";;;
        let: "x" := ref_ty uint64T (zero_val uint64T) in
        let: "$a0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "s") (![uint64T] "i")) in
        do:  "x" <-[uint64T] "$a0";;;
        let: "$a0" := (![uint64T] "sum") + (![uint64T] "x") in
        do:  (![ptrT] "sumPtr") <-[uint64T] "$a0";;;
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()
      else do:  #());;;
      break: #();;;
      do:  #()));;;
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
    do:  "sum" <-[uint64T] "$a0";;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition conditionalInLoop : val :=
  rec: "conditionalInLoop" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #3
      then
        do:  DoSomething #(str "i is small");;;
        do:  #()
      else do:  #());;;
      (if: (![uint64T] "i") > #5
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] "i") + #1 in
      do:  "i" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

Definition conditionalInLoopElse : val :=
  rec: "conditionalInLoopElse" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #5
      then
        break: #();;;
        do:  #()
      else
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #());;;
      do:  #()));;;
    do:  #()).

Definition nestedConditionalInLoopImplicitContinue : val :=
  rec: "nestedConditionalInLoopImplicitContinue" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #5
      then
        (if: (![uint64T] "i") > #10
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        do:  #()
      else
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #());;;
      do:  #()));;;
    do:  #()).

Definition ImplicitLoopContinue : val :=
  rec: "ImplicitLoopContinue" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #4
      then
        let: "$a0" := #0 in
        do:  "i" <-[uint64T] "$a0";;;
        do:  #()
      else do:  #());;;
      do:  #()));;;
    do:  #()).

Definition ImplicitLoopContinue2 : val :=
  rec: "ImplicitLoopContinue2" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #4
      then
        let: "$a0" := #0 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()
      else do:  #());;;
      do:  #()));;;
    do:  #()).

Definition ImplicitLoopContinueAfterIfBreak : val :=
  rec: "ImplicitLoopContinueAfterIfBreak" "i" :=
    exception_do (let: "i" := ref_ty uint64T "i" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #0
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      do:  #());;;
    do:  #()).

Definition nestedLoops : val :=
  rec: "nestedLoops" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (let: "j" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := #0 in
      do:  "j" <-[uint64T] "$a0";;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: #true
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        let: "$a0" := (![uint64T] "j") + #1 in
        do:  "j" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()));;;
      let: "$a0" := (![uint64T] "i") + #1 in
      do:  "i" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

Definition nestedGoStyleLoops : val :=
  rec: "nestedGoStyleLoops" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      (let: "j" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := #0 in
      do:  "j" <-[uint64T] "$a0";;;
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, do:  "j" <-[uint64T] ((![uint64T] "j") + #1);;;
      #()) := λ: <>,
        (if: #true
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        continue: #();;;
        do:  #()));;;
      do:  #()));;;
    do:  #()).

Definition sumSlice : val :=
  rec: "sumSlice" "xs" :=
    exception_do (let: "xs" := ref_ty (sliceT uint64T) "xs" in
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    do:  let: "$range" := ![sliceT uint64T] "xs" in
    slice.for_range uint64T "$range" (λ: <> "x",
      let: "x" := ref_ty uint64T "x" in
      do:  "sum" <-[uint64T] ((![uint64T] "sum") + (![uint64T] "x"));;;
      do:  #());;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition breakFromLoop : val :=
  rec: "breakFromLoop" <> :=
    exception_do ((for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      continue: #();;;
      do:  #());;;
    do:  #()).

(* maps.go *)

Definition clearMap : val :=
  rec: "clearMap" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    do:  machine.MapClear (![mapT uint64T uint64T] "m");;;
    do:  #()).

Definition IterateMapKeys : val :=
  rec: "IterateMapKeys" "m" "sum" :=
    exception_do (let: "sum" := ref_ty ptrT "sum" in
    let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    do:  MapIter (![mapT uint64T uint64T] "m") (λ: "k" <>,
      let: "oldSum" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := ![uint64T] (![ptrT] "sum") in
      do:  "oldSum" <-[uint64T] "$a0";;;
      let: "$a0" := (![uint64T] "oldSum") + (![uint64T] "k") in
      do:  (![ptrT] "sum") <-[uint64T] "$a0";;;
      do:  #());;;
    do:  #()).

Definition MapSize : val :=
  rec: "MapSize" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T boolT) "m" in
    return: (MapLen (![mapT uint64T boolT] "m"));;;
    do:  #()).

Definition IntWrapper : go_type := uint64T.

Definition MapWrapper : go_type := mapT uint64T boolT.

Definition MapTypeAliases : val :=
  rec: "MapTypeAliases" "m1" "m2" :=
    exception_do (let: "m2" := ref_ty MapWrapper "m2" in
    let: "m1" := ref_ty (mapT IntWrapper boolT) "m1" in
    let: "$a0" := Fst (map.get (![MapWrapper] "m2") #0) in
    do:  map.insert (![mapT IntWrapper boolT] "m1") #4 "$a0";;;
    do:  #()).

Definition StringMap : val :=
  rec: "StringMap" "m" :=
    exception_do (let: "m" := ref_ty (mapT stringT uint64T) "m" in
    return: (Fst (map.get (![mapT stringT uint64T] "m") #(str "foo")));;;
    do:  #()).

(* multiple.go *)

Definition returnTwo : val :=
  rec: "returnTwo" "p" :=
    exception_do (let: "p" := ref_ty (sliceT byteT) "p" in
    return: (#0, #0);;;
    do:  #()).

Definition returnTwoWrapper : val :=
  rec: "returnTwoWrapper" "data" :=
    exception_do (let: "data" := ref_ty (sliceT byteT) "data" in
    let: "b" := ref_ty uint64T (zero_val uint64T) in
    let: "a" := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := returnTwo (![sliceT byteT] "data") in
    do:  "b" <-[uint64T] "$a1";;;
    do:  "a" <-[uint64T] "$a0";;;
    return: (![uint64T] "a", ![uint64T] "b");;;
    do:  #()).

Definition multipleVar : val :=
  rec: "multipleVar" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint64T "x" in
    do:  #()).

(* nil.go *)

Definition AssignNilSlice : val :=
  rec: "AssignNilSlice" <> :=
    exception_do (let: "s" := ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT))) in
    let: "$a0" := slice.make2 (sliceT byteT) #4 in
    do:  "s" <-[sliceT (sliceT byteT)] "$a0";;;
    let: "$a0" := slice.nil in
    do:  (slice.elem_ref (sliceT byteT) (![sliceT (sliceT byteT)] "s") #2) <-[sliceT byteT] "$a0";;;
    do:  #()).

Definition AssignNilPointer : val :=
  rec: "AssignNilPointer" <> :=
    exception_do (let: "s" := ref_ty (sliceT ptrT) (zero_val (sliceT ptrT)) in
    let: "$a0" := slice.make2 ptrT #4 in
    do:  "s" <-[sliceT ptrT] "$a0";;;
    let: "$a0" := slice.nil in
    do:  (slice.elem_ref ptrT (![sliceT ptrT] "s") #2) <-[ptrT] "$a0";;;
    do:  #()).

Definition CompareSliceToNil : val :=
  rec: "CompareSliceToNil" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #0 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    return: ((![sliceT byteT] "s") ≠ slice.nil);;;
    do:  #()).

Definition ComparePointerToNil : val :=
  rec: "ComparePointerToNil" <> :=
    exception_do (let: "s" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "s" <-[ptrT] "$a0";;;
    return: ((![ptrT] "s") ≠ #null);;;
    do:  #()).

(* operators.go *)

Definition LogicalOperators : val :=
  rec: "LogicalOperators" "b1" "b2" :=
    exception_do (let: "b2" := ref_ty boolT "b2" in
    let: "b1" := ref_ty boolT "b1" in
    return: (((![boolT] "b1") && ((![boolT] "b2") || (![boolT] "b1"))) && (~ #false));;;
    do:  #()).

Definition LogicalAndEqualityOperators : val :=
  rec: "LogicalAndEqualityOperators" "b1" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "b1" := ref_ty boolT "b1" in
    return: (((![uint64T] "x") = #3) && ((![boolT] "b1") = #true));;;
    do:  #()).

Definition ArithmeticShifts : val :=
  rec: "ArithmeticShifts" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint32T "x" in
    return: (((to_u64 ((![uint32T] "x") ≪ #3)) + ((![uint64T] "y") ≪ (to_u64 (![uint32T] "x")))) + ((![uint64T] "y") ≪ #1));;;
    do:  #()).

Definition BitwiseOps : val :=
  rec: "BitwiseOps" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint32T "x" in
    return: ((to_u64 (![uint32T] "x")) `or` ((to_u64 (to_u32 (![uint64T] "y"))) `and` #43));;;
    do:  #()).

Definition Comparison : val :=
  rec: "Comparison" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint64T "x" in
    (if: (![uint64T] "x") < (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] "x") = (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] "x") ≠ (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] "x") > (![uint64T] "y")
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    (if: ((![uint64T] "x") + #1) > ((![uint64T] "y") - #2)
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    return: (#false);;;
    do:  #()).

Definition AssignOps : val :=
  rec: "AssignOps" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    do:  "x" <-[uint64T] ((![uint64T] "x") + #3);;;
    do:  "x" <-[uint64T] ((![uint64T] "x") - #3);;;
    do:  "x" <-[uint64T] ((![uint64T] "x") + #1);;;
    do:  "x" <-[uint64T] ((![uint64T] "x") - #1);;;
    do:  #()).

(* package.go *)

(* unittest has two package comments *)

Definition wrapExternalStruct : go_type := structT [
  "e" :: marshal.Enc;
  "d" :: marshal.Dec
].

Definition wrapExternalStruct__moveUint64 : val :=
  rec: "wrapExternalStruct__moveUint64" "w" <> :=
    exception_do (let: "w" := ref_ty wrapExternalStruct "w" in
    do:  (marshal.Enc__PutInt (![marshal.Enc] (struct.field_ref wrapExternalStruct "e" "w"))) ((marshal.Dec__GetInt (![marshal.Dec] (struct.field_ref wrapExternalStruct "d" "w"))) #());;;
    do:  #()).

(* panic.go *)

Definition PanicAtTheDisco : val :=
  rec: "PanicAtTheDisco" <> :=
    exception_do (do:  Panic "disco";;;
    do:  #()).

(* proph.go *)

Definition Oracle : val :=
  rec: "Oracle" <> :=
    exception_do (let: "p" := ref_ty ProphIdT (zero_val ProphIdT) in
    let: "$a0" := machine.NewProph #() in
    do:  "p" <-[ProphIdT] "$a0";;;
    do:  (machine.prophId__ResolveBool (![ProphIdT] "p")) #false;;;
    do:  (machine.prophId__ResolveU64 (![ProphIdT] "p")) #0;;;
    do:  #()).

Definition typing : go_type := structT [
  "proph" :: ProphIdT
].

(* reassign.go *)

Definition composite : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition ReassignVars : val :=
  rec: "ReassignVars" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "y" <-[uint64T] "$a0";;;
    let: "$a0" := #3 in
    do:  "x" <-[uint64T] "$a0";;;
    let: "z" := ref_ty composite (struct.make composite [{
      "a" ::= ![uint64T] "x";
      "b" ::= ![uint64T] "y"
    }]) in
    let: "$a0" := struct.make composite [{
      "a" ::= ![uint64T] "y";
      "b" ::= ![uint64T] "x"
    }] in
    do:  "z" <-[composite] "$a0";;;
    let: "$a0" := ![uint64T] (struct.field_ref composite "a" "z") in
    do:  "x" <-[uint64T] "$a0";;;
    do:  #()).

(* replicated_disk.go *)

Definition Block : go_type := structT [
  "Value" :: uint64T
].

Definition Disk1 : expr := #0.

Definition Disk2 : expr := #0.

Definition DiskSize : expr := #1000.

(* TwoDiskWrite is a dummy function to represent the base layer's disk write *)
Definition TwoDiskWrite : val :=
  rec: "TwoDiskWrite" "diskId" "a" "v" :=
    exception_do (let: "v" := ref_ty Block "v" in
    let: "a" := ref_ty uint64T "a" in
    let: "diskId" := ref_ty uint64T "diskId" in
    return: (#true);;;
    do:  #()).

(* TwoDiskRead is a dummy function to represent the base layer's disk read *)
Definition TwoDiskRead : val :=
  rec: "TwoDiskRead" "diskId" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    let: "diskId" := ref_ty uint64T "diskId" in
    return: (struct.make Block [{
       "Value" ::= #0
     }], #true);;;
    do:  #()).

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer *)
Definition TwoDiskLock : val :=
  rec: "TwoDiskLock" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    do:  #()).

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer *)
Definition TwoDiskUnlock : val :=
  rec: "TwoDiskUnlock" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    do:  #()).

Definition ReplicatedDiskRead : val :=
  rec: "ReplicatedDiskRead" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    do:  TwoDiskLock (![uint64T] "a");;;
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "v" := ref_ty Block (zero_val Block) in
    let: ("$a0", "$a1") := TwoDiskRead Disk1 (![uint64T] "a") in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v" <-[Block] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  TwoDiskUnlock (![uint64T] "a");;;
      return: (![Block] "v");;;
      do:  #()
    else do:  #());;;
    let: <> := ref_ty boolT (zero_val boolT) in
    let: "v2" := ref_ty Block (zero_val Block) in
    let: ("$a0", "$a1") := TwoDiskRead Disk2 (![uint64T] "a") in
    do:  "$a1";;;
    do:  "v2" <-[Block] "$a0";;;
    do:  TwoDiskUnlock (![uint64T] "a");;;
    return: (![Block] "v2");;;
    do:  #()).

Definition ReplicatedDiskWrite : val :=
  rec: "ReplicatedDiskWrite" "a" "v" :=
    exception_do (let: "v" := ref_ty Block "v" in
    let: "a" := ref_ty uint64T "a" in
    do:  TwoDiskLock (![uint64T] "a");;;
    do:  TwoDiskWrite Disk1 (![uint64T] "a") (![Block] "v");;;
    do:  TwoDiskWrite Disk2 (![uint64T] "a") (![Block] "v");;;
    do:  TwoDiskUnlock (![uint64T] "a");;;
    do:  #()).

Definition ReplicatedDiskRecover : val :=
  rec: "ReplicatedDiskRecover" <> :=
    exception_do ((let: "a" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "a" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "a") > DiskSize
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "ok" := ref_ty boolT (zero_val boolT) in
      let: "v" := ref_ty Block (zero_val Block) in
      let: ("$a0", "$a1") := TwoDiskRead Disk1 (![uint64T] "a") in
      do:  "ok" <-[boolT] "$a1";;;
      do:  "v" <-[Block] "$a0";;;
      (if: ![boolT] "ok"
      then
        do:  TwoDiskWrite Disk2 (![uint64T] "a") (![Block] "v");;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] "a") + #1 in
      do:  "a" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

(* slices.go *)

Definition SliceAlias : go_type := sliceT boolT.

Definition sliceOps : val :=
  rec: "sliceOps" <> :=
    exception_do (let: "x" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := slice.make2 uint64T #10 in
    do:  "x" <-[sliceT uint64T] "$a0";;;
    let: "v1" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "x") #2) in
    do:  "v1" <-[uint64T] "$a0";;;
    let: "v2" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #2 #3 in
    do:  "v2" <-[sliceT uint64T] "$a0";;;
    let: "v3" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #0 #3 in
    do:  "v3" <-[sliceT uint64T] "$a0";;;
    let: "v4" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := SliceRef uint64T (![sliceT uint64T] "x") #2 in
    do:  "v4" <-[ptrT] "$a0";;;
    return: ((((((![uint64T] "v1") + (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "v2") #0))) + (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "v3") #1))) + (![uint64T] (![ptrT] "v4"))) + (slice.len (![sliceT uint64T] "x"))) + (slice.cap (![sliceT uint64T] "x")));;;
    do:  #()).

Definition makeSingletonSlice : val :=
  rec: "makeSingletonSlice" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    return: (slice.literal uint64T [![uint64T] "x"]);;;
    do:  #()).

Definition thing : go_type := structT [
  "x" :: uint64T
].

Definition sliceOfThings : go_type := structT [
  "things" :: sliceT thing
].

Definition sliceOfThings__getThingRef : val :=
  rec: "sliceOfThings__getThingRef" "ts" "i" :=
    exception_do (let: "ts" := ref_ty sliceOfThings "ts" in
    let: "i" := ref_ty uint64T "i" in
    return: (SliceRef thing (![sliceT thing] (struct.field_ref sliceOfThings "things" "ts")) (![uint64T] "i"));;;
    do:  #()).

Definition makeAlias : val :=
  rec: "makeAlias" <> :=
    exception_do (return: (slice.make2 boolT #10);;;
    do:  #()).

(* spawn.go *)

(* Skip is a placeholder for some impure code *)
Definition Skip : val :=
  rec: "Skip" <> :=
    exception_do do:  #().

Definition simpleSpawn : val :=
  rec: "simpleSpawn" <> :=
    exception_do (let: "l" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "l" <-[ptrT] "$a0";;;
    let: "v" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "v" <-[ptrT] "$a0";;;
    let: "$go" := (λ: <>,
      do:  (sync.Mutex__Lock (![ptrT] "l")) #();;;
      let: "x" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := ![uint64T] (![ptrT] "v") in
      do:  "x" <-[uint64T] "$a0";;;
      (if: (![uint64T] "x") > #0
      then
        do:  Skip #();;;
        do:  #()
      else do:  #());;;
      do:  (sync.Mutex__Unlock (![ptrT] "l")) #();;;
      do:  #()
      ) in
    do:  Fork ("$go" #());;;
    do:  (sync.Mutex__Lock (![ptrT] "l")) #();;;
    let: "$a0" := #1 in
    do:  (![ptrT] "v") <-[uint64T] "$a0";;;
    do:  (sync.Mutex__Unlock (![ptrT] "l")) #();;;
    do:  #()).

Definition threadCode : val :=
  rec: "threadCode" "tid" :=
    exception_do (let: "tid" := ref_ty uint64T "tid" in
    do:  #()).

Definition loopSpawn : val :=
  rec: "loopSpawn" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "i" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := ![uint64T] "i" in
      do:  "i" <-[uint64T] "$a0";;;
      let: "$go" := (λ: <>,
        do:  threadCode (![uint64T] "i");;;
        do:  #()
        ) in
      do:  Fork ("$go" #());;;
      do:  #()));;;
    (let: "dummy" := ref_ty boolT (zero_val boolT) in
    let: "$a0" := #true in
    do:  "dummy" <-[boolT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "$a0" := (~ (![boolT] "dummy")) in
      do:  "dummy" <-[boolT] "$a0";;;
      continue: #();;;
      do:  #()));;;
    do:  #()).

(* strings.go *)

Definition stringAppend : val :=
  rec: "stringAppend" "s" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "s" := ref_ty stringT "s" in
    return: (((#(str "prefix ") + (![stringT] "s")) + #(str " ")) + (machine.UInt64ToString (![uint64T] "x")));;;
    do:  #()).

Definition stringLength : val :=
  rec: "stringLength" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    return: (StringLength (![stringT] "s"));;;
    do:  #()).

(* struct_method.go *)

Definition Point : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition Point__Add : val :=
  rec: "Point__Add" "c" "z" :=
    exception_do (let: "c" := ref_ty Point "c" in
    let: "z" := ref_ty uint64T "z" in
    return: (((![uint64T] (struct.field_ref Point "x" "c")) + (![uint64T] (struct.field_ref Point "y" "c"))) + (![uint64T] "z"));;;
    do:  #()).

Definition Point__GetField : val :=
  rec: "Point__GetField" "c" <> :=
    exception_do (let: "c" := ref_ty Point "c" in
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (struct.field_ref Point "x" "c") in
    do:  "x" <-[uint64T] "$a0";;;
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (struct.field_ref Point "y" "c") in
    do:  "y" <-[uint64T] "$a0";;;
    return: ((![uint64T] "x") + (![uint64T] "y"));;;
    do:  #()).

Definition UseAdd : val :=
  rec: "UseAdd" <> :=
    exception_do (let: "c" := ref_ty Point (zero_val Point) in
    let: "$a0" := struct.make Point [{
      "x" ::= #2;
      "y" ::= #3
    }] in
    do:  "c" <-[Point] "$a0";;;
    let: "r" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := (Point__Add (![Point] "c")) #4 in
    do:  "r" <-[uint64T] "$a0";;;
    return: (![uint64T] "r");;;
    do:  #()).

Definition UseAddWithLiteral : val :=
  rec: "UseAddWithLiteral" <> :=
    exception_do (let: "r" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := (Point__Add (struct.make Point [{
      "x" ::= #2;
      "y" ::= #3
    }])) #4 in
    do:  "r" <-[uint64T] "$a0";;;
    return: (![uint64T] "r");;;
    do:  #()).

(* struct_pointers.go *)

Definition TwoInts : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition S : go_type := structT [
  "a" :: uint64T;
  "b" :: TwoInts;
  "c" :: boolT
].

Definition NewS : val :=
  rec: "NewS" <> :=
    exception_do (return: (ref_ty S (struct.make S [{
       "a" ::= #2;
       "b" ::= struct.make TwoInts [{
         "x" ::= #1;
         "y" ::= #2
       }];
       "c" ::= #true
     }]));;;
    do:  #()).

Definition S__readA : val :=
  rec: "S__readA" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (![uint64T] (struct.field_ref S "a" (![ptrT] "s")));;;
    do:  #()).

Definition S__readB : val :=
  rec: "S__readB" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (![TwoInts] (struct.field_ref S "b" (![ptrT] "s")));;;
    do:  #()).

Definition S__readBVal : val :=
  rec: "S__readBVal" "s" <> :=
    exception_do (let: "s" := ref_ty S "s" in
    return: (![TwoInts] (struct.field_ref S "b" "s"));;;
    do:  #()).

Definition S__writeB : val :=
  rec: "S__writeB" "s" "two" :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    let: "two" := ref_ty TwoInts "two" in
    let: "$a0" := ![TwoInts] "two" in
    do:  (struct.field_ref S "b" (![ptrT] "s")) <-[TwoInts] "$a0";;;
    do:  #()).

Definition S__negateC : val :=
  rec: "S__negateC" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    let: "$a0" := (~ (![boolT] (struct.field_ref S "c" (![ptrT] "s")))) in
    do:  (struct.field_ref S "c" (![ptrT] "s")) <-[boolT] "$a0";;;
    do:  #()).

Definition S__refC : val :=
  rec: "S__refC" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (struct.field_ref S "c" (![ptrT] "s"));;;
    do:  #()).

Definition localSRef : val :=
  rec: "localSRef" <> :=
    exception_do (let: "s" := ref_ty S (zero_val S) in
    return: (struct.field_ref S "b" "s");;;
    do:  #()).

Definition setField : val :=
  rec: "setField" <> :=
    exception_do (let: "s" := ref_ty S (zero_val S) in
    let: "$a0" := #0 in
    do:  (struct.field_ref S "a" "s") <-[uint64T] "$a0";;;
    let: "$a0" := #true in
    do:  (struct.field_ref S "c" "s") <-[boolT] "$a0";;;
    return: (![S] "s");;;
    do:  #()).

(* synchronization.go *)

(* DoSomeLocking uses the entire lock API *)
Definition DoSomeLocking : val :=
  rec: "DoSomeLocking" "l" :=
    exception_do (let: "l" := ref_ty ptrT "l" in
    do:  (sync.Mutex__Lock (![ptrT] "l")) #();;;
    do:  (sync.Mutex__Unlock (![ptrT] "l")) #();;;
    do:  #()).

Definition makeLock : val :=
  rec: "makeLock" <> :=
    exception_do (let: "l" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "l" <-[ptrT] "$a0";;;
    do:  DoSomeLocking (![ptrT] "l");;;
    do:  #()).

(* time.go *)

Definition sleep : val :=
  rec: "sleep" <> :=
    exception_do (do:  machine.Sleep #1000;;;
    do:  #()).

(* topsort.go *)

Definition A : go_type := structT [
].

Definition B : go_type := structT [
  "a" :: sliceT A
].

(* trailing_call.go *)

Definition mkInt : val :=
  rec: "mkInt" <> :=
    exception_do (return: (#42);;;
    do:  #()).

Definition mkNothing : val :=
  rec: "mkNothing" <> :=
    exception_do (do:  mkInt #();;;
    do:  #()).

(* type_alias.go *)

Definition my_u64 : go_type := uint64T.

Definition Timestamp : go_type := uint64T.

Definition UseTypeAbbrev : go_type := uint64T.

Definition UseNamedType : go_type := Timestamp.

Definition convertToAlias : val :=
  rec: "convertToAlias" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #2 in
    do:  "x" <-[uint64T] "$a0";;;
    return: (![uint64T] "x");;;
    do:  #()).
