(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest *)
From New.golang Require Import defn.
From New.code Require github_com.goose_lang.primitive.
From New.code Require github_com.goose_lang.primitive.disk.
From New.code Require github_com.tchajed.marshal.
From New.code Require log.
From New.code Require sync.

From New Require Import disk_prelude.

Definition importantStruct : go_type := structT [
]%struct.

Definition importantStruct__mset : list (string * val) := [
].

Definition importantStruct__mset_ptr : list (string * val) := [
].

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing)

   go: comments.go:12:6 *)
Definition doSubtleThings : val :=
  rec: "doSubtleThings" <> :=
    exception_do (do:  #()).

(* This comment starts a Coq comment ( *

   go: comments.go:15:6 *)
Definition hasStartComment : val :=
  rec: "hasStartComment" <> :=
    exception_do (do:  #()).

(* This comment * ) ends a Coq comment

   go: comments.go:18:6 *)
Definition hasEndComment : val :=
  rec: "hasEndComment" <> :=
    exception_do (do:  #()).

(* go: condvar.go:5:6 *)
Definition condvarWrapping : val :=
  rec: "condvarWrapping" <> :=
    exception_do (let: "mu" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  ("mu" <-[ptrT] "$r0");;;
    let: "cond1" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := let: "$a0" := interface.make sync.Mutex__mset_ptr (![ptrT] "mu") in
    sync.NewCond "$a0" in
    do:  ("cond1" <-[ptrT] "$r0");;;
    let: "$r0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  ("mu" <-[ptrT] "$r0");;;
    do:  ((sync.Cond__Wait (![ptrT] "cond1")) #())).

Definition GlobalConstant : expr := #(str "foo").

(* an untyped string *)
Definition UntypedStringConstant : expr := #(str "bar").

Definition TypedInt : expr := #32.

Definition ConstWithArith : expr := #4 + (#3 * TypedInt).

Definition TypedInt32 : expr := #(U32 3).

Definition DivisionInConst : expr := (#4096 - #8) `quot` #8.

(* 517 *)
Definition ModInConst : expr := #513 + (#12 `rem` #8).

(* 5 *)
Definition ModInConstParens : expr := (#513 + #12) `rem` #8.

(* go: control_flow.go:3:6 *)
Definition conditionalReturn : val :=
  rec: "conditionalReturn" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then return: (#0)
    else do:  #());;;
    return: (#1)).

(* go: control_flow.go:10:6 *)
Definition alwaysReturn : val :=
  rec: "alwaysReturn" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then return: (#0)
    else return: (#1))).

(* go: control_flow.go:18:6 *)
Definition alwaysReturnInNestedBranches : val :=
  rec: "alwaysReturnInNestedBranches" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: (~ (![boolT] "x"))
    then
      (if: ![boolT] "x"
      then return: (#0)
      else return: (#1))
    else do:  #());;;
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #14 in
    do:  ("y" <-[uint64T] "$r0");;;
    return: (![uint64T] "y")).

(* go: control_flow.go:32:6 *)
Definition earlyReturn : val :=
  rec: "earlyReturn" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then return: (#())
    else do:  #())).

(* go: control_flow.go:38:6 *)
Definition conditionalAssign : val :=
  rec: "conditionalAssign" "x" :=
    exception_do (let: "x" := ref_ty boolT "x" in
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    (if: ![boolT] "x"
    then
      let: "$r0" := #1 in
      do:  ("y" <-[uint64T] "$r0")
    else
      let: "$r0" := #2 in
      do:  ("y" <-[uint64T] "$r0"));;;
    do:  ("y" <-[uint64T] ((![uint64T] "y") + #1));;;
    return: (![uint64T] "y")).

(* go: control_flow.go:49:6 *)
Definition elseIf : val :=
  rec: "elseIf" "x" "y" :=
    exception_do (let: "y" := ref_ty boolT "y" in
    let: "x" := ref_ty boolT "x" in
    (if: ![boolT] "x"
    then return: (#0)
    else
      (if: ![boolT] "y"
      then return: (#1)
      else return: (#2)))).

(* go: control_flow.go:59:6 *)
Definition ifStmtInitialization : val :=
  rec: "ifStmtInitialization" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "f" := ref_ty funcT (zero_val funcT) in
    let: "$r0" := (Î»: <>,
      return: (![uint64T] "x")
      ) in
    do:  ("f" <-[funcT] "$r0");;;
    (do:  ((![funcT] "f") #());;;
    (if: (![uint64T] "x") = #2
    then do:  #()
    else
      (let: "z" := ref_ty uint64T (zero_val uint64T) in
      let: "$r0" := ![uint64T] "x" in
      do:  ("z" <-[uint64T] "$r0");;;
      (if: (![uint64T] "z") = #1
      then do:  #()
      else
        (let: "y" := ref_ty intT (zero_val intT) in
        let: "$r0" := #94 in
        do:  ("y" <-[intT] "$r0");;;
        (if: (![intT] "y") = #30
        then do:  #()
        else
          (let: "$r0" := #10 in
          do:  ("z" <-[uint64T] "$r0");;;
          (if: (![uint64T] "x") = #30
          then do:  #()
          else do:  #()))))))));;;
    (let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #10 in
    do:  ("y" <-[uint64T] "$r0");;;
    (if: (![uint64T] "x") = #0
    then return: (![uint64T] "y")
    else return: ((![uint64T] "y") - #1)))).

Definition stringWrapper : go_type := stringT.

Definition stringWrapper__mset : list (string * val) := [
].

Definition stringWrapper__mset_ptr : list (string * val) := [
].

(* go: conversions.go:5:6 *)
Definition typedLiteral : val :=
  rec: "typedLiteral" <> :=
    exception_do (return: (#3)).

(* go: conversions.go:9:6 *)
Definition literalCast : val :=
  rec: "literalCast" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #2 in
    do:  ("x" <-[uint64T] "$r0");;;
    return: ((![uint64T] "x") + #2)).

(* go: conversions.go:15:6 *)
Definition castInt : val :=
  rec: "castInt" "p" :=
    exception_do (let: "p" := ref_ty (sliceT byteT) "p" in
    return: (slice.len (![sliceT byteT] "p"))).

(* go: conversions.go:19:6 *)
Definition stringToByteSlice : val :=
  rec: "stringToByteSlice" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    let: "p" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := string.to_bytes (![stringT] "s") in
    do:  ("p" <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "p")).

(* go: conversions.go:25:6 *)
Definition byteSliceToString : val :=
  rec: "byteSliceToString" "p" :=
    exception_do (let: "p" := ref_ty (sliceT byteT) "p" in
    let: "s" := ref_ty stringT (zero_val stringT) in
    let: "$r0" := string.from_bytes (![sliceT byteT] "p") in
    do:  ("s" <-[stringT] "$r0");;;
    return: (![stringT] "s")).

(* go: conversions.go:31:6 *)
Definition stringToStringWrapper : val :=
  rec: "stringToStringWrapper" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    return: (![stringT] "s")).

(* go: conversions.go:35:6 *)
Definition stringWrapperToString : val :=
  rec: "stringWrapperToString" "s" :=
    exception_do (let: "s" := ref_ty stringWrapper "s" in
    return: (![stringWrapper] "s")).

(* go: copy.go:3:6 *)
Definition testCopySimple : val :=
  rec: "testCopySimple" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make2 byteT #10 in
    do:  ("x" <-[sliceT byteT] "$r0");;;
    let: "$r0" := #(U8 1) in
    do:  ((slice.elem_ref byteT (![sliceT byteT] "x") #3) <-[byteT] "$r0");;;
    let: "y" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make2 byteT #10 in
    do:  ("y" <-[sliceT byteT] "$r0");;;
    do:  (slice.copy byteT (![sliceT byteT] "y") (![sliceT byteT] "x"));;;
    return: ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #3)) = #(U8 1))).

(* go: copy.go:11:6 *)
Definition testCopyDifferentLengths : val :=
  rec: "testCopyDifferentLengths" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make2 byteT #15 in
    do:  ("x" <-[sliceT byteT] "$r0");;;
    let: "$r0" := #(U8 1) in
    do:  ((slice.elem_ref byteT (![sliceT byteT] "x") #3) <-[byteT] "$r0");;;
    let: "$r0" := #(U8 2) in
    do:  ((slice.elem_ref byteT (![sliceT byteT] "x") #12) <-[byteT] "$r0");;;
    let: "y" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make2 byteT #10 in
    do:  ("y" <-[sliceT byteT] "$r0");;;
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := slice.copy byteT (![sliceT byteT] "y") (![sliceT byteT] "x") in
    do:  ("n" <-[uint64T] "$r0");;;
    return: (((![uint64T] "n") = #10) && ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #3)) = #(U8 1)))).

(* go: data_structures.go:7:6 *)
Definition atomicCreateStub : val :=
  rec: "atomicCreateStub" "dir" "fname" "data" :=
    exception_do (let: "data" := ref_ty (sliceT byteT) "data" in
    let: "fname" := ref_ty stringT "fname" in
    let: "dir" := ref_ty stringT "dir" in
    do:  #()).

(* go: data_structures.go:9:6 *)
Definition useSlice : val :=
  rec: "useSlice" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make2 byteT #1 in
    do:  ("s" <-[sliceT byteT] "$r0");;;
    let: "s1" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$a0" := ![sliceT byteT] "s" in
    let: "$a1" := ![sliceT byteT] "s" in
    (slice.append (sliceT byteT)) "$a0" "$a1" in
    do:  ("s1" <-[sliceT byteT] "$r0");;;
    do:  (let: "$a0" := #(str "dir") in
    let: "$a1" := #(str "file") in
    let: "$a2" := ![sliceT byteT] "s1" in
    atomicCreateStub "$a0" "$a1" "$a2")).

(* go: data_structures.go:15:6 *)
Definition useSliceIndexing : val :=
  rec: "useSliceIndexing" <> :=
    exception_do (let: "s" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$r0" := slice.make2 uint64T #2 in
    do:  ("s" <-[sliceT uint64T] "$r0");;;
    let: "$r0" := #2 in
    do:  ((slice.elem_ref uint64T (![sliceT uint64T] "s") #1) <-[uint64T] "$r0");;;
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "s") #0) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: data_structures.go:22:6 *)
Definition useMap : val :=
  rec: "useMap" <> :=
    exception_do (let: "m" := ref_ty (mapT uint64T (sliceT byteT)) (zero_val (mapT uint64T (sliceT byteT))) in
    let: "$r0" := map.make uint64T (sliceT byteT) #() in
    do:  ("m" <-[mapT uint64T (sliceT byteT)] "$r0");;;
    let: "$r0" := slice.nil in
    do:  (map.insert (![mapT uint64T (sliceT byteT)] "m") #1 "$r0");;;
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: ("$ret0", "$ret1") := map.get (![mapT uint64T (sliceT byteT)] "m") #2 in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[sliceT byteT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (#())
    else do:  #());;;
    let: "$r0" := ![sliceT byteT] "x" in
    do:  (map.insert (![mapT uint64T (sliceT byteT)] "m") #3 "$r0")).

(* go: data_structures.go:32:6 *)
Definition usePtr : val :=
  rec: "usePtr" <> :=
    exception_do (let: "p" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty uint64T (zero_val uint64T) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := #1 in
    do:  ((![ptrT] "p") <-[uint64T] "$r0");;;
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (![ptrT] "p") in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := ![uint64T] "x" in
    do:  ((![ptrT] "p") <-[uint64T] "$r0")).

(* go: data_structures.go:39:6 *)
Definition iterMapKeysAndValues : val :=
  rec: "iterMapKeysAndValues" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    let: "sumPtr" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty uint64T (zero_val uint64T) in
    do:  ("sumPtr" <-[ptrT] "$r0");;;
    do:  (map.for_range (![mapT uint64T uint64T] "m") (Î»: "k" "v",
      let: "sum" := ref_ty uint64T (zero_val uint64T) in
      let: "$r0" := ![uint64T] (![ptrT] "sumPtr") in
      do:  ("sum" <-[uint64T] "$r0");;;
      let: "$r0" := ((![uint64T] "sum") + (![uint64T] "k")) + (![uint64T] "v") in
      do:  ((![ptrT] "sumPtr") <-[uint64T] "$r0")));;;
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (![ptrT] "sumPtr") in
    do:  ("sum" <-[uint64T] "$r0");;;
    return: (![uint64T] "sum")).

(* go: data_structures.go:49:6 *)
Definition iterMapKeys : val :=
  rec: "iterMapKeys" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    let: "keysSlice" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$r0" := slice.make2 uint64T #0 in
    do:  ("keysSlice" <-[sliceT uint64T] "$r0");;;
    let: "keysRef" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    do:  ("keysRef" <-[ptrT] "$r0");;;
    let: "$r0" := ![sliceT uint64T] "keysSlice" in
    do:  ((![ptrT] "keysRef") <-[sliceT uint64T] "$r0");;;
    do:  (map.for_range (![mapT uint64T uint64T] "m") (Î»: "k" <>,
      let: "keys" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
      let: "$r0" := ![sliceT uint64T] (![ptrT] "keysRef") in
      do:  ("keys" <-[sliceT uint64T] "$r0");;;
      let: "newKeys" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
      let: "$r0" := let: "$a0" := ![sliceT uint64T] "keys" in
      let: "$a1" := (let: "$sl0" := ![uint64T] "k" in
      slice.literal uint64T ["$sl0"]) in
      (slice.append (sliceT uint64T)) "$a0" "$a1" in
      do:  ("newKeys" <-[sliceT uint64T] "$r0");;;
      let: "$r0" := ![sliceT uint64T] "newKeys" in
      do:  ((![ptrT] "keysRef") <-[sliceT uint64T] "$r0")));;;
    let: "keys" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$r0" := ![sliceT uint64T] (![ptrT] "keysRef") in
    do:  ("keys" <-[sliceT uint64T] "$r0");;;
    return: (![sliceT uint64T] "keys")).

(* go: data_structures.go:62:6 *)
Definition getRandom : val :=
  rec: "getRandom" <> :=
    exception_do (let: "r" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := primitive.RandomUint64 #() in
    do:  ("r" <-[uint64T] "$r0");;;
    return: (![uint64T] "r")).

Definition diskWrapper : go_type := structT [
  "d" :: disk.Disk
]%struct.

Definition diskWrapper__mset : list (string * val) := [
].

Definition diskWrapper__mset_ptr : list (string * val) := [
].

(* go: disk.go:9:6 *)
Definition diskArgument : val :=
  rec: "diskArgument" "d" :=
    exception_do (let: "d" := ref_ty disk.Disk "d" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$a0" := #0 in
    (interface.get "Read" (![disk.Disk] "d")) "$a0" in
    do:  ("b" <-[sliceT byteT] "$r0");;;
    do:  (let: "$a0" := #1 in
    let: "$a1" := ![sliceT byteT] "b" in
    (interface.get "Write" (![disk.Disk] "d")) "$a0" "$a1")).

Definition embedA : go_type := structT [
  "a" :: uint64T
]%struct.

(* go: embedded.go:19:17 *)
Definition embedA__Foo : val :=
  rec: "embedA__Foo" "a" <> :=
    exception_do (let: "a" := ref_ty embedA "a" in
    return: (#0)).

Definition embedA__mset : list (string * val) := [
  ("Foo", embedA__Foo)
].

Definition embedA__mset_ptr : list (string * val) := [
  ("Foo", (Î»: "r", embedA__Foo (![embedA] "r"))%V)
].

Definition embedB : go_type := structT [
  "embedA" :: embedA
]%struct.

(* go: embedded.go:23:17 *)
Definition embedB__Foo : val :=
  rec: "embedB__Foo" "a" <> :=
    exception_do (let: "a" := ref_ty embedB "a" in
    return: (#10)).

Definition embedB__mset : list (string * val) := [
  ("Foo", embedB__Foo)
].

Definition embedB__mset_ptr : list (string * val) := [
  ("Foo", (Î»: "r", embedB__Foo (![embedB] "r"))%V)
].

Definition embedC : go_type := structT [
  "embedB" :: ptrT
]%struct.

Definition embedC__mset : list (string * val) := [
  ("Foo", embedC__Foo)
].

Definition embedC__mset_ptr : list (string * val) := [
  ("Foo", (Î»: "r", embedC__Foo (![embedC] "r"))%V)
].

Definition embedD : go_type := structT [
  "embedC" :: embedC
]%struct.

Definition embedD__mset : list (string * val) := [
  ("Foo", embedD__Foo)
].

Definition embedD__mset_ptr : list (string * val) := [
  ("Foo", (Î»: "r", embedD__Foo (![embedD] "r"))%V)
].

(* go: embedded.go:27:6 *)
Definition returnEmbedVal : val :=
  rec: "returnEmbedVal" <> :=
    exception_do (return: (struct.make embedB [{
     }])).

(* go: embedded.go:31:6 *)
Definition returnEmbedValWithPointer : val :=
  rec: "returnEmbedValWithPointer" <> :=
    exception_do (return: (struct.make embedD [{
     }])).

(* go: embedded.go:35:6 *)
Definition useEmbeddedField : val :=
  rec: "useEmbeddedField" "d" :=
    exception_do (let: "d" := ref_ty embedD "d" in
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := ![uint64T] (struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := #10 in
    do:  ((struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) <-[uint64T] "$r0");;;
    let: "y" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty embedD (struct.make embedD [{
    }]) in
    do:  ("y" <-[ptrT] "$r0");;;
    let: "$r0" := #11 in
    do:  ((struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" (![ptrT] "y")))))) <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: embedded.go:46:6 *)
Definition useEmbeddedValField : val :=
  rec: "useEmbeddedValField" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := struct.field_get embedA "a" (struct.field_get embedB "embedA" (returnEmbedVal #())) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := ![uint64T] (struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (struct.field_get embedC "embedB" (struct.field_get embedD "embedC" (returnEmbedValWithPointer #()))))) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: embedded.go:52:6 *)
Definition useEmbeddedMethod : val :=
  rec: "useEmbeddedMethod" "d" :=
    exception_do (let: "d" := ref_ty embedD "d" in
    return: (((embedB__Foo (![ptrT] (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) #()) = ((embedA__Foo (![ptrT] (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d")))))) #()))).

(* go: empty_functions.go:3:6 *)
Definition empty : val :=
  rec: "empty" <> :=
    exception_do (do:  #()).

(* go: empty_functions.go:5:6 *)
Definition emptyReturn : val :=
  rec: "emptyReturn" <> :=
    exception_do (return: (#())).

Definition Enc : go_type := structT [
  "p" :: sliceT byteT
]%struct.

Definition Enc__mset : list (string * val) := [
].

(* go: encoding.go:9:15 *)
Definition Enc__consume : val :=
  rec: "Enc__consume" "e" "n" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "n" := ref_ty uint64T "n" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$s" := ![sliceT byteT] (struct.field_ref Enc "p" (![ptrT] "e")) in
    slice.slice byteT "$s" #0 (![uint64T] "n") in
    do:  ("b" <-[sliceT byteT] "$r0");;;
    let: "$r0" := let: "$s" := ![sliceT byteT] (struct.field_ref Enc "p" (![ptrT] "e")) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s") in
    do:  ((struct.field_ref Enc "p" (![ptrT] "e")) <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "b")).

(* go: encoding.go:19:15 *)
Definition Enc__UInt32 : val :=
  rec: "Enc__UInt32" "e" "x" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "x" := ref_ty uint32T "x" in
    do:  (let: "$a0" := let: "$a0" := #4 in
    (Enc__consume (![ptrT] "e")) "$a0" in
    let: "$a1" := ![uint32T] "x" in
    primitive.UInt32Put "$a0" "$a1")).

(* go: encoding.go:15:15 *)
Definition Enc__UInt64 : val :=
  rec: "Enc__UInt64" "e" "x" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "x" := ref_ty uint64T "x" in
    do:  (let: "$a0" := let: "$a0" := #8 in
    (Enc__consume (![ptrT] "e")) "$a0" in
    let: "$a1" := ![uint64T] "x" in
    primitive.UInt64Put "$a0" "$a1")).

Definition Enc__mset_ptr : list (string * val) := [
  ("UInt32", Enc__UInt32);
  ("UInt64", Enc__UInt64);
  ("consume", Enc__consume)
].

Definition Dec : go_type := structT [
  "p" :: sliceT byteT
]%struct.

Definition Dec__mset : list (string * val) := [
].

(* go: encoding.go:27:15 *)
Definition Dec__consume : val :=
  rec: "Dec__consume" "d" "n" :=
    exception_do (let: "d" := ref_ty ptrT "d" in
    let: "n" := ref_ty uint64T "n" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$s" := ![sliceT byteT] (struct.field_ref Dec "p" (![ptrT] "d")) in
    slice.slice byteT "$s" #0 (![uint64T] "n") in
    do:  ("b" <-[sliceT byteT] "$r0");;;
    let: "$r0" := let: "$s" := ![sliceT byteT] (struct.field_ref Dec "p" (![ptrT] "d")) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s") in
    do:  ((struct.field_ref Dec "p" (![ptrT] "d")) <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "b")).

(* go: encoding.go:37:15 *)
Definition Dec__UInt32 : val :=
  rec: "Dec__UInt32" "d" <> :=
    exception_do (let: "d" := ref_ty ptrT "d" in
    return: (let: "$a0" := let: "$a0" := #4 in
     (Dec__consume (![ptrT] "d")) "$a0" in
     primitive.UInt32Get "$a0")).

(* go: encoding.go:33:15 *)
Definition Dec__UInt64 : val :=
  rec: "Dec__UInt64" "d" <> :=
    exception_do (let: "d" := ref_ty ptrT "d" in
    return: (let: "$a0" := let: "$a0" := #8 in
     (Dec__consume (![ptrT] "d")) "$a0" in
     primitive.UInt64Get "$a0")).

Definition Dec__mset_ptr : list (string * val) := [
  ("UInt32", Dec__UInt32);
  ("UInt64", Dec__UInt64);
  ("consume", Dec__consume)
].

(* go: higher_order.go:3:6 *)
Definition TakesFunctionType : val :=
  rec: "TakesFunctionType" "f" :=
    exception_do (let: "f" := ref_ty funcT "f" in
    do:  ((![funcT] "f") #())).

Definition Fooer : go_type := interfaceT.

Definition concreteFooer : go_type := structT [
  "a" :: uint64T
]%struct.

Definition concreteFooer__mset : list (string * val) := [
].

(* go: interfaces.go:15:25 *)
Definition concreteFooer__Foo : val :=
  rec: "concreteFooer__Foo" "f" <> :=
    exception_do (let: "f" := ref_ty ptrT "f" in
    do:  #()).

Definition concreteFooer__mset_ptr : list (string * val) := [
  ("Foo", concreteFooer__Foo)
].

Definition FooerUser : go_type := structT [
  "f" :: Fooer
]%struct.

Definition FooerUser__mset : list (string * val) := [
].

Definition FooerUser__mset_ptr : list (string * val) := [
].

(* go: interfaces.go:18:6 *)
Definition fooConsumer : val :=
  rec: "fooConsumer" "f" :=
    exception_do (let: "f" := ref_ty Fooer "f" in
    do:  ((interface.get "Foo" (![Fooer] "f")) #())).

(* go: interfaces.go:22:6 *)
Definition testAssignConcreteToInterface : val :=
  rec: "testAssignConcreteToInterface" "x" :=
    exception_do (let: "x" := ref_ty ptrT "x" in
    let: "c" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty concreteFooer (struct.make concreteFooer [{
    }]) in
    do:  ("c" <-[ptrT] "$r0");;;
    let: "$r0" := interface.make concreteFooer__mset_ptr (![ptrT] "c") in
    do:  ((![ptrT] "x") <-[Fooer] "$r0")).

(* go: interfaces.go:27:6 *)
Definition testPassConcreteToInterfaceArg : val :=
  rec: "testPassConcreteToInterfaceArg" <> :=
    exception_do (let: "c" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty concreteFooer (struct.make concreteFooer [{
    }]) in
    do:  ("c" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := interface.make concreteFooer__mset_ptr (![ptrT] "c") in
    fooConsumer "$a0");;;
    let: "f" := ref_ty Fooer (interface.make concreteFooer__mset_ptr (![ptrT] "c")) in
    do:  (let: "$a0" := ![Fooer] "f" in
    fooConsumer "$a0");;;
    do:  ((concreteFooer__Foo (![ptrT] "c")) #());;;
    do:  ((interface.get "Foo" (![Fooer] "f")) #())).

(* go: interfaces.go:37:6 *)
Definition testPassConcreteToInterfaceArgSpecial : val :=
  rec: "testPassConcreteToInterfaceArgSpecial" <> :=
    exception_do (let: "c1" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty concreteFooer (struct.make concreteFooer [{
    }]) in
    do:  ("c1" <-[ptrT] "$r0");;;
    let: "c2" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty concreteFooer (struct.make concreteFooer [{
    }]) in
    do:  ("c2" <-[ptrT] "$r0");;;
    let: "l" := ref_ty (sliceT Fooer) (zero_val (sliceT Fooer)) in
    let: "$r0" := (let: "$sl0" := interface.make concreteFooer__mset_ptr (![ptrT] "c1") in
    let: "$sl1" := interface.make concreteFooer__mset_ptr (![ptrT] "c2") in
    slice.literal Fooer ["$sl0"; "$sl1"]) in
    do:  ("l" <-[sliceT Fooer] "$r0");;;
    let: "m" := ref_ty (mapT uint64T Fooer) (zero_val (mapT uint64T Fooer)) in
    let: "$r0" := map.make uint64T Fooer #() in
    do:  ("m" <-[mapT uint64T Fooer] "$r0");;;
    let: "$r0" := interface.make concreteFooer__mset_ptr (![ptrT] "c1") in
    do:  (map.insert (![mapT uint64T Fooer] "m") #10 "$r0");;;
    let: "f" := ref_ty FooerUser (zero_val FooerUser) in
    let: "$r0" := struct.make FooerUser [{
      "f" ::= interface.make concreteFooer__mset_ptr (![ptrT] "c1")
    }] in
    do:  ("f" <-[FooerUser] "$r0");;;
    return: (![sliceT Fooer] "l", ![mapT uint64T Fooer] "m", ![FooerUser] "f")).

(* go: interfaces.go:51:6 *)
Definition takesVarArgsInterface : val :=
  rec: "takesVarArgsInterface" "fs" :=
    exception_do (let: "fs" := ref_ty (sliceT Fooer) "fs" in
    do:  ((interface.get "Foo" (![Fooer] (slice.elem_ref Fooer (![sliceT Fooer] "fs") #0))) #())).

(* go: interfaces.go:55:6 *)
Definition test : val :=
  rec: "test" <> :=
    exception_do (do:  (let: "$a0" := (let: "$sl0" := interface.make concreteFooer__mset_ptr (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    let: "$sl1" := interface.make concreteFooer__mset_ptr (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    slice.literal Fooer ["$sl0"; "$sl1"]) in
    takesVarArgsInterface "$a0")).

(* go: interfaces.go:59:6 *)
Definition returnConcrete : val :=
  rec: "returnConcrete" <> :=
    exception_do (return: (ref_ty concreteFooer (struct.make concreteFooer [{
     }]), #10)).

(* converts an object into an interface in a multiple return destructuring statement.

   go: interfaces.go:64:6 *)
Definition testMultiReturn : val :=
  rec: "testMultiReturn" "x" :=
    exception_do (let: "x" := ref_ty ptrT "x" in
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: ("$ret0", "$ret1") := returnConcrete #() in
    let: "$r0" := interface.make concreteFooer__mset_ptr "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((![ptrT] "x") <-[Fooer] "$r0");;;
    do:  ("y" <-[uint64T] "$r1");;;
    return: (![uint64T] "y")).

(* go: interfaces.go:70:6 *)
Definition testReturnStatment : val :=
  rec: "testReturnStatment" <> :=
    exception_do (let: "y" := ref_ty ptrT (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    return: (interface.make concreteFooer__mset_ptr (![ptrT] "y"))).

(* go: interfaces.go:75:6 *)
Definition testConversionInEq : val :=
  rec: "testConversionInEq" "f" :=
    exception_do (let: "f" := ref_ty Fooer "f" in
    let: "c" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty concreteFooer (struct.make concreteFooer [{
    }]) in
    do:  ("c" <-[ptrT] "$r0");;;
    let: "$r0" := interface.make concreteFooer__mset_ptr (![ptrT] "c") in
    do:  ("f" <-[Fooer] "$r0");;;
    return: ((interface.make concreteFooer__mset_ptr (![ptrT] "c")) = (![Fooer] "f"))).

(* go: interfaces.go:82:6 *)
Definition takeMultiple : val :=
  rec: "takeMultiple" "a" "f" :=
    exception_do (let: "f" := ref_ty (sliceT Fooer) "f" in
    let: "a" := ref_ty uint64T "a" in
    do:  #()).

(* go: interfaces.go:85:6 *)
Definition giveMultiple : val :=
  rec: "giveMultiple" <> :=
    exception_do (return: (#0, interface.make concreteFooer__mset_ptr (ref_ty concreteFooer (struct.make concreteFooer [{
     }])), ref_ty concreteFooer (struct.make concreteFooer [{
     }]))).

(* go: interfaces.go:89:6 *)
Definition testConversionInMultipleReturnPassThrough : val :=
  rec: "testConversionInMultipleReturnPassThrough" <> :=
    exception_do (let: (("$ret0", "$ret1"), "$ret2") := (giveMultiple #()) in
    return: ("$ret0", "$ret1", interface.make concreteFooer__mset_ptr "$ret2")).

(* See "special case" in https://go.dev/ref/spec#Calls

   go: interfaces.go:94:6 *)
Definition testConversionInMultiplePassThrough : val :=
  rec: "testConversionInMultiplePassThrough" <> :=
    exception_do (do:  (let: (("$ret0", "$ret1"), "$ret2") := (giveMultiple #()) in
    let: "$a0" := "$ret0" in
    let: "$a1" := (let: "$sl0" := "$ret1" in
    let: "$sl1" := interface.make concreteFooer__mset_ptr "$ret2" in
    slice.literal Fooer ["$sl0"; "$sl1"]) in
    takeMultiple "$a0" "$a1")).

Definition PointerInterface : go_type := interfaceT.

Definition concrete1 : go_type := structT [
]%struct.

(* go: interfaces.go:106:20 *)
Definition concrete1__Foo : val :=
  rec: "concrete1__Foo" "c" <> :=
    exception_do (let: "c" := ref_ty concrete1 "c" in
    do:  #()).

Definition concrete1__mset : list (string * val) := [
  ("Foo", concrete1__Foo)
].

(* go: interfaces.go:109:21 *)
Definition concrete1__B : val :=
  rec: "concrete1__B" "c" <> :=
    exception_do (let: "c" := ref_ty ptrT "c" in
    do:  #()).

Definition concrete1__mset_ptr : list (string * val) := [
  ("B", concrete1__B);
  ("Foo", (Î»: "r", concrete1__Foo (![concrete1] "r"))%V)
].

(* go: interfaces.go:112:6 *)
Definition testPtrMset : val :=
  rec: "testPtrMset" <> :=
    exception_do (let: "a" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty concrete1 (struct.make concrete1 [{
    }]) in
    do:  ("a" <-[ptrT] "$r0");;;
    let: "p" := ref_ty PointerInterface (interface.make concrete1__mset_ptr (![ptrT] "a")) in
    let: "f" := ref_ty Fooer (interface.make concrete1__mset (![concrete1] (![ptrT] "a"))) in
    do:  ((interface.get "B" (![PointerInterface] "p")) #());;;
    do:  ((interface.get "Foo" (![Fooer] "f")) #())).

(* go: ints.go:3:6 *)
Definition useInts : val :=
  rec: "useInts" "x" "y" :=
    exception_do (let: "y" := ref_ty uint32T "y" in
    let: "x" := ref_ty uint64T "x" in
    let: "z" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := to_u64 (![uint32T] "y") in
    do:  ("z" <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] "z") + #1 in
    do:  ("z" <-[uint64T] "$r0");;;
    let: "y2" := ref_ty uint32T (zero_val uint32T) in
    let: "$r0" := (![uint32T] "y") + #(U32 3) in
    do:  ("y2" <-[uint32T] "$r0");;;
    return: (![uint64T] "z", ![uint32T] "y2")).

Definition my_u32 : go_type := uint32T.

Definition my_u32__mset : list (string * val) := [
].

Definition my_u32__mset_ptr : list (string * val) := [
].

Definition also_u32 : go_type := my_u32.

Definition also_u32__mset : list (string * val) := [
].

Definition also_u32__mset_ptr : list (string * val) := [
].

Definition ConstWithAbbrevType : expr := #(U32 3).

Definition allTheLiterals : go_type := structT [
  "int" :: uint64T;
  "s" :: stringT;
  "b" :: boolT
]%struct.

Definition allTheLiterals__mset : list (string * val) := [
].

Definition allTheLiterals__mset_ptr : list (string * val) := [
].

(* go: literals.go:9:6 *)
Definition normalLiterals : val :=
  rec: "normalLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #0;
       "s" ::= #(str "foo");
       "b" ::= #true
     }])).

(* go: literals.go:17:6 *)
Definition specialLiterals : val :=
  rec: "specialLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #4096;
       "s" ::= #(str "");
       "b" ::= #false
     }])).

(* go: literals.go:25:6 *)
Definition oddLiterals : val :=
  rec: "oddLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #5;
       "s" ::= #(str "backquote string");
       "b" ::= #false
     }])).

(* go: literals.go:33:6 *)
Definition unKeyedLiteral : val :=
  rec: "unKeyedLiteral" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #0;
       "s" ::= #(str "a");
       "b" ::= #false
     }])).

(* go: locks.go:5:6 *)
Definition useLocks : val :=
  rec: "useLocks" <> :=
    exception_do (let: "m" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  ("m" <-[ptrT] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] "m")) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "m")) #())).

(* go: locks.go:11:6 *)
Definition useCondVar : val :=
  rec: "useCondVar" <> :=
    exception_do (let: "m" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  ("m" <-[ptrT] "$r0");;;
    let: "c" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := let: "$a0" := interface.make sync.Mutex__mset_ptr (![ptrT] "m") in
    sync.NewCond "$a0" in
    do:  ("c" <-[ptrT] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] "m")) #());;;
    do:  ((sync.Cond__Signal (![ptrT] "c")) #());;;
    do:  ((sync.Cond__Wait (![ptrT] "c")) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "m")) #())).

Definition hasCondVar : go_type := structT [
  "cond" :: ptrT
]%struct.

Definition hasCondVar__mset : list (string * val) := [
].

Definition hasCondVar__mset_ptr : list (string * val) := [
].

(* go: log_debugging.go:5:6 *)
Definition ToBeDebugged : val :=
  rec: "ToBeDebugged" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    do:  (let: "$a0" := (let: "$sl0" := interface.make string__mset #(str "starting function") in
    slice.literal interfaceT ["$sl0"]) in
    log.Println "$a0");;;
    do:  (let: "$a0" := #(str "called with %d") in
    let: "$a1" := (let: "$sl0" := interface.make uint64__mset (![uint64T] "x") in
    slice.literal interfaceT ["$sl0"]) in
    log.Printf "$a0" "$a1");;;
    do:  (let: "$a0" := (let: "$sl0" := interface.make string__mset #(str "ending function") in
    slice.literal interfaceT ["$sl0"]) in
    log.Println "$a0");;;
    return: (![uint64T] "x")).

(* go: log_debugging.go:12:6 *)
Definition DoNothing : val :=
  rec: "DoNothing" <> :=
    exception_do (do:  (let: "$a0" := (let: "$sl0" := interface.make string__mset #(str "doing nothing") in
    slice.literal interfaceT ["$sl0"]) in
    log.Println "$a0")).

(* DoSomething is an impure function

   go: loops.go:4:6 *)
Definition DoSomething : val :=
  rec: "DoSomething" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    do:  #()).

(* go: loops.go:6:6 *)
Definition standardForLoop : val :=
  rec: "standardForLoop" "s" :=
    exception_do (let: "s" := ref_ty (sliceT uint64T) "s" in
    let: "sumPtr" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty uint64T (zero_val uint64T) in
    do:  ("sumPtr" <-[ptrT] "$r0");;;
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "i") < (slice.len (![sliceT uint64T] "s"))
      then
        let: "sum" := ref_ty uint64T (zero_val uint64T) in
        let: "$r0" := ![uint64T] (![ptrT] "sumPtr") in
        do:  ("sum" <-[uint64T] "$r0");;;
        let: "x" := ref_ty uint64T (zero_val uint64T) in
        let: "$r0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "s") (![uint64T] "i")) in
        do:  ("x" <-[uint64T] "$r0");;;
        let: "$r0" := (![uint64T] "sum") + (![uint64T] "x") in
        do:  ((![ptrT] "sumPtr") <-[uint64T] "$r0");;;
        let: "$r0" := (![uint64T] "i") + #1 in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (![ptrT] "sumPtr") in
    do:  ("sum" <-[uint64T] "$r0");;;
    return: (![uint64T] "sum")).

(* go: loops.go:25:6 *)
Definition conditionalInLoop : val :=
  rec: "conditionalInLoop" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "i") < #3
      then
        do:  (let: "$a0" := #(str "i is small") in
        DoSomething "$a0")
      else do:  #());;;
      (if: (![uint64T] "i") > #5
      then break: #()
      else do:  #());;;
      let: "$r0" := (![uint64T] "i") + #1 in
      do:  ("i" <-[uint64T] "$r0");;;
      continue: #()))).

(* go: loops.go:38:6 *)
Definition conditionalInLoopElse : val :=
  rec: "conditionalInLoopElse" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "i") > #5
      then break: #()
      else
        let: "$r0" := (![uint64T] "i") + #1 in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #())))).

(* go: loops.go:49:6 *)
Definition nestedConditionalInLoopImplicitContinue : val :=
  rec: "nestedConditionalInLoopImplicitContinue" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "i") > #5
      then
        (if: (![uint64T] "i") > #10
        then break: #()
        else do:  #())
      else
        let: "$r0" := (![uint64T] "i") + #1 in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #())))).

(* go: loops.go:62:6 *)
Definition ImplicitLoopContinue : val :=
  rec: "ImplicitLoopContinue" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "i") < #4
      then
        let: "$r0" := #0 in
        do:  ("i" <-[uint64T] "$r0")
      else do:  #())))).

(* go: loops.go:70:6 *)
Definition ImplicitLoopContinue2 : val :=
  rec: "ImplicitLoopContinue2" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "i") < #4
      then
        let: "$r0" := #0 in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #()
      else do:  #())))).

(* go: loops.go:79:6 *)
Definition ImplicitLoopContinueAfterIfBreak : val :=
  rec: "ImplicitLoopContinueAfterIfBreak" "i" :=
    exception_do (let: "i" := ref_ty uint64T "i" in
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "i") > #0
      then break: #()
      else do:  #()))).

(* go: loops.go:87:6 *)
Definition nestedLoops : val :=
  rec: "nestedLoops" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (let: "j" := ref_ty uint64T (zero_val uint64T) in
      let: "$r0" := #0 in
      do:  ("j" <-[uint64T] "$r0");;;
      (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        let: "$r0" := (![uint64T] "j") + #1 in
        do:  ("j" <-[uint64T] "$r0");;;
        continue: #()));;;
      let: "$r0" := (![uint64T] "i") + #1 in
      do:  ("i" <-[uint64T] "$r0");;;
      continue: #()))).

(* go: loops.go:101:6 *)
Definition nestedGoStyleLoops : val :=
  rec: "nestedGoStyleLoops" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, (![uint64T] "i") < #10); (Î»: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #1))) := Î»: <>,
      (let: "j" := ref_ty uint64T (zero_val uint64T) in
      let: "$r0" := #0 in
      do:  ("j" <-[uint64T] "$r0");;;
      (for: (Î»: <>, (![uint64T] "j") < (![uint64T] "i")); (Î»: <>, do:  ("j" <-[uint64T] ((![uint64T] "j") + #1))) := Î»: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()))))).

(* go: loops.go:113:6 *)
Definition sumSlice : val :=
  rec: "sumSlice" "xs" :=
    exception_do (let: "xs" := ref_ty (sliceT uint64T) "xs" in
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    do:  (let: "$range" := ![sliceT uint64T] "xs" in
    slice.for_range uint64T "$range" (Î»: <> "x",
      let: "x" := ref_ty uint64T "x" in
      do:  ("sum" <-[uint64T] ((![uint64T] "sum") + (![uint64T] "x")))));;;
    return: (![uint64T] "sum")).

(* go: loops.go:121:6 *)
Definition breakFromLoop : val :=
  rec: "breakFromLoop" <> :=
    exception_do ((for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: #true
      then break: #()
      else do:  #());;;
      continue: #())).

(* go: maps.go:5:6 *)
Definition clearMap : val :=
  rec: "clearMap" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    do:  (let: "$a0" := ![mapT uint64T uint64T] "m" in
    primitive.MapClear "$a0")).

(* go: maps.go:9:6 *)
Definition IterateMapKeys : val :=
  rec: "IterateMapKeys" "m" "sum" :=
    exception_do (let: "sum" := ref_ty ptrT "sum" in
    let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    do:  (map.for_range (![mapT uint64T uint64T] "m") (Î»: "k" <>,
      let: "oldSum" := ref_ty uint64T (zero_val uint64T) in
      let: "$r0" := ![uint64T] (![ptrT] "sum") in
      do:  ("oldSum" <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] "oldSum") + (![uint64T] "k") in
      do:  ((![ptrT] "sum") <-[uint64T] "$r0")))).

(* go: maps.go:16:6 *)
Definition MapSize : val :=
  rec: "MapSize" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T boolT) "m" in
    return: (map.len (![mapT uint64T boolT] "m"))).

Definition IntWrapper : go_type := uint64T.

Definition IntWrapper__mset : list (string * val) := [
].

Definition IntWrapper__mset_ptr : list (string * val) := [
].

Definition MapWrapper : go_type := mapT uint64T boolT.

Definition MapWrapper__mset : list (string * val) := [
].

Definition MapWrapper__mset_ptr : list (string * val) := [
].

(* go: maps.go:24:6 *)
Definition MapTypeAliases : val :=
  rec: "MapTypeAliases" "m1" "m2" :=
    exception_do (let: "m2" := ref_ty MapWrapper "m2" in
    let: "m1" := ref_ty (mapT IntWrapper boolT) "m1" in
    let: "$r0" := Fst (map.get (![MapWrapper] "m2") #0) in
    do:  (map.insert (![mapT IntWrapper boolT] "m1") #4 "$r0")).

(* go: maps.go:28:6 *)
Definition StringMap : val :=
  rec: "StringMap" "m" :=
    exception_do (let: "m" := ref_ty (mapT stringT uint64T) "m" in
    return: (Fst (map.get (![mapT stringT uint64T] "m") #(str "foo")))).

Definition mapElem : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
]%struct.

Definition mapElem__mset : list (string * val) := [
].

Definition mapElem__mset_ptr : list (string * val) := [
].

(* go: maps.go:37:6 *)
Definition mapUpdateField : val :=
  rec: "mapUpdateField" <> :=
    exception_do (let: "x" := ref_ty (mapT uint64T ptrT) (zero_val (mapT uint64T ptrT)) in
    let: "$r0" := map.make uint64T ptrT #() in
    do:  ("x" <-[mapT uint64T ptrT] "$r0");;;
    let: "$r0" := #10 in
    do:  ((struct.field_ref mapElem "a" (Fst (map.get (![mapT uint64T ptrT] "x") #0))) <-[uint64T] "$r0")).

(* go: multiple.go:3:6 *)
Definition returnTwo : val :=
  rec: "returnTwo" "p" :=
    exception_do (let: "p" := ref_ty (sliceT byteT) "p" in
    return: (#0, #0)).

(* go: multiple.go:7:6 *)
Definition returnTwoWrapper : val :=
  rec: "returnTwoWrapper" "data" :=
    exception_do (let: "data" := ref_ty (sliceT byteT) "data" in
    let: "b" := ref_ty uint64T (zero_val uint64T) in
    let: "a" := ref_ty uint64T (zero_val uint64T) in
    let: ("$ret0", "$ret1") := let: "$a0" := ![sliceT byteT] "data" in
    returnTwo "$a0" in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[uint64T] "$r0");;;
    do:  ("b" <-[uint64T] "$r1");;;
    return: (![uint64T] "a", ![uint64T] "b")).

(* go: multiple.go:12:6 *)
Definition multipleVar : val :=
  rec: "multipleVar" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint64T "x" in
    do:  #()).

(* go: multiple.go:14:6 *)
Definition multiplePassThrough : val :=
  rec: "multiplePassThrough" <> :=
    exception_do (do:  (let: ("$ret0", "$ret1") := (let: "$a0" := slice.nil in
    returnTwoWrapper "$a0") in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    multipleVar "$a0" "$a1")).

(* go: multiple.go:18:6 *)
Definition multipleReturnPassThrough : val :=
  rec: "multipleReturnPassThrough" <> :=
    exception_do (let: ("$ret0", "$ret1") := (let: "$a0" := slice.nil in
    returnTwo "$a0") in
    return: ("$ret0", "$ret1")).

(* go: nil.go:3:6 *)
Definition AssignNilSlice : val :=
  rec: "AssignNilSlice" <> :=
    exception_do (let: "s" := ref_ty (sliceT (sliceT byteT)) (zero_val (sliceT (sliceT byteT))) in
    let: "$r0" := slice.make2 (sliceT byteT) #4 in
    do:  ("s" <-[sliceT (sliceT byteT)] "$r0");;;
    let: "$r0" := slice.nil in
    do:  ((slice.elem_ref (sliceT byteT) (![sliceT (sliceT byteT)] "s") #2) <-[sliceT byteT] "$r0")).

(* go: nil.go:8:6 *)
Definition AssignNilPointer : val :=
  rec: "AssignNilPointer" <> :=
    exception_do (let: "s" := ref_ty (sliceT ptrT) (zero_val (sliceT ptrT)) in
    let: "$r0" := slice.make2 ptrT #4 in
    do:  ("s" <-[sliceT ptrT] "$r0");;;
    let: "$r0" := #null in
    do:  ((slice.elem_ref ptrT (![sliceT ptrT] "s") #2) <-[ptrT] "$r0")).

(* go: nil.go:13:6 *)
Definition CompareSliceToNil : val :=
  rec: "CompareSliceToNil" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make2 byteT #0 in
    do:  ("s" <-[sliceT byteT] "$r0");;;
    return: ((![sliceT byteT] "s") â  slice.nil)).

(* go: nil.go:18:6 *)
Definition ComparePointerToNil : val :=
  rec: "ComparePointerToNil" <> :=
    exception_do (let: "s" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty uint64T (zero_val uint64T) in
    do:  ("s" <-[ptrT] "$r0");;;
    return: ((![ptrT] "s") â  #null)).

(* go: operators.go:3:6 *)
Definition LogicalOperators : val :=
  rec: "LogicalOperators" "b1" "b2" :=
    exception_do (let: "b2" := ref_ty boolT "b2" in
    let: "b1" := ref_ty boolT "b1" in
    return: (((![boolT] "b1") && ((![boolT] "b2") || (![boolT] "b1"))) && (~ #false))).

(* go: operators.go:7:6 *)
Definition LogicalAndEqualityOperators : val :=
  rec: "LogicalAndEqualityOperators" "b1" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "b1" := ref_ty boolT "b1" in
    return: (((![uint64T] "x") = #3) && ((![boolT] "b1") = #true))).

(* go: operators.go:11:6 *)
Definition ArithmeticShifts : val :=
  rec: "ArithmeticShifts" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint32T "x" in
    return: (((to_u64 ((![uint32T] "x") âª #3)) + ((![uint64T] "y") âª (to_u64 (![uint32T] "x")))) + ((![uint64T] "y") âª #1))).

(* go: operators.go:15:6 *)
Definition BitwiseOps : val :=
  rec: "BitwiseOps" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint32T "x" in
    return: ((to_u64 (![uint32T] "x")) `or` ((to_u64 (to_u32 (![uint64T] "y"))) `and` #43))).

(* go: operators.go:19:6 *)
Definition Comparison : val :=
  rec: "Comparison" "x" "y" :=
    exception_do (let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint64T "x" in
    (if: (![uint64T] "x") < (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![uint64T] "x") = (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![uint64T] "x") â  (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![uint64T] "x") > (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: ((![uint64T] "x") + #1) > ((![uint64T] "y") - #2)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: operators.go:38:6 *)
Definition AssignOps : val :=
  rec: "AssignOps" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    do:  ("x" <-[uint64T] ((![uint64T] "x") + #3));;;
    do:  ("x" <-[uint64T] ((![uint64T] "x") - #3));;;
    do:  ("x" <-[uint64T] ((![uint64T] "x") + #1));;;
    do:  ("x" <-[uint64T] ((![uint64T] "x") - #1))).

Definition wrapExternalStruct : go_type := structT [
  "e" :: marshal.Enc;
  "d" :: marshal.Dec
]%struct.

(* go: package.go:14:29 *)
Definition wrapExternalStruct__moveUint64 : val :=
  rec: "wrapExternalStruct__moveUint64" "w" <> :=
    exception_do (let: "w" := ref_ty wrapExternalStruct "w" in
    do:  (let: "$a0" := (marshal.Dec__GetInt (![ptrT] (struct.field_ref wrapExternalStruct "d" "w"))) #() in
    (marshal.Enc__PutInt (![ptrT] (struct.field_ref wrapExternalStruct "e" "w"))) "$a0")).

Definition wrapExternalStruct__mset : list (string * val) := [
  ("moveUint64", wrapExternalStruct__moveUint64)
].

Definition wrapExternalStruct__mset_ptr : list (string * val) := [
  ("moveUint64", (Î»: "r", wrapExternalStruct__moveUint64 (![wrapExternalStruct] "r"))%V)
].

(* go: panic.go:3:6 *)
Definition PanicAtTheDisco : val :=
  rec: "PanicAtTheDisco" <> :=
    exception_do (do:  (Panic "disco")).

(* go: proph.go:5:6 *)
Definition Oracle : val :=
  rec: "Oracle" <> :=
    exception_do (let: "p" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := primitive.NewProph #() in
    do:  ("p" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := #false in
    (primitive.prophId__ResolveBool (![ptrT] "p")) "$a0");;;
    do:  (let: "$a0" := #0 in
    (primitive.prophId__ResolveU64 (![ptrT] "p")) "$a0")).

Definition typing : go_type := structT [
  "proph" :: ptrT
]%struct.

Definition typing__mset : list (string * val) := [
].

Definition typing__mset_ptr : list (string * val) := [
].

Definition composite : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
]%struct.

Definition composite__mset : list (string * val) := [
].

Definition composite__mset_ptr : list (string * val) := [
].

(* go: reassign.go:8:6 *)
Definition ReassignVars : val :=
  rec: "ReassignVars" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("y" <-[uint64T] "$r0");;;
    let: "$r0" := #3 in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "z" := ref_ty composite (struct.make composite [{
      "a" ::= ![uint64T] "x";
      "b" ::= ![uint64T] "y"
    }]) in
    let: "$r0" := struct.make composite [{
      "a" ::= ![uint64T] "y";
      "b" ::= ![uint64T] "x"
    }] in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := ![uint64T] (struct.field_ref composite "a" "z") in
    do:  ("x" <-[uint64T] "$r0")).

Definition Block : go_type := structT [
  "Value" :: uint64T
]%struct.

Definition Block__mset : list (string * val) := [
].

Definition Block__mset_ptr : list (string * val) := [
].

Definition Disk1 : expr := #0.

Definition Disk2 : expr := #0.

Definition DiskSize : expr := #1000.

(* TwoDiskWrite is a dummy function to represent the base layer's disk write

   go: replicated_disk.go:12:6 *)
Definition TwoDiskWrite : val :=
  rec: "TwoDiskWrite" "diskId" "a" "v" :=
    exception_do (let: "v" := ref_ty Block "v" in
    let: "a" := ref_ty uint64T "a" in
    let: "diskId" := ref_ty uint64T "diskId" in
    return: (#true)).

(* TwoDiskRead is a dummy function to represent the base layer's disk read

   go: replicated_disk.go:17:6 *)
Definition TwoDiskRead : val :=
  rec: "TwoDiskRead" "diskId" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    let: "diskId" := ref_ty uint64T "diskId" in
    return: (struct.make Block [{
       "Value" ::= #0
     }], #true)).

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer

   go: replicated_disk.go:23:6 *)
Definition TwoDiskLock : val :=
  rec: "TwoDiskLock" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    do:  #()).

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer

   go: replicated_disk.go:27:6 *)
Definition TwoDiskUnlock : val :=
  rec: "TwoDiskUnlock" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    do:  #()).

(* go: replicated_disk.go:29:6 *)
Definition ReplicatedDiskRead : val :=
  rec: "ReplicatedDiskRead" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    do:  (let: "$a0" := ![uint64T] "a" in
    TwoDiskLock "$a0");;;
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "v" := ref_ty Block (zero_val Block) in
    let: ("$ret0", "$ret1") := let: "$a0" := Disk1 in
    let: "$a1" := ![uint64T] "a" in
    TwoDiskRead "$a0" "$a1" in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[Block] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  (let: "$a0" := ![uint64T] "a" in
      TwoDiskUnlock "$a0");;;
      return: (![Block] "v")
    else do:  #());;;
    let: <> := ref_ty boolT (zero_val boolT) in
    let: "v2" := ref_ty Block (zero_val Block) in
    let: ("$ret0", "$ret1") := let: "$a0" := Disk2 in
    let: "$a1" := ![uint64T] "a" in
    TwoDiskRead "$a0" "$a1" in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[Block] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := ![uint64T] "a" in
    TwoDiskUnlock "$a0");;;
    return: (![Block] "v2")).

(* go: replicated_disk.go:42:6 *)
Definition ReplicatedDiskWrite : val :=
  rec: "ReplicatedDiskWrite" "a" "v" :=
    exception_do (let: "v" := ref_ty Block "v" in
    let: "a" := ref_ty uint64T "a" in
    do:  (let: "$a0" := ![uint64T] "a" in
    TwoDiskLock "$a0");;;
    do:  (let: "$a0" := Disk1 in
    let: "$a1" := ![uint64T] "a" in
    let: "$a2" := ![Block] "v" in
    TwoDiskWrite "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := Disk2 in
    let: "$a1" := ![uint64T] "a" in
    let: "$a2" := ![Block] "v" in
    TwoDiskWrite "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := ![uint64T] "a" in
    TwoDiskUnlock "$a0")).

(* go: replicated_disk.go:49:6 *)
Definition ReplicatedDiskRecover : val :=
  rec: "ReplicatedDiskRecover" <> :=
    exception_do ((let: "a" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("a" <-[uint64T] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: (![uint64T] "a") > DiskSize
      then break: #()
      else do:  #());;;
      let: "ok" := ref_ty boolT (zero_val boolT) in
      let: "v" := ref_ty Block (zero_val Block) in
      let: ("$ret0", "$ret1") := let: "$a0" := Disk1 in
      let: "$a1" := ![uint64T] "a" in
      TwoDiskRead "$a0" "$a1" in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[Block] "$r0");;;
      do:  ("ok" <-[boolT] "$r1");;;
      (if: ![boolT] "ok"
      then
        do:  (let: "$a0" := Disk2 in
        let: "$a1" := ![uint64T] "a" in
        let: "$a2" := ![Block] "v" in
        TwoDiskWrite "$a0" "$a1" "$a2")
      else do:  #());;;
      let: "$r0" := (![uint64T] "a") + #1 in
      do:  ("a" <-[uint64T] "$r0");;;
      continue: #()))).

Definition SliceAlias : go_type := sliceT boolT.

Definition SliceAlias__mset : list (string * val) := [
].

Definition SliceAlias__mset_ptr : list (string * val) := [
].

(* go: slices.go:5:6 *)
Definition sliceOps : val :=
  rec: "sliceOps" <> :=
    exception_do (let: "x" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$r0" := slice.make2 uint64T #10 in
    do:  ("x" <-[sliceT uint64T] "$r0");;;
    let: "v1" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "x") #2) in
    do:  ("v1" <-[uint64T] "$r0");;;
    let: "v2" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$r0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #2 #3 in
    do:  ("v2" <-[sliceT uint64T] "$r0");;;
    let: "v3" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$r0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #0 #3 in
    do:  ("v3" <-[sliceT uint64T] "$r0");;;
    let: "v4" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := slice.elem_ref uint64T (![sliceT uint64T] "x") #2 in
    do:  ("v4" <-[ptrT] "$r0");;;
    return: ((((((![uint64T] "v1") + (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "v2") #0))) + (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "v3") #1))) + (![uint64T] (![ptrT] "v4"))) + (slice.len (![sliceT uint64T] "x"))) + (slice.cap (![sliceT uint64T] "x")))).

(* go: slices.go:14:6 *)
Definition makeSingletonSlice : val :=
  rec: "makeSingletonSlice" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    return: ((let: "$sl0" := ![uint64T] "x" in
     slice.literal uint64T ["$sl0"]))).

Definition thing : go_type := structT [
  "x" :: uint64T
]%struct.

Definition thing__mset : list (string * val) := [
].

Definition thing__mset_ptr : list (string * val) := [
].

Definition sliceOfThings : go_type := structT [
  "things" :: sliceT thing
]%struct.

(* go: slices.go:26:25 *)
Definition sliceOfThings__getThingRef : val :=
  rec: "sliceOfThings__getThingRef" "ts" "i" :=
    exception_do (let: "ts" := ref_ty sliceOfThings "ts" in
    let: "i" := ref_ty uint64T "i" in
    return: (slice.elem_ref thing (![sliceT thing] (struct.field_ref sliceOfThings "things" "ts")) (![uint64T] "i"))).

Definition sliceOfThings__mset : list (string * val) := [
  ("getThingRef", sliceOfThings__getThingRef)
].

Definition sliceOfThings__mset_ptr : list (string * val) := [
  ("getThingRef", (Î»: "r", sliceOfThings__getThingRef (![sliceOfThings] "r"))%V)
].

(* go: slices.go:30:6 *)
Definition makeAlias : val :=
  rec: "makeAlias" <> :=
    exception_do (return: (slice.make2 boolT #10)).

(* Skip is a placeholder for some impure code

   go: spawn.go:8:6 *)
Definition Skip : val :=
  rec: "Skip" <> :=
    exception_do (do:  #()).

(* go: spawn.go:10:6 *)
Definition simpleSpawn : val :=
  rec: "simpleSpawn" <> :=
    exception_do (let: "l" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  ("l" <-[ptrT] "$r0");;;
    let: "v" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty uint64T (zero_val uint64T) in
    do:  ("v" <-[ptrT] "$r0");;;
    let: "$go" := (Î»: <>,
      do:  ((sync.Mutex__Lock (![ptrT] "l")) #());;;
      let: "x" := ref_ty uint64T (zero_val uint64T) in
      let: "$r0" := ![uint64T] (![ptrT] "v") in
      do:  ("x" <-[uint64T] "$r0");;;
      (if: (![uint64T] "x") > #0
      then do:  (Skip #())
      else do:  #());;;
      do:  ((sync.Mutex__Unlock (![ptrT] "l")) #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((sync.Mutex__Lock (![ptrT] "l")) #());;;
    let: "$r0" := #1 in
    do:  ((![ptrT] "v") <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] "l")) #())).

(* go: spawn.go:26:6 *)
Definition threadCode : val :=
  rec: "threadCode" "tid" :=
    exception_do (let: "tid" := ref_ty uint64T "tid" in
    do:  #()).

(* go: spawn.go:28:6 *)
Definition loopSpawn : val :=
  rec: "loopSpawn" <> :=
    exception_do ((let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #0 in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (Î»: <>, (![uint64T] "i") < #10); (Î»: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #1))) := Î»: <>,
      let: "i" := ref_ty uint64T (zero_val uint64T) in
      let: "$r0" := ![uint64T] "i" in
      do:  ("i" <-[uint64T] "$r0");;;
      let: "$go" := (Î»: <>,
        do:  (let: "$a0" := ![uint64T] "i" in
        threadCode "$a0")
        ) in
      do:  (Fork ("$go" #()))));;;
    (let: "dummy" := ref_ty boolT (zero_val boolT) in
    let: "$r0" := #true in
    do:  ("dummy" <-[boolT] "$r0");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      let: "$r0" := (~ (![boolT] "dummy")) in
      do:  ("dummy" <-[boolT] "$r0");;;
      continue: #()))).

(* go: strings.go:5:6 *)
Definition stringAppend : val :=
  rec: "stringAppend" "s" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "s" := ref_ty stringT "s" in
    return: (((#(str "prefix ") + (![stringT] "s")) + #(str " ")) + (let: "$a0" := ![uint64T] "x" in
     primitive.UInt64ToString "$a0"))).

(* go: strings.go:9:6 *)
Definition stringLength : val :=
  rec: "stringLength" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    return: (StringLength (![stringT] "s"))).

Definition Point : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
]%struct.

(* go: struct_method.go:8:16 *)
Definition Point__Add : val :=
  rec: "Point__Add" "c" "z" :=
    exception_do (let: "c" := ref_ty Point "c" in
    let: "z" := ref_ty uint64T "z" in
    return: (((![uint64T] (struct.field_ref Point "x" "c")) + (![uint64T] (struct.field_ref Point "y" "c"))) + (![uint64T] "z"))).

(* go: struct_method.go:12:16 *)
Definition Point__GetField : val :=
  rec: "Point__GetField" "c" <> :=
    exception_do (let: "c" := ref_ty Point "c" in
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (struct.field_ref Point "x" "c") in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (struct.field_ref Point "y" "c") in
    do:  ("y" <-[uint64T] "$r0");;;
    return: ((![uint64T] "x") + (![uint64T] "y"))).

Definition Point__mset : list (string * val) := [
  ("Add", Point__Add);
  ("GetField", Point__GetField)
].

Definition Point__mset_ptr : list (string * val) := [
  ("Add", (Î»: "r", Point__Add (![Point] "r"))%V);
  ("GetField", (Î»: "r", Point__GetField (![Point] "r"))%V)
].

(* go: struct_method.go:18:6 *)
Definition UseAdd : val :=
  rec: "UseAdd" <> :=
    exception_do (let: "c" := ref_ty Point (zero_val Point) in
    let: "$r0" := struct.make Point [{
      "x" ::= #2;
      "y" ::= #3
    }] in
    do:  ("c" <-[Point] "$r0");;;
    let: "r" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := let: "$a0" := #4 in
    (Point__Add (![ptrT] "c")) "$a0" in
    do:  ("r" <-[uint64T] "$r0");;;
    return: (![uint64T] "r")).

(* go: struct_method.go:24:6 *)
Definition UseAddWithLiteral : val :=
  rec: "UseAddWithLiteral" <> :=
    exception_do (let: "r" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := let: "$a0" := #4 in
    (Point__Add (struct.make Point [{
      "x" ::= #2;
      "y" ::= #3
    }])) "$a0" in
    do:  ("r" <-[uint64T] "$r0");;;
    return: (![uint64T] "r")).

Definition TwoInts : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
]%struct.

Definition TwoInts__mset : list (string * val) := [
].

Definition TwoInts__mset_ptr : list (string * val) := [
].

Definition S : go_type := structT [
  "a" :: uint64T;
  "b" :: TwoInts;
  "c" :: boolT
]%struct.

(* go: struct_pointers.go:30:12 *)
Definition S__readBVal : val :=
  rec: "S__readBVal" "s" <> :=
    exception_do (let: "s" := ref_ty S "s" in
    return: (![TwoInts] (struct.field_ref S "b" "s"))).

Definition S__mset : list (string * val) := [
  ("readBVal", S__readBVal)
].

(* go: struct_pointers.go:38:13 *)
Definition S__negateC : val :=
  rec: "S__negateC" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    let: "$r0" := (~ (![boolT] (struct.field_ref S "c" (![ptrT] "s")))) in
    do:  ((struct.field_ref S "c" (![ptrT] "s")) <-[boolT] "$r0")).

(* go: struct_pointers.go:22:13 *)
Definition S__readA : val :=
  rec: "S__readA" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (![uint64T] (struct.field_ref S "a" (![ptrT] "s")))).

(* go: struct_pointers.go:26:13 *)
Definition S__readB : val :=
  rec: "S__readB" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (![TwoInts] (struct.field_ref S "b" (![ptrT] "s")))).

(* go: struct_pointers.go:42:13 *)
Definition S__refC : val :=
  rec: "S__refC" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (struct.field_ref S "c" (![ptrT] "s"))).

(* go: struct_pointers.go:34:13 *)
Definition S__writeB : val :=
  rec: "S__writeB" "s" "two" :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    let: "two" := ref_ty TwoInts "two" in
    let: "$r0" := ![TwoInts] "two" in
    do:  ((struct.field_ref S "b" (![ptrT] "s")) <-[TwoInts] "$r0")).

Definition S__mset_ptr : list (string * val) := [
  ("negateC", S__negateC);
  ("readA", S__readA);
  ("readB", S__readB);
  ("refC", S__refC);
  ("writeB", S__writeB);
  ("readBVal", (Î»: "r", S__readBVal (![S] "r"))%V)
].

(* go: struct_pointers.go:14:6 *)
Definition NewS : val :=
  rec: "NewS" <> :=
    exception_do (return: (ref_ty S (struct.make S [{
       "a" ::= #2;
       "b" ::= struct.make TwoInts [{
         "x" ::= #1;
         "y" ::= #2
       }];
       "c" ::= #true
     }]))).

(* go: struct_pointers.go:46:6 *)
Definition localSRef : val :=
  rec: "localSRef" <> :=
    exception_do (let: "s" := ref_ty S (zero_val S) in
    return: (struct.field_ref S "b" "s")).

(* go: struct_pointers.go:54:6 *)
Definition setField : val :=
  rec: "setField" <> :=
    exception_do (let: "s" := ref_ty S (zero_val S) in
    let: "$r0" := #0 in
    do:  ((struct.field_ref S "a" "s") <-[uint64T] "$r0");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref S "c" "s") <-[boolT] "$r0");;;
    return: (![S] "s")).

(* DoSomeLocking uses the entire lock API

   go: synchronization.go:6:6 *)
Definition DoSomeLocking : val :=
  rec: "DoSomeLocking" "l" :=
    exception_do (let: "l" := ref_ty ptrT "l" in
    do:  ((sync.Mutex__Lock (![ptrT] "l")) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "l")) #())).

(* go: synchronization.go:15:6 *)
Definition makeLock : val :=
  rec: "makeLock" <> :=
    exception_do (let: "l" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  ("l" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := ![ptrT] "l" in
    DoSomeLocking "$a0")).

(* go: time.go:5:6 *)
Definition sleep : val :=
  rec: "sleep" <> :=
    exception_do (do:  (let: "$a0" := #1000 in
    primitive.Sleep "$a0")).

Definition A : go_type := structT [
]%struct.

Definition B : go_type := structT [
  "a" :: sliceT A
]%struct.

Definition B__mset : list (string * val) := [
].

Definition B__mset_ptr : list (string * val) := [
].

Definition A__mset : list (string * val) := [
].

Definition A__mset_ptr : list (string * val) := [
].

(* go: trailing_call.go:3:6 *)
Definition mkInt : val :=
  rec: "mkInt" <> :=
    exception_do (return: (#42)).

(* go: trailing_call.go:7:6 *)
Definition mkNothing : val :=
  rec: "mkNothing" <> :=
    exception_do (do:  (mkInt #())).

Definition my_u64 : go_type := uint64T.

Definition Timestamp : go_type := uint64T.

Definition Timestamp__mset : list (string * val) := [
].

Definition Timestamp__mset_ptr : list (string * val) := [
].

Definition UseTypeAbbrev : go_type := uint64T.

Definition UseTypeAbbrev__mset : list (string * val) := [
].

Definition UseTypeAbbrev__mset_ptr : list (string * val) := [
].

Definition UseNamedType : go_type := Timestamp.

Definition UseNamedType__mset : list (string * val) := [
].

Definition UseNamedType__mset_ptr : list (string * val) := [
].

(* go: type_alias.go:11:6 *)
Definition convertToAlias : val :=
  rec: "convertToAlias" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := #2 in
    do:  ("x" <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: varargs.go:3:6 *)
Definition variadicFunc : val :=
  rec: "variadicFunc" "a" "b" "cs" :=
    exception_do (let: "cs" := ref_ty (sliceT byteT) "cs" in
    let: "b" := ref_ty stringT "b" in
    let: "a" := ref_ty uint64T "a" in
    do:  #()).

(* go: varargs.go:6:6 *)
Definition testVariadicCall : val :=
  rec: "testVariadicCall" <> :=
    exception_do (do:  (let: "$a0" := #10 in
    let: "$a1" := #(str "abc") in
    let: "$a2" := (let: "$sl0" := #(U8 0) in
    let: "$sl1" := #(U8 1) in
    let: "$sl2" := #(U8 2) in
    let: "$sl3" := #(U8 3) in
    slice.literal byteT ["$sl0"; "$sl1"; "$sl2"; "$sl3"]) in
    variadicFunc "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := #10 in
    let: "$a1" := #(str "abc") in
    let: "$a2" := slice.nil in
    variadicFunc "$a0" "$a1" "$a2");;;
    let: "c" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    do:  (let: "$a0" := #10 in
    let: "$a1" := #(str "abc") in
    let: "$a2" := ![sliceT byteT] "c" in
    variadicFunc "$a0" "$a1" "$a2")).

(* go: varargs.go:13:6 *)
Definition returnMultiple : val :=
  rec: "returnMultiple" <> :=
    exception_do (return: (#0, #(str "xyz"), #(U8 0), #(U8 0))).

(* go: varargs.go:17:6 *)
Definition testVariadicPassThrough : val :=
  rec: "testVariadicPassThrough" <> :=
    exception_do (do:  (let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (returnMultiple #()) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    let: "$a2" := (let: "$sl0" := "$ret2" in
    let: "$sl1" := "$ret3" in
    slice.literal byteT ["$sl0"; "$sl1"]) in
    variadicFunc "$a0" "$a1" "$a2")).
