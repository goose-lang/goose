(* autogenerated from github.com/tchajed/goose/testdata/examples/semantics *)
From New.golang Require Import defn.
From New.code Require github_com.tchajed.goose.machine.
From New.code Require github_com.tchajed.goose.machine.disk.
From New.code Require sync.

From New Require Import disk_prelude.

(* allocator.go *)

Definition unit : go_type := structT [
].

Definition unit__mset : list (string * val) := [
].

Definition findKey : val :=
  rec: "findKey" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T unit) "m" in
    let: "found" := ref_ty uint64T #0 in
    let: "ok" := ref_ty boolT #false in
    do:  MapIter (![mapT uint64T unit] "m") (λ: "k" <>,
      (if: (~ (![boolT] "ok"))
      then
        let: "$a0" := ![uint64T] "k" in
        do:  "found" <-[uint64T] "$a0";;;
        let: "$a0" := #true in
        do:  "ok" <-[boolT] "$a0";;;
        do:  #()
      else do:  #());;;
      do:  #());;;
    return: (![uint64T] "found", ![boolT] "ok");;;
    do:  #()).

Definition allocate : val :=
  rec: "allocate" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T unit) "m" in
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "k" := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := findKey (![mapT uint64T unit] "m") in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "k" <-[uint64T] "$a0";;;
    do:  MapDelete (![mapT uint64T unit] "m") (![uint64T] "k");;;
    return: (![uint64T] "k", ![boolT] "ok");;;
    do:  #()).

Definition freeRange : val :=
  rec: "freeRange" "sz" :=
    exception_do (let: "sz" := ref_ty uint64T "sz" in
    let: "m" := ref_ty (mapT uint64T unit) (zero_val (mapT uint64T unit)) in
    let: "$a0" := map.make uint64T unit #() in
    do:  "m" <-[mapT uint64T unit] "$a0";;;
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "sz")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "$a0" := struct.make unit [{
      }] in
      do:  map.insert (![mapT uint64T unit] "m") (![uint64T] "i") "$a0";;;
      do:  #()));;;
    return: (![mapT uint64T unit] "m");;;
    do:  #()).

Definition testAllocateDistinct : val :=
  rec: "testAllocateDistinct" <> :=
    exception_do (let: "free" := ref_ty (mapT uint64T unit) (zero_val (mapT uint64T unit)) in
    let: "$a0" := freeRange #4 in
    do:  "free" <-[mapT uint64T unit] "$a0";;;
    let: <> := ref_ty boolT (zero_val boolT) in
    let: "a1" := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := allocate (![mapT uint64T unit] "free") in
    do:  "$a1";;;
    do:  "a1" <-[uint64T] "$a0";;;
    let: <> := ref_ty boolT (zero_val boolT) in
    let: "a2" := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := allocate (![mapT uint64T unit] "free") in
    do:  "$a1";;;
    do:  "a2" <-[uint64T] "$a0";;;
    return: ((![uint64T] "a1") ≠ (![uint64T] "a2"));;;
    do:  #()).

Definition testAllocateFull : val :=
  rec: "testAllocateFull" <> :=
    exception_do (let: "free" := ref_ty (mapT uint64T unit) (zero_val (mapT uint64T unit)) in
    let: "$a0" := freeRange #2 in
    do:  "free" <-[mapT uint64T unit] "$a0";;;
    let: "ok1" := ref_ty boolT (zero_val boolT) in
    let: <> := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := allocate (![mapT uint64T unit] "free") in
    do:  "ok1" <-[boolT] "$a1";;;
    do:  "$a0";;;
    let: "ok2" := ref_ty boolT (zero_val boolT) in
    let: <> := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := allocate (![mapT uint64T unit] "free") in
    do:  "ok2" <-[boolT] "$a1";;;
    do:  "$a0";;;
    let: "ok3" := ref_ty boolT (zero_val boolT) in
    let: <> := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := allocate (![mapT uint64T unit] "free") in
    do:  "ok3" <-[boolT] "$a1";;;
    do:  "$a0";;;
    return: (((![boolT] "ok1") && (![boolT] "ok2")) && (~ (![boolT] "ok3")));;;
    do:  #()).

(* closures.go *)

Definition AdderType : go_type := funcT.

Definition MultipleArgsType : go_type := funcT.

Definition adder : val :=
  rec: "adder" <> :=
    exception_do (let: "sum" := ref_ty uint64T #0 in
    return: ((λ: "x",
       do:  "sum" <-[uint64T] ((![uint64T] "sum") + (![uint64T] "x"));;;
       return: (![uint64T] "sum");;;
       do:  #()
       ));;;
    do:  #()).

Definition testClosureBasic : val :=
  rec: "testClosureBasic" <> :=
    exception_do (let: "pos" := ref_ty funcT (zero_val funcT) in
    let: "$a0" := adder #() in
    do:  "pos" <-[funcT] "$a0";;;
    let: "doub" := ref_ty funcT (zero_val funcT) in
    let: "$a0" := adder #() in
    do:  "doub" <-[funcT] "$a0";;;
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      do:  (![funcT] "pos") (![uint64T] "i");;;
      do:  (![funcT] "doub") (#2 * (![uint64T] "i"));;;
      do:  #()));;;
    (if: (((![funcT] "pos") #0) = #45) && (((![funcT] "doub") #0) = #90)
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    return: (#false);;;
    do:  #()).

(* comparisons.go *)

Definition testCompareAll : val :=
  rec: "testCompareAll" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "nok" := ref_ty boolT #false in
    let: "$a0" := (![boolT] "ok") && (#1 < #2) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (#2 < #1) in
    do:  "nok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (#1 ≤ #2) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (#2 ≤ #2) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (#2 ≤ #1) in
    do:  "nok" <-[boolT] "$a0";;;
    (if: ![boolT] "nok"
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testCompareGT : val :=
  rec: "testCompareGT" <> :=
    exception_do (let: "x" := ref_ty uint64T #4 in
    let: "y" := ref_ty uint64T #5 in
    let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") > #4) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") > (![uint64T] "x")) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testCompareGE : val :=
  rec: "testCompareGE" <> :=
    exception_do (let: "x" := ref_ty uint64T #4 in
    let: "y" := ref_ty uint64T #5 in
    let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") ≥ #4) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") ≥ #5) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") ≥ (![uint64T] "x")) in
    do:  "ok" <-[boolT] "$a0";;;
    (if: (![uint64T] "y") > #5
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testCompareLT : val :=
  rec: "testCompareLT" <> :=
    exception_do (let: "x" := ref_ty uint64T #4 in
    let: "y" := ref_ty uint64T #5 in
    let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") < #6) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "x") < (![uint64T] "y")) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testCompareLE : val :=
  rec: "testCompareLE" <> :=
    exception_do (let: "x" := ref_ty uint64T #4 in
    let: "y" := ref_ty uint64T #5 in
    let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") ≤ #6) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "y") ≤ #5) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "x") ≤ (![uint64T] "y")) in
    do:  "ok" <-[boolT] "$a0";;;
    (if: (![uint64T] "y") < #5
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ok");;;
    do:  #()).

(* conversions.go *)

Definition literalCast : val :=
  rec: "literalCast" <> :=
    exception_do (let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #2 in
    do:  "x" <-[uint64T] "$a0";;;
    return: ((![uint64T] "x") + #2);;;
    do:  #()).

Definition stringToByteSlice : val :=
  rec: "stringToByteSlice" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    let: "p" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := StringToBytes (![stringT] "s") in
    do:  "p" <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "p");;;
    do:  #()).

Definition byteSliceToString : val :=
  rec: "byteSliceToString" "p" :=
    exception_do (let: "p" := ref_ty (sliceT byteT) "p" in
    return: (StringFromBytes (![sliceT byteT] "p"));;;
    do:  #()).

(* tests *)
Definition testByteSliceToString : val :=
  rec: "testByteSliceToString" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #3 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 65) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #0) <-[byteT] "$a0";;;
    let: "$a0" := #(U8 66) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #1) <-[byteT] "$a0";;;
    let: "$a0" := #(U8 67) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #2) <-[byteT] "$a0";;;
    return: ((byteSliceToString (![sliceT byteT] "x")) = #(str "ABC"));;;
    do:  #()).

(* copy.go *)

Definition testCopySimple : val :=
  rec: "testCopySimple" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #10 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 1) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #3) <-[byteT] "$a0";;;
    let: "y" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #10 in
    do:  "y" <-[sliceT byteT] "$a0";;;
    do:  slice.copy byteT (![sliceT byteT] "y") (![sliceT byteT] "x");;;
    return: ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #3)) = #(U8 1));;;
    do:  #()).

Definition testCopyShorterDst : val :=
  rec: "testCopyShorterDst" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #15 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 1) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #3) <-[byteT] "$a0";;;
    let: "$a0" := #(U8 2) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #12) <-[byteT] "$a0";;;
    let: "y" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #10 in
    do:  "y" <-[sliceT byteT] "$a0";;;
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := slice.copy byteT (![sliceT byteT] "y") (![sliceT byteT] "x") in
    do:  "n" <-[uint64T] "$a0";;;
    return: (((![uint64T] "n") = #10) && ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #3)) = #(U8 1)));;;
    do:  #()).

Definition testCopyShorterSrc : val :=
  rec: "testCopyShorterSrc" <> :=
    exception_do (let: "x" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #10 in
    do:  "x" <-[sliceT byteT] "$a0";;;
    let: "y" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #15 in
    do:  "y" <-[sliceT byteT] "$a0";;;
    let: "$a0" := #(U8 1) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "x") #3) <-[byteT] "$a0";;;
    let: "$a0" := #(U8 2) in
    do:  (slice.elem_ref byteT (![sliceT byteT] "y") #12) <-[byteT] "$a0";;;
    let: "n" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := slice.copy byteT (![sliceT byteT] "y") (![sliceT byteT] "x") in
    do:  "n" <-[uint64T] "$a0";;;
    return: ((((![uint64T] "n") = #10) && ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #3)) = #(U8 1))) && ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "y") #12)) = #(U8 2)));;;
    do:  #()).

(* encoding.go *)

Definition Enc : go_type := structT [
  "p" :: sliceT byteT
].

Definition Enc__mset : list (string * val) := [
  ("consume", Enc__consume)
].

Definition Enc__consume : val :=
  rec: "Enc__consume" "e" "n" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "n" := ref_ty uint64T "n" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Enc "p" (![ptrT] "e")) in
    slice.slice byteT "$s" #0 (![uint64T] "n") in
    do:  "b" <-[sliceT byteT] "$a0";;;
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Enc "p" (![ptrT] "e")) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s") in
    do:  (struct.field_ref Enc "p" (![ptrT] "e")) <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "b");;;
    do:  #()).

Definition Dec : go_type := structT [
  "p" :: sliceT byteT
].

Definition Dec__mset : list (string * val) := [
  ("consume", Dec__consume)
].

Definition Dec__consume : val :=
  rec: "Dec__consume" "d" "n" :=
    exception_do (let: "d" := ref_ty ptrT "d" in
    let: "n" := ref_ty uint64T "n" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Dec "p" (![ptrT] "d")) in
    slice.slice byteT "$s" #0 (![uint64T] "n") in
    do:  "b" <-[sliceT byteT] "$a0";;;
    let: "$a0" := let: "$s" := ![sliceT byteT] (struct.field_ref Dec "p" (![ptrT] "d")) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s") in
    do:  (struct.field_ref Dec "p" (![ptrT] "d")) <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "b");;;
    do:  #()).

Definition roundtripEncDec32 : val :=
  rec: "roundtripEncDec32" "x" :=
    exception_do (let: "x" := ref_ty uint32T "x" in
    let: "r" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #4 in
    do:  "r" <-[sliceT byteT] "$a0";;;
    let: "e" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty Enc (struct.make Enc [{
      "p" ::= ![sliceT byteT] "r"
    }]) in
    do:  "e" <-[ptrT] "$a0";;;
    let: "d" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty Dec (struct.make Dec [{
      "p" ::= ![sliceT byteT] "r"
    }]) in
    do:  "d" <-[ptrT] "$a0";;;
    do:  machine.UInt32Put ((Enc__consume (![ptrT] "e")) #4) (![uint32T] "x");;;
    return: (machine.UInt32Get ((Dec__consume (![ptrT] "d")) #4));;;
    do:  #()).

Definition roundtripEncDec64 : val :=
  rec: "roundtripEncDec64" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "r" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #8 in
    do:  "r" <-[sliceT byteT] "$a0";;;
    let: "e" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty Enc (struct.make Enc [{
      "p" ::= ![sliceT byteT] "r"
    }]) in
    do:  "e" <-[ptrT] "$a0";;;
    let: "d" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty Dec (struct.make Dec [{
      "p" ::= ![sliceT byteT] "r"
    }]) in
    do:  "d" <-[ptrT] "$a0";;;
    do:  machine.UInt64Put ((Enc__consume (![ptrT] "e")) #8) (![uint64T] "x");;;
    return: (machine.UInt64Get ((Dec__consume (![ptrT] "d")) #8));;;
    do:  #()).

(* tests *)
Definition testEncDec32Simple : val :=
  rec: "testEncDec32Simple" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 #(U32 0)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 #(U32 1)) = #(U32 1)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 #(U32 1231234)) = #(U32 1231234)) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition failing_testEncDec32 : val :=
  rec: "failing_testEncDec32" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 #(U32 3434807466)) = #(U32 3434807466)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #20)) = (#1 ≪ #20)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #18)) = (#1 ≪ #18)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #10)) = (#1 ≪ #10)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #0)) = (#1 ≪ #0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec32 ((#1 ≪ #32) - #1)) = ((#1 ≪ #32) - #1)) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testEncDec64Simple : val :=
  rec: "testEncDec64Simple" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 #0) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 #1) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 #1231234) = #1231234) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testEncDec64 : val :=
  rec: "testEncDec64" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 #62206846038638762) = #62206846038638762) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #63)) = (#1 ≪ #63)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #47)) = (#1 ≪ #47)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #20)) = (#1 ≪ #20)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #18)) = (#1 ≪ #18)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #10)) = (#1 ≪ #10)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #0)) = (#1 ≪ #0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((roundtripEncDec64 ((#1 ≪ #64) - #1)) = ((#1 ≪ #64) - #1)) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

(* first_class_function.go *)

Definition FirstClassFunction : val :=
  rec: "FirstClassFunction" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    return: ((![uint64T] "a") + #10);;;
    do:  #()).

Definition ApplyF : val :=
  rec: "ApplyF" "a" "f" :=
    exception_do (let: "f" := ref_ty funcT "f" in
    let: "a" := ref_ty uint64T "a" in
    return: ((![funcT] "f") (![uint64T] "a"));;;
    do:  #()).

Definition testFirstClassFunction : val :=
  rec: "testFirstClassFunction" <> :=
    exception_do (return: ((ApplyF #1 FirstClassFunction) = #11);;;
    do:  #()).

(* function_ordering.go *)

Definition Editor : go_type := structT [
  "s" :: sliceT uint64T;
  "next_val" :: uint64T
].

Definition Editor__mset : list (string * val) := [
  ("AdvanceReturn", Editor__AdvanceReturn)
].

(* advances the array editor, and returns the value it wrote, storing
   "next" in next_val *)
Definition Editor__AdvanceReturn : val :=
  rec: "Editor__AdvanceReturn" "e" "next" :=
    exception_do (let: "e" := ref_ty ptrT "e" in
    let: "next" := ref_ty uint64T "next" in
    let: "tmp" := ref_ty uint64T (![uint64T] (struct.field_ref Editor "next_val" (![ptrT] "e"))) in
    let: "$a0" := ![uint64T] "tmp" in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] (struct.field_ref Editor "s" (![ptrT] "e"))) #0) <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "next" in
    do:  (struct.field_ref Editor "next_val" (![ptrT] "e")) <-[uint64T] "$a0";;;
    let: "$a0" := let: "$s" := ![sliceT uint64T] (struct.field_ref Editor "s" (![ptrT] "e")) in
    slice.slice uint64T "$s" #1 (slice.len "$s") in
    do:  (struct.field_ref Editor "s" (![ptrT] "e")) <-[sliceT uint64T] "$a0";;;
    return: (![uint64T] "tmp");;;
    do:  #()).

(* we call this function with side-effectful function calls as arguments,
   its implementation is unimportant *)
Definition addFour64 : val :=
  rec: "addFour64" "a" "b" "c" "d" :=
    exception_do (let: "d" := ref_ty uint64T "d" in
    let: "c" := ref_ty uint64T "c" in
    let: "b" := ref_ty uint64T "b" in
    let: "a" := ref_ty uint64T "a" in
    return: ((((![uint64T] "a") + (![uint64T] "b")) + (![uint64T] "c")) + (![uint64T] "d"));;;
    do:  #()).

Definition Pair : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition Pair__mset : list (string * val) := [
].

(* tests *)
Definition failing_testFunctionOrdering : val :=
  rec: "failing_testFunctionOrdering" <> :=
    exception_do (let: "arr" := ref_ty (sliceT uint64T) (slice.make2 uint64T #5) in
    let: "e1" := ref_ty Editor (zero_val Editor) in
    let: "$a0" := struct.make Editor [{
      "s" ::= let: "$s" := ![sliceT uint64T] "arr" in
      slice.slice uint64T "$s" #0 (slice.len "$s");
      "next_val" ::= #1
    }] in
    do:  "e1" <-[Editor] "$a0";;;
    let: "e2" := ref_ty Editor (zero_val Editor) in
    let: "$a0" := struct.make Editor [{
      "s" ::= let: "$s" := ![sliceT uint64T] "arr" in
      slice.slice uint64T "$s" #0 (slice.len "$s");
      "next_val" ::= #101
    }] in
    do:  "e2" <-[Editor] "$a0";;;
    (if: (((Editor__AdvanceReturn (![Editor] "e1")) #2) + ((Editor__AdvanceReturn (![Editor] "e2")) #102)) ≠ #102
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #0)) ≠ #101
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    (if: (addFour64 ((Editor__AdvanceReturn (![Editor] "e1")) #3) ((Editor__AdvanceReturn (![Editor] "e2")) #103) ((Editor__AdvanceReturn (![Editor] "e2")) #104) ((Editor__AdvanceReturn (![Editor] "e1")) #4)) ≠ #210
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #1)) ≠ #102
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #2)) ≠ #3
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    let: "p" := ref_ty Pair (zero_val Pair) in
    let: "$a0" := struct.make Pair [{
      "x" ::= (Editor__AdvanceReturn (![Editor] "e1")) #5;
      "y" ::= (Editor__AdvanceReturn (![Editor] "e2")) #105
    }] in
    do:  "p" <-[Pair] "$a0";;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #3)) ≠ #104
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    let: "q" := ref_ty Pair (zero_val Pair) in
    let: "$a0" := struct.make Pair [{
      "y" ::= (Editor__AdvanceReturn (![Editor] "e1")) #6;
      "x" ::= (Editor__AdvanceReturn (![Editor] "e2")) #106
    }] in
    do:  "q" <-[Pair] "$a0";;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #4)) ≠ #105
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    return: (((![uint64T] (struct.field_ref Pair "x" "p")) + (![uint64T] (struct.field_ref Pair "x" "q"))) = #109);;;
    do:  #()).

Definition storeAndReturn : val :=
  rec: "storeAndReturn" "x" "v" :=
    exception_do (let: "v" := ref_ty uint64T "v" in
    let: "x" := ref_ty ptrT "x" in
    let: "$a0" := ![uint64T] "v" in
    do:  (![ptrT] "x") <-[uint64T] "$a0";;;
    return: (![uint64T] "v");;;
    do:  #()).

(* Goose has a right-to-left evaluation order for function arguments,
   which is incorrect. *)
Definition failing_testArgumentOrder : val :=
  rec: "failing_testArgumentOrder" <> :=
    exception_do (let: "x" := ref_ty uint64T #0 in
    do:  addFour64 (storeAndReturn "x" #1) (storeAndReturn "x" #2) (storeAndReturn "x" #3) (storeAndReturn "x" #4);;;
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "$a0" := (![uint64T] "x") = #4 in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

(* int_conversions.go *)

Definition testU64ToU32 : val :=
  rec: "testU64ToU32" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #1230 in
    do:  "x" <-[uint64T] "$a0";;;
    let: "y" := ref_ty uint32T (zero_val uint32T) in
    let: "$a0" := #(U32 1230) in
    do:  "y" <-[uint32T] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((to_u32 (![uint64T] "x")) = (![uint32T] "y")) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((to_u64 (![uint32T] "y")) = (![uint64T] "x")) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testU32Len : val :=
  rec: "testU32Len" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #100 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    return: ((to_u32 (slice.len (![sliceT byteT] "s"))) = #(U32 100));;;
    do:  #()).

Definition Uint32 : go_type := uint32T.

Definition Uint32__mset : list (string * val) := [
].

(* https://github.com/tchajed/goose/issues/14 *)
Definition failing_testU32NewtypeLen : val :=
  rec: "failing_testU32NewtypeLen" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #20 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    return: ((to_u32 (slice.len (![sliceT byteT] "s"))) = #(U32 20));;;
    do:  #()).

(* interfaces.go *)

Definition geometryInterface : go_type := interfaceT.

Definition geometryInterface__mset : list (string * val) := [
].

Definition measureArea : val :=
  rec: "measureArea" "t" :=
    exception_do (let: "t" := ref_ty geometryInterface "t" in
    return: ((__Square (![geometryInterface] "t")) #());;;
    do:  #()).

Definition measureVolumePlusNM : val :=
  rec: "measureVolumePlusNM" "t" "n" "m" :=
    exception_do (let: "m" := ref_ty uint64T "m" in
    let: "n" := ref_ty uint64T "n" in
    let: "t" := ref_ty geometryInterface "t" in
    return: ((((__Volume (![geometryInterface] "t")) #()) + (![uint64T] "n")) + (![uint64T] "m"));;;
    do:  #()).

Definition measureVolume : val :=
  rec: "measureVolume" "t" :=
    exception_do (let: "t" := ref_ty geometryInterface "t" in
    return: ((__Volume (![geometryInterface] "t")) #());;;
    do:  #()).

Definition SquareStruct : go_type := structT [
  "Side" :: uint64T
].

Definition SquareStruct__mset : list (string * val) := [
  ("Square", SquareStruct__Square)
  ("Volume", SquareStruct__Volume)
].

Definition SquareStruct__Square : val :=
  rec: "SquareStruct__Square" "t" <> :=
    exception_do (let: "t" := ref_ty SquareStruct "t" in
    return: ((![uint64T] (struct.field_ref SquareStruct "Side" "t")) * (![uint64T] (struct.field_ref SquareStruct "Side" "t")));;;
    do:  #()).

Definition SquareStruct__Volume : val :=
  rec: "SquareStruct__Volume" "t" <> :=
    exception_do (let: "t" := ref_ty SquareStruct "t" in
    return: (((![uint64T] (struct.field_ref SquareStruct "Side" "t")) * (![uint64T] (struct.field_ref SquareStruct "Side" "t"))) * (![uint64T] (struct.field_ref SquareStruct "Side" "t")));;;
    do:  #()).

Definition testBasicInterface : val :=
  rec: "testBasicInterface" <> :=
    exception_do (let: "s" := ref_ty SquareStruct (zero_val SquareStruct) in
    let: "$a0" := struct.make SquareStruct [{
      "Side" ::= #2
    }] in
    do:  "s" <-[SquareStruct] "$a0";;;
    return: ((measureArea (![SquareStruct] "s")) = #4);;;
    do:  #()).

Definition testAssignInterface : val :=
  rec: "testAssignInterface" <> :=
    exception_do (let: "s" := ref_ty SquareStruct (zero_val SquareStruct) in
    let: "$a0" := struct.make SquareStruct [{
      "Side" ::= #3
    }] in
    do:  "s" <-[SquareStruct] "$a0";;;
    let: "area" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := measureArea (![SquareStruct] "s") in
    do:  "area" <-[uint64T] "$a0";;;
    return: ((![uint64T] "area") = #9);;;
    do:  #()).

Definition testMultipleInterface : val :=
  rec: "testMultipleInterface" <> :=
    exception_do (let: "s" := ref_ty SquareStruct (zero_val SquareStruct) in
    let: "$a0" := struct.make SquareStruct [{
      "Side" ::= #3
    }] in
    do:  "s" <-[SquareStruct] "$a0";;;
    let: "square1" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := measureArea (![SquareStruct] "s") in
    do:  "square1" <-[uint64T] "$a0";;;
    let: "square2" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := measureArea (![SquareStruct] "s") in
    do:  "square2" <-[uint64T] "$a0";;;
    return: ((![uint64T] "square1") = (![uint64T] "square2"));;;
    do:  #()).

Definition testBinaryExprInterface : val :=
  rec: "testBinaryExprInterface" <> :=
    exception_do (let: "s" := ref_ty SquareStruct (zero_val SquareStruct) in
    let: "$a0" := struct.make SquareStruct [{
      "Side" ::= #3
    }] in
    do:  "s" <-[SquareStruct] "$a0";;;
    let: "square1" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := measureArea (![SquareStruct] "s") in
    do:  "square1" <-[uint64T] "$a0";;;
    let: "square2" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := measureVolume (![SquareStruct] "s") in
    do:  "square2" <-[uint64T] "$a0";;;
    return: (((![uint64T] "square1") = (measureArea (![SquareStruct] "s"))) && ((![uint64T] "square2") = (measureVolume (![SquareStruct] "s"))));;;
    do:  #()).

Definition testIfStmtInterface : val :=
  rec: "testIfStmtInterface" <> :=
    exception_do (let: "s" := ref_ty SquareStruct (zero_val SquareStruct) in
    let: "$a0" := struct.make SquareStruct [{
      "Side" ::= #3
    }] in
    do:  "s" <-[SquareStruct] "$a0";;;
    (if: (measureArea (![SquareStruct] "s")) = #9
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    return: (#false);;;
    do:  #()).

(* interfaces_failing.go *)

(* lock.go *)

(* We can't interpret multithreaded code, so this just checks that
   locks are correctly interpreted *)
Definition testsUseLocks : val :=
  rec: "testsUseLocks" <> :=
    exception_do (let: "m" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "m" <-[ptrT] "$a0";;;
    do:  (sync.Mutex__Lock (![ptrT] "m")) #();;;
    do:  (sync.Mutex__Unlock (![ptrT] "m")) #();;;
    return: (#true);;;
    do:  #()).

(* loops.go *)

(* helpers *)
Definition standardForLoop : val :=
  rec: "standardForLoop" "s" :=
    exception_do (let: "s" := ref_ty (sliceT uint64T) "s" in
    let: "sumPtr" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "sumPtr" <-[ptrT] "$a0";;;
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (slice.len (![sliceT uint64T] "s"))
      then
        let: "sum" := ref_ty uint64T (zero_val uint64T) in
        let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
        do:  "sum" <-[uint64T] "$a0";;;
        let: "x" := ref_ty uint64T (zero_val uint64T) in
        let: "$a0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "s") (![uint64T] "i")) in
        do:  "x" <-[uint64T] "$a0";;;
        let: "$a0" := (![uint64T] "sum") + (![uint64T] "x") in
        do:  (![ptrT] "sumPtr") <-[uint64T] "$a0";;;
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()
      else do:  #());;;
      break: #();;;
      do:  #()));;;
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] "sumPtr") in
    do:  "sum" <-[uint64T] "$a0";;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition LoopStruct : go_type := structT [
  "loopNext" :: ptrT
].

Definition LoopStruct__mset : list (string * val) := [
  ("forLoopWait", LoopStruct__forLoopWait)
].

Definition LoopStruct__forLoopWait : val :=
  rec: "LoopStruct__forLoopWait" "ls" "i" :=
    exception_do (let: "ls" := ref_ty LoopStruct "ls" in
    let: "i" := ref_ty uint64T "i" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "nxt" := ref_ty ptrT (zero_val ptrT) in
      let: "$a0" := ![ptrT] (struct.field_ref LoopStruct "loopNext" "ls") in
      do:  "nxt" <-[ptrT] "$a0";;;
      (if: (![uint64T] "i") < (![uint64T] (![ptrT] "nxt"))
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] (![ptrT] (struct.field_ref LoopStruct "loopNext" "ls"))) + #1 in
      do:  (![ptrT] (struct.field_ref LoopStruct "loopNext" "ls")) <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #());;;
    do:  #()).

(* tests *)
Definition testStandardForLoop : val :=
  rec: "testStandardForLoop" <> :=
    exception_do (let: "arr" := ref_ty (sliceT uint64T) (slice.make2 uint64T #4) in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "arr") #0) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #0)) + #1);;;
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "arr") #1) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #1)) + #3);;;
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "arr") #2) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #2)) + #5);;;
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "arr") #3) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #3)) + #7);;;
    return: ((standardForLoop (![sliceT uint64T] "arr")) = #16);;;
    do:  #()).

Definition testForLoopWait : val :=
  rec: "testForLoopWait" <> :=
    exception_do (let: "ls" := ref_ty LoopStruct (zero_val LoopStruct) in
    let: "$a0" := struct.make LoopStruct [{
      "loopNext" ::= ref_ty uint64T (zero_val uint64T)
    }] in
    do:  "ls" <-[LoopStruct] "$a0";;;
    do:  (LoopStruct__forLoopWait (![LoopStruct] "ls")) #3;;;
    return: ((![uint64T] (![ptrT] (struct.field_ref LoopStruct "loopNext" "ls"))) = #4);;;
    do:  #()).

Definition testBreakFromLoopWithContinue : val :=
  rec: "testBreakFromLoopWithContinue" <> :=
    exception_do (let: "i" := ref_ty uint64T #0 in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        break: #();;;
        do:  #()
      else do:  #());;;
      continue: #();;;
      do:  #());;;
    return: ((![uint64T] "i") = #1);;;
    do:  #()).

Definition testBreakFromLoopNoContinue : val :=
  rec: "testBreakFromLoopNoContinue" <> :=
    exception_do (let: "i" := ref_ty uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] "i") + #2 in
      do:  "i" <-[uint64T] "$a0";;;
      do:  #());;;
    return: ((![uint64T] "i") = #1);;;
    do:  #()).

Definition testBreakFromLoopNoContinueDouble : val :=
  rec: "testBreakFromLoopNoContinueDouble" <> :=
    exception_do (let: "i" := ref_ty uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") = #1
      then
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] "i") + #2 in
      do:  "i" <-[uint64T] "$a0";;;
      let: "$a0" := (![uint64T] "i") + #2 in
      do:  "i" <-[uint64T] "$a0";;;
      do:  #());;;
    return: ((![uint64T] "i") = #4);;;
    do:  #()).

Definition testBreakFromLoopForOnly : val :=
  rec: "testBreakFromLoopForOnly" <> :=
    exception_do (let: "i" := ref_ty uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      let: "$a0" := (![uint64T] "i") + #2 in
      do:  "i" <-[uint64T] "$a0";;;
      do:  #());;;
    return: ((![uint64T] "i") = #4);;;
    do:  #()).

Definition testBreakFromLoopAssignAndContinue : val :=
  rec: "testBreakFromLoopAssignAndContinue" <> :=
    exception_do (let: "i" := ref_ty uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "$a0" := (![uint64T] "i") + #2 in
      do:  "i" <-[uint64T] "$a0";;;
      continue: #();;;
      do:  #());;;
    return: ((![uint64T] "i") = #1);;;
    do:  #()).

Definition testNestedLoops : val :=
  rec: "testNestedLoops" <> :=
    exception_do (let: "ok1" := ref_ty boolT #false in
    let: "ok2" := ref_ty boolT #false in
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (let: "j" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := #0 in
      do:  "j" <-[uint64T] "$a0";;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: (![uint64T] "j") > #5
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        let: "$a0" := (![uint64T] "j") + #1 in
        do:  "j" <-[uint64T] "$a0";;;
        let: "$a0" := (![uint64T] "j") = #6 in
        do:  "ok1" <-[boolT] "$a0";;;
        continue: #();;;
        do:  #()));;;
      let: "$a0" := (![uint64T] "i") + #1 in
      do:  "i" <-[uint64T] "$a0";;;
      let: "$a0" := (![uint64T] "i") = #1 in
      do:  "ok2" <-[boolT] "$a0";;;
      break: #();;;
      do:  #()));;;
    return: ((![boolT] "ok1") && (![boolT] "ok2"));;;
    do:  #()).

Definition testNestedGoStyleLoops : val :=
  rec: "testNestedGoStyleLoops" <> :=
    exception_do (let: "ok" := ref_ty boolT #false in
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      (let: "j" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := #0 in
      do:  "j" <-[uint64T] "$a0";;;
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, do:  "j" <-[uint64T] ((![uint64T] "j") + #1);;;
      #()) := λ: <>,
        (if: #true
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        continue: #();;;
        do:  #()));;;
      let: "$a0" := (![uint64T] "i") = #9 in
      do:  "ok" <-[boolT] "$a0";;;
      do:  #()));;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testNestedGoStyleLoopsNoComparison : val :=
  rec: "testNestedGoStyleLoopsNoComparison" <> :=
    exception_do (let: "ok" := ref_ty boolT #false in
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      (let: "j" := ref_ty uint64T (zero_val uint64T) in
      let: "$a0" := #0 in
      do:  "j" <-[uint64T] "$a0";;;
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, do:  "j" <-[uint64T] ((![uint64T] "j") + #1);;;
      #()) := λ: <>,
        (if: #true
        then
          break: #();;;
          do:  #()
        else do:  #());;;
        continue: #();;;
        do:  #()));;;
      let: "$a0" := (![uint64T] "i") = #9 in
      do:  "ok" <-[boolT] "$a0";;;
      do:  #()));;;
    return: (![boolT] "ok");;;
    do:  #()).

(* maps.go *)

Definition IterateMapKeys : val :=
  rec: "IterateMapKeys" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    do:  MapIter (![mapT uint64T uint64T] "m") (λ: "k" <>,
      let: "$a0" := (![uint64T] "sum") + (![uint64T] "k") in
      do:  "sum" <-[uint64T] "$a0";;;
      do:  #());;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition IterateMapValues : val :=
  rec: "IterateMapValues" "m" :=
    exception_do (let: "m" := ref_ty (mapT uint64T uint64T) "m" in
    let: "sum" := ref_ty uint64T (zero_val uint64T) in
    do:  MapIter (![mapT uint64T uint64T] "m") (λ: <> "v",
      let: "$a0" := (![uint64T] "sum") + (![uint64T] "v") in
      do:  "sum" <-[uint64T] "$a0";;;
      do:  #());;;
    return: (![uint64T] "sum");;;
    do:  #()).

Definition testIterateMap : val :=
  rec: "testIterateMap" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "m" := ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T)) in
    let: "$a0" := map.make uint64T uint64T #() in
    do:  "m" <-[mapT uint64T uint64T] "$a0";;;
    let: "$a0" := #1 in
    do:  map.insert (![mapT uint64T uint64T] "m") #0 "$a0";;;
    let: "$a0" := #2 in
    do:  map.insert (![mapT uint64T uint64T] "m") #1 "$a0";;;
    let: "$a0" := #4 in
    do:  map.insert (![mapT uint64T uint64T] "m") #3 "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((IterateMapKeys (![mapT uint64T uint64T] "m")) = #4) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((IterateMapValues (![mapT uint64T uint64T] "m")) = #7) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testMapSize : val :=
  rec: "testMapSize" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "m" := ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T)) in
    let: "$a0" := map.make uint64T uint64T #() in
    do:  "m" <-[mapT uint64T uint64T] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((MapLen (![mapT uint64T uint64T] "m")) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := #1 in
    do:  map.insert (![mapT uint64T uint64T] "m") #0 "$a0";;;
    let: "$a0" := #2 in
    do:  map.insert (![mapT uint64T uint64T] "m") #1 "$a0";;;
    let: "$a0" := #4 in
    do:  map.insert (![mapT uint64T uint64T] "m") #3 "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((MapLen (![mapT uint64T uint64T] "m")) = #3) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

(* multiple_assign.go *)

Definition multReturnTwo : val :=
  rec: "multReturnTwo" <> :=
    exception_do (return: (#2, #3);;;
    do:  #()).

Definition testAssignTwo : val :=
  rec: "testAssignTwo" <> :=
    exception_do (let: "x" := ref_ty uint64T #10 in
    let: "y" := ref_ty uint64T #15 in
    let: ("$a0", "$a1") := multReturnTwo #() in
    do:  "y" <-[uint64T] "$a1";;;
    do:  "x" <-[uint64T] "$a0";;;
    return: (((![uint64T] "x") = #2) && ((![uint64T] "y") = #3));;;
    do:  #()).

Definition multReturnThree : val :=
  rec: "multReturnThree" <> :=
    exception_do (return: (#2, #true, #(U32 1));;;
    do:  #()).

Definition testAssignThree : val :=
  rec: "testAssignThree" <> :=
    exception_do (let: "x" := ref_ty uint64T #10 in
    let: "y" := ref_ty boolT #false in
    let: "z" := ref_ty uint32T #(U32 15) in
    let: (("$a0", "$a1"), "$a2") := multReturnThree #() in
    do:  "z" <-[uint32T] "$a2";;;
    do:  "y" <-[boolT] "$a1";;;
    do:  "x" <-[uint64T] "$a0";;;
    return: ((((![uint64T] "x") = #2) && ((![boolT] "y") = #true)) && ((![uint32T] "z") = #(U32 1)));;;
    do:  #()).

Definition testMultipleAssignToMap : val :=
  rec: "testMultipleAssignToMap" <> :=
    exception_do (let: "x" := ref_ty uint64T #10 in
    let: "m" := ref_ty (mapT uint64T uint64T) (map.make uint64T uint64T #()) in
    let: ("$a0", "$a1") := multReturnTwo #() in
    do:  map.insert (![mapT uint64T uint64T] "m") #0 "$a1";;;
    do:  "x" <-[uint64T] "$a0";;;
    return: (((![uint64T] "x") = #2) && ((Fst (map.get (![mapT uint64T uint64T] "m") #0)) = #3));;;
    do:  #()).

(* multiple_return.go *)

Definition returnTwo : val :=
  rec: "returnTwo" <> :=
    exception_do (return: (#2, #3);;;
    do:  #()).

Definition testReturnTwo : val :=
  rec: "testReturnTwo" <> :=
    exception_do (let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := returnTwo #() in
    do:  "y" <-[uint64T] "$a1";;;
    do:  "x" <-[uint64T] "$a0";;;
    return: (((![uint64T] "x") = #2) && ((![uint64T] "y") = #3));;;
    do:  #()).

Definition testAnonymousBinding : val :=
  rec: "testAnonymousBinding" <> :=
    exception_do (let: "y" := ref_ty uint64T (zero_val uint64T) in
    let: <> := ref_ty uint64T (zero_val uint64T) in
    let: ("$a0", "$a1") := returnTwo #() in
    do:  "y" <-[uint64T] "$a1";;;
    do:  "$a0";;;
    return: ((![uint64T] "y") = #3);;;
    do:  #()).

Definition returnThree : val :=
  rec: "returnThree" <> :=
    exception_do (return: (#2, #true, #(U32 1));;;
    do:  #()).

Definition testReturnThree : val :=
  rec: "testReturnThree" <> :=
    exception_do (let: "z" := ref_ty uint32T (zero_val uint32T) in
    let: "y" := ref_ty boolT (zero_val boolT) in
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: (("$a0", "$a1"), "$a2") := returnThree #() in
    do:  "z" <-[uint32T] "$a2";;;
    do:  "y" <-[boolT] "$a1";;;
    do:  "x" <-[uint64T] "$a0";;;
    return: ((((![uint64T] "x") = #2) && ((![boolT] "y") = #true)) && ((![uint32T] "z") = #(U32 1)));;;
    do:  #()).

Definition returnFour : val :=
  rec: "returnFour" <> :=
    exception_do (return: (#2, #true, #(U32 1), #7);;;
    do:  #()).

Definition testReturnFour : val :=
  rec: "testReturnFour" <> :=
    exception_do (let: "w" := ref_ty uint64T (zero_val uint64T) in
    let: "z" := ref_ty uint32T (zero_val uint32T) in
    let: "y" := ref_ty boolT (zero_val boolT) in
    let: "x" := ref_ty uint64T (zero_val uint64T) in
    let: ((("$a0", "$a1"), "$a2"), "$a3") := returnFour #() in
    do:  "w" <-[uint64T] "$a3";;;
    do:  "z" <-[uint32T] "$a2";;;
    do:  "y" <-[boolT] "$a1";;;
    do:  "x" <-[uint64T] "$a0";;;
    return: (((((![uint64T] "x") = #2) && ((![boolT] "y") = #true)) && ((![uint32T] "z") = #(U32 1))) && ((![uint64T] "w") = #7));;;
    do:  #()).

(* nil.go *)

Definition failing_testCompareSliceToNil : val :=
  rec: "failing_testCompareSliceToNil" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #0 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    return: ((![sliceT byteT] "s") ≠ slice.nil);;;
    do:  #()).

Definition testComparePointerToNil : val :=
  rec: "testComparePointerToNil" <> :=
    exception_do (let: "s" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "s" <-[ptrT] "$a0";;;
    return: ((![ptrT] "s") ≠ #null);;;
    do:  #()).

Definition testCompareNilToNil : val :=
  rec: "testCompareNilToNil" <> :=
    exception_do (let: "s" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty ptrT (zero_val ptrT) in
    do:  "s" <-[ptrT] "$a0";;;
    return: ((![ptrT] (![ptrT] "s")) = #null);;;
    do:  #()).

Definition testComparePointerWrappedToNil : val :=
  rec: "testComparePointerWrappedToNil" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT #1 in
    do:  "s" <-[sliceT byteT] "$a0";;;
    return: ((![sliceT byteT] "s") ≠ slice.nil);;;
    do:  #()).

Definition testComparePointerWrappedDefaultToNil : val :=
  rec: "testComparePointerWrappedDefaultToNil" <> :=
    exception_do (let: "s" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    return: ((![sliceT byteT] "s") = slice.nil);;;
    do:  #()).

(* operations.go *)

(* helpers *)
Definition reverseAssignOps64 : val :=
  rec: "reverseAssignOps64" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "y" := ref_ty uint64T (zero_val uint64T) in
    do:  "y" <-[uint64T] ((![uint64T] "y") + (![uint64T] "x"));;;
    do:  "y" <-[uint64T] ((![uint64T] "y") - (![uint64T] "x"));;;
    do:  "y" <-[uint64T] ((![uint64T] "y") + #1);;;
    do:  "y" <-[uint64T] ((![uint64T] "y") - #1);;;
    return: (![uint64T] "y");;;
    do:  #()).

Definition reverseAssignOps32 : val :=
  rec: "reverseAssignOps32" "x" :=
    exception_do (let: "x" := ref_ty uint32T "x" in
    let: "y" := ref_ty uint32T (zero_val uint32T) in
    do:  "y" <-[uint32T] ((![uint32T] "y") + (![uint32T] "x"));;;
    do:  "y" <-[uint32T] ((![uint32T] "y") - (![uint32T] "x"));;;
    do:  "y" <-[uint32T] ((![uint32T] "y") + #1);;;
    do:  "y" <-[uint32T] ((![uint32T] "y") - #1);;;
    return: (![uint32T] "y");;;
    do:  #()).

Definition add64Equals : val :=
  rec: "add64Equals" "x" "y" "z" :=
    exception_do (let: "z" := ref_ty uint64T "z" in
    let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint64T "x" in
    return: (((![uint64T] "x") + (![uint64T] "y")) = (![uint64T] "z"));;;
    do:  #()).

Definition sub64Equals : val :=
  rec: "sub64Equals" "x" "y" "z" :=
    exception_do (let: "z" := ref_ty uint64T "z" in
    let: "y" := ref_ty uint64T "y" in
    let: "x" := ref_ty uint64T "x" in
    return: (((![uint64T] "x") - (![uint64T] "y")) = (![uint64T] "z"));;;
    do:  #()).

(* tests *)
Definition testReverseAssignOps64 : val :=
  rec: "testReverseAssignOps64" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 #0) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 #1) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 #1231234) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 #62206846038638762) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #63)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #47)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #20)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #18)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #10)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #0)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps64 ((#1 ≪ #64) - #1)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition failing_testReverseAssignOps32 : val :=
  rec: "failing_testReverseAssignOps32" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 #(U32 0)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 #(U32 1)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 #(U32 1231234)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 #(U32 3434807466)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #20)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #18)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #10)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #0)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((reverseAssignOps32 ((#1 ≪ #32) - #1)) = #(U32 0)) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testAdd64Equals : val :=
  rec: "testAdd64Equals" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && (add64Equals #2 #3 #5) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (add64Equals ((#1 ≪ #64) - #1) #1 #0) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testSub64Equals : val :=
  rec: "testSub64Equals" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && (sub64Equals #2 #1 #1) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (sub64Equals ((#1 ≪ #64) - #1) (#1 ≪ #63) ((#1 ≪ #63) - #1)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (sub64Equals #2 #8 ((#1 ≪ #64) - #6)) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testDivisionPrecedence : val :=
  rec: "testDivisionPrecedence" <> :=
    exception_do (let: "blockSize" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #4096 in
    do:  "blockSize" <-[uint64T] "$a0";;;
    let: "hdrmeta" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #8 in
    do:  "hdrmeta" <-[uint64T] "$a0";;;
    let: "hdraddrs" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ((![uint64T] "blockSize") - (![uint64T] "hdrmeta")) `quot` #8 in
    do:  "hdraddrs" <-[uint64T] "$a0";;;
    return: ((![uint64T] "hdraddrs") = #511);;;
    do:  #()).

Definition testModPrecedence : val :=
  rec: "testModPrecedence" <> :=
    exception_do (let: "x1" := ref_ty intT (zero_val intT) in
    let: "$a0" := #513 + (#12 `rem` #8) in
    do:  "x1" <-[intT] "$a0";;;
    let: "x2" := ref_ty intT (zero_val intT) in
    let: "$a0" := (#513 + #12) `rem` #8 in
    do:  "x2" <-[intT] "$a0";;;
    return: (((![intT] "x1") = #517) && ((![intT] "x2") = #5));;;
    do:  #()).

Definition testBitwiseOpsPrecedence : val :=
  rec: "testBitwiseOpsPrecedence" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((#222 `or` #327) = #479) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((#468 `and` #1191) = #132) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((#453 `xor` #761) = #828) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (((#453 `xor` #761) `or` #121) = #893) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (((#468 `and` #1191) `or` #333) = #461) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((#222 `or` (#327 `and` #421)) ≠ #389) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testArithmeticShifts : val :=
  rec: "testArithmeticShifts" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((#672 ≪ #3) = #5376) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((#672 ≪ #51) = #1513209474796486656) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((#672 ≫ #4) = #42) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((#672 ≫ #12) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (((#672 ≫ #4) ≪ #4) = #672) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testBitAddAnd : val :=
  rec: "testBitAddAnd" <> :=
    exception_do (let: "tid" := ref_ty intT (zero_val intT) in
    let: "$a0" := #17 in
    do:  "tid" <-[intT] "$a0";;;
    let: "n" := ref_ty intT (zero_val intT) in
    let: "$a0" := #16 in
    do:  "n" <-[intT] "$a0";;;
    return: ((((![intT] "tid") + (![intT] "n")) `and` (~ ((![intT] "n") - #1))) = #32);;;
    do:  #()).

Definition testManyParentheses : val :=
  rec: "testManyParentheses" <> :=
    exception_do (return: ((((#1 `rem` #2) `or` (#3 `rem` #4)) * #6) = (#3 * #6));;;
    do:  #()).

Definition testPlusTimes : val :=
  rec: "testPlusTimes" <> :=
    exception_do (return: (((#2 + #5) * #2) = #14);;;
    do:  #()).

(* precedence.go *)

Definition testOrCompareSimple : val :=
  rec: "testOrCompareSimple" <> :=
    exception_do ((if: (#3 > #4) || (#4 > #3)
    then
      return: (#true);;;
      do:  #()
    else do:  #());;;
    return: (#false);;;
    do:  #()).

Definition testOrCompare : val :=
  rec: "testOrCompare" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    (if: (~ ((#3 > #4) || (#4 > #3)))
    then
      let: "$a0" := #false in
      do:  "ok" <-[boolT] "$a0";;;
      do:  #()
    else do:  #());;;
    (if: (#4 < #3) || (#2 > #3)
    then
      let: "$a0" := #false in
      do:  "ok" <-[boolT] "$a0";;;
      do:  #()
    else do:  #());;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testAndCompare : val :=
  rec: "testAndCompare" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    (if: (#3 > #4) && (#4 > #3)
    then
      let: "$a0" := #false in
      do:  "ok" <-[boolT] "$a0";;;
      do:  #()
    else do:  #());;;
    (if: (#4 > #3) || (#2 < #3)
    then do:  #()
    else
      let: "$a0" := #false in
      do:  "ok" <-[boolT] "$a0";;;
      do:  #());;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testShiftMod : val :=
  rec: "testShiftMod" <> :=
    exception_do (return: ((#20 ≫ (#8 `rem` #4)) = #20);;;
    do:  #()).

(* prims.go *)

Definition testLinearize : val :=
  rec: "testLinearize" <> :=
    exception_do (let: "m" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "m" <-[ptrT] "$a0";;;
    do:  (sync.Mutex__Lock (![ptrT] "m")) #();;;
    do:  machine.Linearize #();;;
    do:  (sync.Mutex__Unlock (![ptrT] "m")) #();;;
    return: (#true);;;
    do:  #()).

(* shortcircuiting.go *)

Definition BoolTest : go_type := structT [
  "t" :: boolT;
  "f" :: boolT;
  "tc" :: uint64T;
  "fc" :: uint64T
].

Definition BoolTest__mset : list (string * val) := [
].

Definition CheckTrue : val :=
  rec: "CheckTrue" "b" :=
    exception_do (let: "b" := ref_ty ptrT "b" in
    do:  (struct.field_ref BoolTest "tc" (![ptrT] "b")) <-[uint64T] ((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) + #1);;;
    return: (![boolT] (struct.field_ref BoolTest "t" (![ptrT] "b")));;;
    do:  #()).

Definition CheckFalse : val :=
  rec: "CheckFalse" "b" :=
    exception_do (let: "b" := ref_ty ptrT "b" in
    do:  (struct.field_ref BoolTest "fc" (![ptrT] "b")) <-[uint64T] ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) + #1);;;
    return: (![boolT] (struct.field_ref BoolTest "f" (![ptrT] "b")));;;
    do:  #()).

(* tests *)
Definition testShortcircuitAndTF : val :=
  rec: "testShortcircuitAndTF" <> :=
    exception_do (let: "b" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    }]) in
    do:  "b" <-[ptrT] "$a0";;;
    (if: (CheckTrue (![ptrT] "b")) && (CheckFalse (![ptrT] "b"))
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #1) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #1));;;
    do:  #()).

Definition testShortcircuitAndFT : val :=
  rec: "testShortcircuitAndFT" <> :=
    exception_do (let: "b" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    }]) in
    do:  "b" <-[ptrT] "$a0";;;
    (if: (CheckFalse (![ptrT] "b")) && (CheckTrue (![ptrT] "b"))
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #0) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #1));;;
    do:  #()).

Definition testShortcircuitOrTF : val :=
  rec: "testShortcircuitOrTF" <> :=
    exception_do (let: "b" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    }]) in
    do:  "b" <-[ptrT] "$a0";;;
    (if: (CheckTrue (![ptrT] "b")) || (CheckFalse (![ptrT] "b"))
    then
      return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #1) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #0));;;
      do:  #()
    else do:  #());;;
    return: (#false);;;
    do:  #()).

Definition testShortcircuitOrFT : val :=
  rec: "testShortcircuitOrFT" <> :=
    exception_do (let: "b" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    }]) in
    do:  "b" <-[ptrT] "$a0";;;
    (if: (CheckFalse (![ptrT] "b")) || (CheckTrue (![ptrT] "b"))
    then
      return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #1) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #1));;;
      do:  #()
    else do:  #());;;
    return: (#false);;;
    do:  #()).

(* slices.go *)

Definition ArrayEditor : go_type := structT [
  "s" :: sliceT uint64T;
  "next_val" :: uint64T
].

Definition ArrayEditor__mset : list (string * val) := [
  ("Advance", ArrayEditor__Advance)
].

Definition ArrayEditor__Advance : val :=
  rec: "ArrayEditor__Advance" "ae" "arr" "next" :=
    exception_do (let: "ae" := ref_ty ptrT "ae" in
    let: "next" := ref_ty uint64T "next" in
    let: "arr" := ref_ty (sliceT uint64T) "arr" in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "arr") #0) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #0)) + #1);;;
    let: "$a0" := ![uint64T] (struct.field_ref ArrayEditor "next_val" (![ptrT] "ae")) in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] (struct.field_ref ArrayEditor "s" (![ptrT] "ae"))) #0) <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "next" in
    do:  (struct.field_ref ArrayEditor "next_val" (![ptrT] "ae")) <-[uint64T] "$a0";;;
    let: "$a0" := let: "$s" := ![sliceT uint64T] (struct.field_ref ArrayEditor "s" (![ptrT] "ae")) in
    slice.slice uint64T "$s" #1 (slice.len "$s") in
    do:  (struct.field_ref ArrayEditor "s" (![ptrT] "ae")) <-[sliceT uint64T] "$a0";;;
    do:  #()).

(* tests *)
Definition testSliceOps : val :=
  rec: "testSliceOps" <> :=
    exception_do (let: "x" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := slice.make2 uint64T #10 in
    do:  "x" <-[sliceT uint64T] "$a0";;;
    let: "$a0" := #5 in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "x") #1) <-[uint64T] "$a0";;;
    let: "$a0" := #10 in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "x") #2) <-[uint64T] "$a0";;;
    let: "$a0" := #15 in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "x") #3) <-[uint64T] "$a0";;;
    let: "$a0" := #20 in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "x") #4) <-[uint64T] "$a0";;;
    let: "v1" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "x") #2) in
    do:  "v1" <-[uint64T] "$a0";;;
    let: "v2" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #2 #3 in
    do:  "v2" <-[sliceT uint64T] "$a0";;;
    let: "v3" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #0 #3 in
    do:  "v3" <-[sliceT uint64T] "$a0";;;
    let: "v4" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := SliceRef uint64T (![sliceT uint64T] "x") #2 in
    do:  "v4" <-[ptrT] "$a0";;;
    let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] "v1") = #10) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "v2") #0)) = #10) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((slice.len (![sliceT uint64T] "v2")) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "v3") #1)) = #5) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "v3") #2)) = #10) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((slice.len (![sliceT uint64T] "v3")) = #3) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (![ptrT] "v4")) = #10) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testSliceCapacityOps : val :=
  rec: "testSliceCapacityOps" <> :=
    exception_do (let: "x" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := slice.make3 uint64T #0 #10 in
    do:  "x" <-[sliceT uint64T] "$a0";;;
    let: "sub1" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #0 #6 in
    do:  "sub1" <-[sliceT uint64T] "$a0";;;
    let: "$a0" := #1 in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "sub1") #0) <-[uint64T] "$a0";;;
    let: "sub2" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #2 #4 in
    do:  "sub2" <-[sliceT uint64T] "$a0";;;
    let: "$a0" := #2 in
    do:  (slice.elem_ref uint64T (![sliceT uint64T] "sub2") #0) <-[uint64T] "$a0";;;
    let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((slice.len (![sliceT uint64T] "sub1")) = #6) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((slice.cap (![sliceT uint64T] "sub1")) = #10) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #0 #10) #0)) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((slice.len (![sliceT uint64T] "sub2")) = #2) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((slice.cap (![sliceT uint64T] "sub2")) = #8) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (let: "$s" := ![sliceT uint64T] "x" in
    slice.slice uint64T "$s" #0 #10) #2)) = #2) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testOverwriteArray : val :=
  rec: "testOverwriteArray" <> :=
    exception_do (let: "arr" := ref_ty (sliceT uint64T) (slice.make2 uint64T #4) in
    let: "ae1" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty ArrayEditor (struct.make ArrayEditor [{
      "s" ::= let: "$s" := ![sliceT uint64T] "arr" in
      slice.slice uint64T "$s" #0 (slice.len "$s");
      "next_val" ::= #1
    }]) in
    do:  "ae1" <-[ptrT] "$a0";;;
    let: "ae2" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty ArrayEditor (struct.make ArrayEditor [{
      "s" ::= let: "$s" := ![sliceT uint64T] "arr" in
      slice.slice uint64T "$s" #1 (slice.len "$s");
      "next_val" ::= #102
    }]) in
    do:  "ae2" <-[ptrT] "$a0";;;
    do:  (ArrayEditor__Advance (![ptrT] "ae2")) (![sliceT uint64T] "arr") #103;;;
    do:  (ArrayEditor__Advance (![ptrT] "ae2")) (![sliceT uint64T] "arr") #104;;;
    do:  (ArrayEditor__Advance (![ptrT] "ae2")) (![sliceT uint64T] "arr") #105;;;
    do:  (ArrayEditor__Advance (![ptrT] "ae1")) (![sliceT uint64T] "arr") #2;;;
    do:  (ArrayEditor__Advance (![ptrT] "ae1")) (![sliceT uint64T] "arr") #3;;;
    do:  (ArrayEditor__Advance (![ptrT] "ae1")) (![sliceT uint64T] "arr") #4;;;
    do:  (ArrayEditor__Advance (![ptrT] "ae1")) (![sliceT uint64T] "arr") #5;;;
    (if: ((((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #0)) + (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #1))) + (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #2))) + (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #3))) ≥ #100
    then
      return: (#false);;;
      do:  #()
    else do:  #());;;
    return: (((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #3)) = #4) && ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "arr") #0)) = #4));;;
    do:  #()).

Definition testSliceLiteral : val :=
  rec: "testSliceLiteral" <> :=
    exception_do (let: "bytes" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.literal byteT [ #(U8 1); #(U8 2) ] in
    do:  "bytes" <-[sliceT byteT] "$a0";;;
    let: "ok" := ref_ty boolT #true in
    let: "$a0" := (![boolT] "ok") && ((![byteT] (slice.elem_ref byteT (![sliceT byteT] "bytes") #0)) = #(U8 1)) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "ints" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := slice.literal uint64T [ #1; #2; #3 ] in
    do:  "ints" <-[sliceT uint64T] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "ints") #1)) = #2) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

(* strings.go *)

(* helpers *)
Definition stringAppend : val :=
  rec: "stringAppend" "s" "x" :=
    exception_do (let: "x" := ref_ty uint64T "x" in
    let: "s" := ref_ty stringT "s" in
    return: ((![stringT] "s") + (machine.UInt64ToString (![uint64T] "x")));;;
    do:  #()).

Definition stringLength : val :=
  rec: "stringLength" "s" :=
    exception_do (let: "s" := ref_ty stringT "s" in
    return: (StringLength (![stringT] "s"));;;
    do:  #()).

(* tests *)
Definition failing_testStringAppend : val :=
  rec: "failing_testStringAppend" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "s" := ref_ty stringT #(str "123") in
    let: "y" := ref_ty stringT (stringAppend (![stringT] "s") #45) in
    return: ((![boolT] "ok") && ((![stringT] "y") = #(str "12345")));;;
    do:  #()).

Definition failing_testStringLength : val :=
  rec: "failing_testStringLength" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "s" := ref_ty stringT #(str "") in
    let: "$a0" := (![boolT] "ok") && ((StringLength (![stringT] "s")) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := stringAppend (![stringT] "s") #1 in
    do:  "s" <-[stringT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((StringLength (![stringT] "s")) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := stringAppend (![stringT] "s") #23 in
    do:  "s" <-[stringT] "$a0";;;
    return: ((![boolT] "ok") && ((StringLength (![stringT] "s")) = #3));;;
    do:  #()).

(* struct_pointers.go *)

Definition Bar : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition Bar__mset : list (string * val) := [
  ("mutate", Bar__mutate)
].

Definition Foo : go_type := structT [
  "bar" :: Bar
].

Definition Foo__mset : list (string * val) := [
  ("mutateBar", Foo__mutateBar)
].

Definition Bar__mutate : val :=
  rec: "Bar__mutate" "bar" <> :=
    exception_do (let: "bar" := ref_ty ptrT "bar" in
    let: "$a0" := #2 in
    do:  (struct.field_ref Bar "a" (![ptrT] "bar")) <-[uint64T] "$a0";;;
    let: "$a0" := #3 in
    do:  (struct.field_ref Bar "b" (![ptrT] "bar")) <-[uint64T] "$a0";;;
    do:  #()).

Definition Foo__mutateBar : val :=
  rec: "Foo__mutateBar" "foo" <> :=
    exception_do (let: "foo" := ref_ty ptrT "foo" in
    do:  (Bar__mutate (![Bar] (struct.field_ref Foo "bar" (![ptrT] "foo")))) #();;;
    do:  #()).

Definition failing_testFooBarMutation : val :=
  rec: "failing_testFooBarMutation" <> :=
    exception_do (let: "x" := ref_ty Foo (zero_val Foo) in
    let: "$a0" := struct.make Foo [{
      "bar" ::= struct.make Bar [{
        "a" ::= #0;
        "b" ::= #0
      }]
    }] in
    do:  "x" <-[Foo] "$a0";;;
    do:  (Foo__mutateBar (![Foo] "x")) #();;;
    return: ((![uint64T] (struct.field_ref Bar "a" (struct.field_ref Foo "bar" "x"))) = #2);;;
    do:  #()).

(* structs.go *)

Definition TwoInts : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition TwoInts__mset : list (string * val) := [
].

Definition S : go_type := structT [
  "a" :: uint64T;
  "b" :: TwoInts;
  "c" :: boolT
].

Definition S__mset : list (string * val) := [
  ("readA", S__readA)
  ("readB", S__readB)
  ("readBVal", S__readBVal)
  ("updateBValX", S__updateBValX)
  ("negateC", S__negateC)
].

Definition NewS : val :=
  rec: "NewS" <> :=
    exception_do (return: (ref_ty S (struct.make S [{
       "a" ::= #2;
       "b" ::= struct.make TwoInts [{
         "x" ::= #1;
         "y" ::= #2
       }];
       "c" ::= #true
     }]));;;
    do:  #()).

Definition S__readA : val :=
  rec: "S__readA" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (![uint64T] (struct.field_ref S "a" (![ptrT] "s")));;;
    do:  #()).

Definition S__readB : val :=
  rec: "S__readB" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    return: (![TwoInts] (struct.field_ref S "b" (![ptrT] "s")));;;
    do:  #()).

Definition S__readBVal : val :=
  rec: "S__readBVal" "s" <> :=
    exception_do (let: "s" := ref_ty S "s" in
    return: (![TwoInts] (struct.field_ref S "b" "s"));;;
    do:  #()).

Definition S__updateBValX : val :=
  rec: "S__updateBValX" "s" "i" :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    let: "i" := ref_ty uint64T "i" in
    let: "$a0" := ![uint64T] "i" in
    do:  (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "s"))) <-[uint64T] "$a0";;;
    do:  #()).

Definition S__negateC : val :=
  rec: "S__negateC" "s" <> :=
    exception_do (let: "s" := ref_ty ptrT "s" in
    let: "$a0" := (~ (![boolT] (struct.field_ref S "c" (![ptrT] "s")))) in
    do:  (struct.field_ref S "c" (![ptrT] "s")) <-[boolT] "$a0";;;
    do:  #()).

Definition failing_testStructUpdates : val :=
  rec: "failing_testStructUpdates" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "ns" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := NewS #() in
    do:  "ns" <-[ptrT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && (((S__readA (![ptrT] "ns")) #()) = #2) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "b1" := ref_ty TwoInts ((S__readB (![ptrT] "ns")) #()) in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" "b1")) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    do:  (S__negateC (![ptrT] "ns")) #();;;
    let: "$a0" := (![boolT] "ok") && ((![boolT] (struct.field_ref S "c" (![ptrT] "ns"))) = #false) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := #3 in
    do:  (struct.field_ref TwoInts "x" "b1") <-[uint64T] "$a0";;;
    let: "b2" := ref_ty TwoInts ((S__readB (![ptrT] "ns")) #()) in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" "b2")) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "b3" := ref_ty ptrT (struct.field_ref S "b" (![ptrT] "ns")) in
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (![ptrT] "b3"))) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    do:  (S__updateBValX (![ptrT] "ns")) #4;;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testNestedStructUpdates : val :=
  rec: "testNestedStructUpdates" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "ns" := ref_ty ptrT (NewS #()) in
    let: "$a0" := #5 in
    do:  (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns"))) <-[uint64T] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns")))) = #5) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := NewS #() in
    do:  "ns" <-[ptrT] "$a0";;;
    let: "p" := ref_ty ptrT (struct.field_ref S "b" (![ptrT] "ns")) in
    let: "$a0" := #5 in
    do:  (struct.field_ref TwoInts "x" (![ptrT] "p")) <-[uint64T] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns")))) = #5) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := NewS #() in
    do:  "ns" <-[ptrT] "$a0";;;
    let: "$a0" := struct.field_ref S "b" (![ptrT] "ns") in
    do:  "p" <-[ptrT] "$a0";;;
    let: "$a0" := #5 in
    do:  (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns"))) <-[uint64T] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (![ptrT] "p"))) = #5) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := NewS #() in
    do:  "ns" <-[ptrT] "$a0";;;
    let: "$a0" := struct.field_ref S "b" (![ptrT] "ns") in
    do:  "p" <-[ptrT] "$a0";;;
    let: "$a0" := #5 in
    do:  (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns"))) <-[uint64T] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (![ptrT] "p"))) = #5) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testStructConstructions : val :=
  rec: "testStructConstructions" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "p1" := ref_ty ptrT (zero_val ptrT) in
    let: "p2" := ref_ty TwoInts (zero_val TwoInts) in
    let: "p3" := ref_ty TwoInts (zero_val TwoInts) in
    let: "$a0" := struct.make TwoInts [{
      "y" ::= #0;
      "x" ::= #0
    }] in
    do:  "p3" <-[TwoInts] "$a0";;;
    let: "p4" := ref_ty TwoInts (zero_val TwoInts) in
    let: "$a0" := struct.make TwoInts [{
      "x" ::= #0;
      "y" ::= #0
    }] in
    do:  "p4" <-[TwoInts] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![ptrT] "p1") = #null) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := ref_ty TwoInts (zero_val TwoInts) in
    do:  "p1" <-[ptrT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![TwoInts] "p2") = (![TwoInts] "p3")) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![TwoInts] "p3") = (![TwoInts] "p4")) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![TwoInts] "p4") = (![TwoInts] (![ptrT] "p1"))) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ("p4" ≠ (![ptrT] "p1")) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition testIncompleteStruct : val :=
  rec: "testIncompleteStruct" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "p1" := ref_ty TwoInts (zero_val TwoInts) in
    let: "$a0" := struct.make TwoInts [{
      "x" ::= #0
    }] in
    do:  "p1" <-[TwoInts] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "y" "p1")) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "p2" := ref_ty S (zero_val S) in
    let: "$a0" := struct.make S [{
      "a" ::= #2
    }] in
    do:  "p2" <-[S] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (struct.field_ref S "b" "p2"))) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((![boolT] (struct.field_ref S "c" "p2")) = #false) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).

Definition StructWrap : go_type := structT [
  "i" :: uint64T
].

Definition StructWrap__mset : list (string * val) := [
].

Definition testStoreInStructVar : val :=
  rec: "testStoreInStructVar" <> :=
    exception_do (let: "p" := ref_ty StructWrap (struct.make StructWrap [{
      "i" ::= #0
    }]) in
    let: "$a0" := #5 in
    do:  (struct.field_ref StructWrap "i" "p") <-[uint64T] "$a0";;;
    return: ((![uint64T] (struct.field_ref StructWrap "i" "p")) = #5);;;
    do:  #()).

Definition testStoreInStructPointerVar : val :=
  rec: "testStoreInStructPointerVar" <> :=
    exception_do (let: "p" := ref_ty ptrT (ref_ty StructWrap (zero_val StructWrap)) in
    let: "$a0" := #5 in
    do:  (struct.field_ref StructWrap "i" (![ptrT] "p")) <-[uint64T] "$a0";;;
    return: ((![uint64T] (struct.field_ref StructWrap "i" (![ptrT] "p"))) = #5);;;
    do:  #()).

Definition testStoreComposite : val :=
  rec: "testStoreComposite" <> :=
    exception_do (let: "p" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty TwoInts (zero_val TwoInts) in
    do:  "p" <-[ptrT] "$a0";;;
    let: "$a0" := struct.make TwoInts [{
      "x" ::= #3;
      "y" ::= #4
    }] in
    do:  (![ptrT] "p") <-[TwoInts] "$a0";;;
    return: ((![uint64T] (struct.field_ref TwoInts "y" (![ptrT] "p"))) = #4);;;
    do:  #()).

Definition testStoreSlice : val :=
  rec: "testStoreSlice" <> :=
    exception_do (let: "p" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    do:  "p" <-[ptrT] "$a0";;;
    let: "s" := ref_ty (sliceT uint64T) (zero_val (sliceT uint64T)) in
    let: "$a0" := slice.make2 uint64T #3 in
    do:  "s" <-[sliceT uint64T] "$a0";;;
    let: "$a0" := ![sliceT uint64T] "s" in
    do:  (![ptrT] "p") <-[sliceT uint64T] "$a0";;;
    return: ((slice.len (![sliceT uint64T] (![ptrT] "p"))) = #3);;;
    do:  #()).

Definition StructWithFunc : go_type := structT [
  "fn" :: funcT
].

Definition StructWithFunc__mset : list (string * val) := [
].

Definition testStructFieldFunc : val :=
  rec: "testStructFieldFunc" <> :=
    exception_do (let: "a" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty StructWithFunc (zero_val StructWithFunc) in
    do:  "a" <-[ptrT] "$a0";;;
    let: "$a0" := (λ: "arg",
      return: ((![uint64T] "arg") * #2);;;
      do:  #()
      ) in
    do:  (struct.field_ref StructWithFunc "fn" (![ptrT] "a")) <-[funcT] "$a0";;;
    return: (((![funcT] (struct.field_ref StructWithFunc "fn" (![ptrT] "a"))) #10) = #20);;;
    do:  #()).

(* vars.go *)

Definition testPointerAssignment : val :=
  rec: "testPointerAssignment" <> :=
    exception_do (let: "x" := ref_ty boolT (zero_val boolT) in
    let: "$a0" := #true in
    do:  "x" <-[boolT] "$a0";;;
    return: (![boolT] "x");;;
    do:  #()).

Definition testAddressOfLocal : val :=
  rec: "testAddressOfLocal" <> :=
    exception_do (let: "x" := ref_ty boolT #false in
    let: "xptr" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := "x" in
    do:  "xptr" <-[ptrT] "$a0";;;
    let: "$a0" := #true in
    do:  (![ptrT] "xptr") <-[boolT] "$a0";;;
    return: ((![boolT] "x") && (![boolT] (![ptrT] "xptr")));;;
    do:  #()).

Definition testAnonymousAssign : val :=
  rec: "testAnonymousAssign" <> :=
    exception_do (let: "$a0" := #1 + #2 in
    do:  "$a0";;;
    return: (#true);;;
    do:  #()).

(* wal.go *)

(* 10 is completely arbitrary *)
Definition MaxTxnWrites : expr := #10.

Definition logLength : expr := #1 + (#2 * MaxTxnWrites).

Definition Log : go_type := structT [
  "d" :: disk.Disk;
  "l" :: ptrT;
  "cache" :: mapT uint64T (sliceT byteT);
  "length" :: ptrT
].

Definition Log__mset : list (string * val) := [
  ("lock", Log__lock)
  ("unlock", Log__unlock)
  ("BeginTxn", Log__BeginTxn)
  ("Read", Log__Read)
  ("Size", Log__Size)
  ("Write", Log__Write)
  ("Commit", Log__Commit)
  ("Apply", Log__Apply)
].

Definition intToBlock : val :=
  rec: "intToBlock" "a" :=
    exception_do (let: "a" := ref_ty uint64T "a" in
    let: "b" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := slice.make2 byteT disk.BlockSize in
    do:  "b" <-[sliceT byteT] "$a0";;;
    do:  machine.UInt64Put (![sliceT byteT] "b") (![uint64T] "a");;;
    return: (![sliceT byteT] "b");;;
    do:  #()).

Definition blockToInt : val :=
  rec: "blockToInt" "v" :=
    exception_do (let: "v" := ref_ty (sliceT byteT) "v" in
    let: "a" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := machine.UInt64Get (![sliceT byteT] "v") in
    do:  "a" <-[uint64T] "$a0";;;
    return: (![uint64T] "a");;;
    do:  #()).

(* New initializes a fresh log *)
Definition New : val :=
  rec: "New" <> :=
    exception_do (let: "d" := ref_ty disk.Disk (zero_val disk.Disk) in
    let: "$a0" := disk.Get #() in
    do:  "d" <-[disk.Disk] "$a0";;;
    let: "diskSize" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := (__Size (![disk.Disk] "d")) #() in
    do:  "diskSize" <-[uint64T] "$a0";;;
    (if: (![uint64T] "diskSize") ≤ logLength
    then
      do:  Panic "disk is too small to host log";;;
      do:  #()
    else do:  #());;;
    let: "cache" := ref_ty (mapT uint64T (sliceT byteT)) (zero_val (mapT uint64T (sliceT byteT))) in
    let: "$a0" := map.make uint64T (sliceT byteT) #() in
    do:  "cache" <-[mapT uint64T (sliceT byteT)] "$a0";;;
    let: "header" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := intToBlock #0 in
    do:  "header" <-[sliceT byteT] "$a0";;;
    do:  (__Write (![disk.Disk] "d")) #0 (![sliceT byteT] "header");;;
    let: "lengthPtr" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "lengthPtr" <-[ptrT] "$a0";;;
    let: "$a0" := #0 in
    do:  (![ptrT] "lengthPtr") <-[uint64T] "$a0";;;
    let: "l" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "l" <-[ptrT] "$a0";;;
    return: (struct.make Log [{
       "d" ::= ![disk.Disk] "d";
       "cache" ::= ![mapT uint64T (sliceT byteT)] "cache";
       "length" ::= ![ptrT] "lengthPtr";
       "l" ::= ![ptrT] "l"
     }]);;;
    do:  #()).

Definition Log__lock : val :=
  rec: "Log__lock" "l" <> :=
    exception_do (let: "l" := ref_ty Log "l" in
    do:  (sync.Mutex__Lock (![ptrT] (struct.field_ref Log "l" "l"))) #();;;
    do:  #()).

Definition Log__unlock : val :=
  rec: "Log__unlock" "l" <> :=
    exception_do (let: "l" := ref_ty Log "l" in
    do:  (sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "l" "l"))) #();;;
    do:  #()).

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded. *)
Definition Log__BeginTxn : val :=
  rec: "Log__BeginTxn" "l" <> :=
    exception_do (let: "l" := ref_ty Log "l" in
    do:  (Log__lock (![Log] "l")) #();;;
    let: "length" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "length" "l")) in
    do:  "length" <-[uint64T] "$a0";;;
    (if: (![uint64T] "length") = #0
    then
      do:  (Log__unlock (![Log] "l")) #();;;
      return: (#true);;;
      do:  #()
    else do:  #());;;
    do:  (Log__unlock (![Log] "l")) #();;;
    return: (#false);;;
    do:  #()).

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes. *)
Definition Log__Read : val :=
  rec: "Log__Read" "l" "a" :=
    exception_do (let: "l" := ref_ty Log "l" in
    let: "a" := ref_ty uint64T "a" in
    do:  (Log__lock (![Log] "l")) #();;;
    let: "ok" := ref_ty boolT (zero_val boolT) in
    let: "v" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: ("$a0", "$a1") := Fst (map.get (![mapT uint64T (sliceT byteT)] (struct.field_ref Log "cache" "l")) (![uint64T] "a")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "v" <-[sliceT byteT] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  (Log__unlock (![Log] "l")) #();;;
      return: (![sliceT byteT] "v");;;
      do:  #()
    else do:  #());;;
    do:  (Log__unlock (![Log] "l")) #();;;
    let: "dv" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := (__Read (![disk.Disk] (struct.field_ref Log "d" "l"))) (logLength + (![uint64T] "a")) in
    do:  "dv" <-[sliceT byteT] "$a0";;;
    return: (![sliceT byteT] "dv");;;
    do:  #()).

Definition Log__Size : val :=
  rec: "Log__Size" "l" <> :=
    exception_do (let: "l" := ref_ty Log "l" in
    let: "sz" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := (__Size (![disk.Disk] (struct.field_ref Log "d" "l"))) #() in
    do:  "sz" <-[uint64T] "$a0";;;
    return: ((![uint64T] "sz") - logLength);;;
    do:  #()).

(* Write to the disk through the log. *)
Definition Log__Write : val :=
  rec: "Log__Write" "l" "a" "v" :=
    exception_do (let: "l" := ref_ty Log "l" in
    let: "v" := ref_ty (sliceT byteT) "v" in
    let: "a" := ref_ty uint64T "a" in
    do:  (Log__lock (![Log] "l")) #();;;
    let: "length" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "length" "l")) in
    do:  "length" <-[uint64T] "$a0";;;
    (if: (![uint64T] "length") ≥ MaxTxnWrites
    then
      do:  Panic "transaction is at capacity";;;
      do:  #()
    else do:  #());;;
    let: "aBlock" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := intToBlock (![uint64T] "a") in
    do:  "aBlock" <-[sliceT byteT] "$a0";;;
    let: "nextAddr" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #1 + (#2 * (![uint64T] "length")) in
    do:  "nextAddr" <-[uint64T] "$a0";;;
    do:  (__Write (![disk.Disk] (struct.field_ref Log "d" "l"))) (![uint64T] "nextAddr") (![sliceT byteT] "aBlock");;;
    do:  (__Write (![disk.Disk] (struct.field_ref Log "d" "l"))) ((![uint64T] "nextAddr") + #1) (![sliceT byteT] "v");;;
    let: "$a0" := ![sliceT byteT] "v" in
    do:  map.insert (![mapT uint64T (sliceT byteT)] (struct.field_ref Log "cache" "l")) (![uint64T] "a") "$a0";;;
    let: "$a0" := (![uint64T] "length") + #1 in
    do:  (![ptrT] (struct.field_ref Log "length" "l")) <-[uint64T] "$a0";;;
    do:  (Log__unlock (![Log] "l")) #();;;
    do:  #()).

(* Commit the current transaction. *)
Definition Log__Commit : val :=
  rec: "Log__Commit" "l" <> :=
    exception_do (let: "l" := ref_ty Log "l" in
    do:  (Log__lock (![Log] "l")) #();;;
    let: "length" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "length" "l")) in
    do:  "length" <-[uint64T] "$a0";;;
    do:  (Log__unlock (![Log] "l")) #();;;
    let: "header" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := intToBlock (![uint64T] "length") in
    do:  "header" <-[sliceT byteT] "$a0";;;
    do:  (__Write (![disk.Disk] (struct.field_ref Log "d" "l"))) #0 (![sliceT byteT] "header");;;
    do:  #()).

Definition getLogEntry : val :=
  rec: "getLogEntry" "d" "logOffset" :=
    exception_do (let: "logOffset" := ref_ty uint64T "logOffset" in
    let: "d" := ref_ty disk.Disk "d" in
    let: "diskAddr" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #1 + (#2 * (![uint64T] "logOffset")) in
    do:  "diskAddr" <-[uint64T] "$a0";;;
    let: "aBlock" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := (__Read (![disk.Disk] "d")) (![uint64T] "diskAddr") in
    do:  "aBlock" <-[sliceT byteT] "$a0";;;
    let: "a" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := blockToInt (![sliceT byteT] "aBlock") in
    do:  "a" <-[uint64T] "$a0";;;
    let: "v" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := (__Read (![disk.Disk] "d")) ((![uint64T] "diskAddr") + #1) in
    do:  "v" <-[sliceT byteT] "$a0";;;
    return: (![uint64T] "a", ![sliceT byteT] "v");;;
    do:  #()).

(* applyLog assumes we are running sequentially *)
Definition applyLog : val :=
  rec: "applyLog" "d" "length" :=
    exception_do (let: "length" := ref_ty uint64T "length" in
    let: "d" := ref_ty disk.Disk "d" in
    (let: "i" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (![uint64T] "length")
      then
        let: "v" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
        let: "a" := ref_ty uint64T (zero_val uint64T) in
        let: ("$a0", "$a1") := getLogEntry (![disk.Disk] "d") (![uint64T] "i") in
        do:  "v" <-[sliceT byteT] "$a1";;;
        do:  "a" <-[uint64T] "$a0";;;
        do:  (__Write (![disk.Disk] "d")) (logLength + (![uint64T] "a")) (![sliceT byteT] "v");;;
        let: "$a0" := (![uint64T] "i") + #1 in
        do:  "i" <-[uint64T] "$a0";;;
        continue: #();;;
        do:  #()
      else do:  #());;;
      break: #();;;
      do:  #()));;;
    do:  #()).

Definition clearLog : val :=
  rec: "clearLog" "d" :=
    exception_do (let: "d" := ref_ty disk.Disk "d" in
    let: "header" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := intToBlock #0 in
    do:  "header" <-[sliceT byteT] "$a0";;;
    do:  (__Write (![disk.Disk] "d")) #0 (![sliceT byteT] "header");;;
    do:  #()).

(* Apply all the committed transactions.

   Frees all the space in the log. *)
Definition Log__Apply : val :=
  rec: "Log__Apply" "l" <> :=
    exception_do (let: "l" := ref_ty Log "l" in
    do:  (Log__lock (![Log] "l")) #();;;
    let: "length" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := ![uint64T] (![ptrT] (struct.field_ref Log "length" "l")) in
    do:  "length" <-[uint64T] "$a0";;;
    do:  applyLog (![disk.Disk] (struct.field_ref Log "d" "l")) (![uint64T] "length");;;
    do:  clearLog (![disk.Disk] (struct.field_ref Log "d" "l"));;;
    let: "$a0" := #0 in
    do:  (![ptrT] (struct.field_ref Log "length" "l")) <-[uint64T] "$a0";;;
    do:  (Log__unlock (![Log] "l")) #();;;
    do:  #()).

(* Open recovers the log following a crash or shutdown *)
Definition Open : val :=
  rec: "Open" <> :=
    exception_do (let: "d" := ref_ty disk.Disk (zero_val disk.Disk) in
    let: "$a0" := disk.Get #() in
    do:  "d" <-[disk.Disk] "$a0";;;
    let: "header" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$a0" := (__Read (![disk.Disk] "d")) #0 in
    do:  "header" <-[sliceT byteT] "$a0";;;
    let: "length" := ref_ty uint64T (zero_val uint64T) in
    let: "$a0" := blockToInt (![sliceT byteT] "header") in
    do:  "length" <-[uint64T] "$a0";;;
    do:  applyLog (![disk.Disk] "d") (![uint64T] "length");;;
    do:  clearLog (![disk.Disk] "d");;;
    let: "cache" := ref_ty (mapT uint64T (sliceT byteT)) (zero_val (mapT uint64T (sliceT byteT))) in
    let: "$a0" := map.make uint64T (sliceT byteT) #() in
    do:  "cache" <-[mapT uint64T (sliceT byteT)] "$a0";;;
    let: "lengthPtr" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty uint64T (zero_val uint64T) in
    do:  "lengthPtr" <-[ptrT] "$a0";;;
    let: "$a0" := #0 in
    do:  (![ptrT] "lengthPtr") <-[uint64T] "$a0";;;
    let: "l" := ref_ty ptrT (zero_val ptrT) in
    let: "$a0" := ref_ty sync.Mutex (zero_val sync.Mutex) in
    do:  "l" <-[ptrT] "$a0";;;
    return: (struct.make Log [{
       "d" ::= ![disk.Disk] "d";
       "cache" ::= ![mapT uint64T (sliceT byteT)] "cache";
       "length" ::= ![ptrT] "lengthPtr";
       "l" ::= ![ptrT] "l"
     }]);;;
    do:  #()).

(* disabled since performance is quite poor *)
Definition disabled_testWal : val :=
  rec: "disabled_testWal" <> :=
    exception_do (let: "ok" := ref_ty boolT #true in
    let: "lg" := ref_ty Log (zero_val Log) in
    let: "$a0" := New #() in
    do:  "lg" <-[Log] "$a0";;;
    (if: (Log__BeginTxn (![Log] "lg")) #()
    then
      do:  (Log__Write (![Log] "lg")) #2 (intToBlock #11);;;
      do:  #()
    else do:  #());;;
    let: "$a0" := (![boolT] "ok") && ((blockToInt ((Log__Read (![Log] "lg")) #2)) = #11) in
    do:  "ok" <-[boolT] "$a0";;;
    let: "$a0" := (![boolT] "ok") && ((blockToInt ((__Read (![disk.Disk] (struct.field_ref Log "d" "lg"))) #0)) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    do:  (Log__Commit (![Log] "lg")) #();;;
    let: "$a0" := (![boolT] "ok") && ((blockToInt ((__Read (![disk.Disk] (struct.field_ref Log "d" "lg"))) #0)) = #1) in
    do:  "ok" <-[boolT] "$a0";;;
    do:  (Log__Apply (![Log] "lg")) #();;;
    let: "$a0" := (![boolT] "ok") && ((![uint64T] (![ptrT] (struct.field_ref Log "length" "lg"))) = #0) in
    do:  "ok" <-[boolT] "$a0";;;
    return: (![boolT] "ok");;;
    do:  #()).
