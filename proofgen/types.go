package proofgen

import (
	"fmt"
	"github.com/goose-lang/goose/glang"
	"go/ast"
	"go/token"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io"
	"log"
	"strings"
)

type typesTranslator struct {
	pkg *packages.Package

	deps        map[string][]string
	currentName string
	defs        map[string]string
	defNames    []string

	importsList []string
	importsSet  map[string]struct{}
}

// Adding a "'" to avoid conflicting with Coq keywords and definitions that
// would already be in context (like `t`). Could do this only when there is a
// conflict, but it's lower entropy to do it always rather than pick and
// choosing when.
func toCoqName(n string) string {
	return n + "'"
}

func (tr *typesTranslator) setCurrent(s string) {
	if tr.currentName != "" {
		panic("recordgen: setting currentName before unsetting")
	}
	tr.currentName = s
}

func (tr *typesTranslator) unsetCurrent() {
	tr.currentName = ""
}

func (tr *typesTranslator) addDep(s string) {
	tr.deps[tr.currentName] = append(tr.deps[tr.currentName], s)
}

func (tr *typesTranslator) Decl(d ast.Decl) {
	info := tr.pkg.TypesInfo
	switch d := d.(type) {
	case *ast.FuncDecl:
	case *ast.GenDecl:
		switch d.Tok {
		case token.TYPE:
			for _, spec := range d.Specs {
				spec := spec.(*ast.TypeSpec)
				if s, ok := info.TypeOf(spec.Type).(*types.Struct); ok {
					name := spec.Name.Name
					w := new(strings.Builder)
					// Record type
					defName := name + ".t"
					tr.setCurrent(defName)
					defer tr.unsetCurrent()

					fmt.Fprintf(w, "Module %s.\nSection def.\nContext `{ffi_syntax}.\nRecord t := mk {\n", name)
					for i := 0; i < s.NumFields(); i++ {
						t := toCoqType(s.Field(i).Type(), tr.pkg.PkgPath)
						tr.addDep(t)
						fmt.Fprintf(w, "  %s : %s;\n",
							toCoqName(s.Field(i).Name()),
							t,
						)
					}
					fmt.Fprintf(w, "}.\nEnd def.\nEnd %s.\n\n", name)

					// Settable instance
					if s.NumFields() > 0 {
						fmt.Fprintf(w, `
Global Instance settable_%s `+"`{ffi_syntax}"+`: Settable _ :=
  settable! %s.mk <`, name, name)
						sep := ""
						for i := 0; i < s.NumFields(); i++ {
							fmt.Fprintf(w, "%s %s.%s", sep, name, toCoqName(s.Field(i).Name()))
							sep = ";"
						}
						fmt.Fprintf(w, " >.\n")
					}

					fmt.Fprintf(w, `Global Instance into_val_%s `+"`"+`{ffi_syntax} : IntoVal %s.t.
Admitted.

`, name, name,
					)

					// IntoValTyped instance
					fmt.Fprintf(w, `Global Instance into_val_typed_%s `+"`"+`{ffi_syntax} : IntoValTyped %s.t %s.%s :=
{|
`,
						name, name, tr.pkg.Name, name,
					)
					// default_val
					fmt.Fprintf(w, "  default_val := %s.mk", name)
					for i := 0; i < s.NumFields(); i++ {
						fmt.Fprintf(w, " (default_val _)")
					}
					fmt.Fprintf(w, `;
  to_val_has_go_type := ltac:(destruct falso);
  default_val_eq_zero_val := ltac:(destruct falso);
  to_val_inj := ltac:(destruct falso);
  to_val_eqdec := ltac:(solve_decision);
|}.
`)

					// IntoValStructField instances
					for i := 0; i < s.NumFields(); i++ {
						fieldName := s.Field(i).Name()
						instanceName := "into_val_struct_field_" + name + "_" + fieldName
						fmt.Fprintf(w, `Global Instance %s `+"`"+`{ffi_syntax} : IntoValStructField "%s" %s.%s %s.%s.
Admitted.

`,
							instanceName, fieldName, tr.pkg.Name, name, name, toCoqName(fieldName),
						)
					}

					// PureWp instance
					fmt.Fprintf(w, "Instance wp_struct_make_%s `{ffi_semantics} `{!ffi_interp ffi} `{!heapGS Î£}", name)
					for i := 0; i < s.NumFields(); i++ {
						fmt.Fprintf(w, " %s", toCoqName(s.Field(i).Name()))
					}
					fmt.Fprintf(w, ":\n  PureWp True\n    (struct.make %s.%s (alist_val [", tr.pkg.Name, name)
					sep := ""
					for i := 0; i < s.NumFields(); i++ {
						fmt.Fprintf(w, "%s\n      \"%s\" ::= #%s", sep, s.Field(i).Name(), toCoqName(s.Field(i).Name()))
						sep = ";"
					}
					fmt.Fprint(w, "\n    ]))%%V\n    #(")
					fmt.Fprintf(w, "%s.mk", name)
					for i := 0; i < s.NumFields(); i++ {
						fmt.Fprintf(w, " %s", toCoqName(s.Field(i).Name()))
					}
					fmt.Fprintf(w, ").\nAdmitted.\n\n")

					tr.defNames = append(tr.defNames, defName)
					tr.defs[defName] = w.String()
				}
			}
		}
	case *ast.BadDecl:
	default:
	}
}

func translateTypes(w io.Writer, pkg *packages.Package, usingFfi bool, ffi string) {
	fmt.Fprintf(w, "(* autogenerated by goose proofgen (types); do not modify *)\n")
	coqPath := strings.ReplaceAll(glang.ThisIsBadAndShouldBeDeprecatedGoPathToCoqPath(pkg.PkgPath), "/", ".")
	fmt.Fprintf(w, "From New.code Require Import %s.\n", coqPath)
	fmt.Fprintf(w, "From New.golang Require Import theory.\n\n")

	tr := &typesTranslator{
		deps:       make(map[string][]string),
		defs:       make(map[string]string),
		importsSet: make(map[string]struct{}),
		pkg:        pkg,
	}
	for _, f := range pkg.Syntax {
		for _, d := range f.Decls {
			tr.Decl(d)
		}
	}

	// print in sorted order, printing error if there's a cycle
	for _, imp := range tr.importsList {
		fmt.Fprintf(w, "Require New.generatedproof.structs.%s.\n", imp)
	}
	fmt.Fprintf(w, "Axiom falso : False.\n\n") // FIXME: get rid of this
	var printingOrdered []string
	printing := make(map[string]bool)
	printed := make(map[string]bool)
	var printDefAndDeps func(string)

	printDefAndDeps = func(n string) {
		if printed[n] {
			return
		} else if printing[n] {
			log.Fatal("Found a cyclic dependency: ", printingOrdered)
		}

		printingOrdered = append(printingOrdered, n)
		printing[n] = true
		defer func() {
			printingOrdered = printingOrdered[:len(printingOrdered)-1]
			delete(printing, n)
		}()

		for _, depName := range tr.deps[n] {
			printDefAndDeps(depName)
		}
		fmt.Fprintf(w, tr.defs[n])
		printed[n] = true
	}
	for _, d := range tr.defNames {
		printDefAndDeps(d)
	}
}
